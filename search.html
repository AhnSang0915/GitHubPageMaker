<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--    costom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!--    Font Awsome-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!--    웹폰트 추가-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!--    syntax.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />


    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Learn Coding" />
    <link rel="shortcut icon" href="https://AhnSang0915.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://AhnSang0915.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="My Coding Practice Gym" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Learn Coding" />
    <meta property="og:url" content="https://AhnSang0915.github.io/search" />
    <meta property="og:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Learn Coding" />
    <meta name="twitter:url" content="https://AhnSang0915.github.io/" />
    <meta name="twitter:image" content="https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="My Coding Practice Gym" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "My Coding Practice Gym",
        "logo": "https://AhnSang0915.github.io/"
    },
    "url": "https://AhnSang0915.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://AhnSang0915.github.io/assets/built/images/blog-cover1.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://AhnSang0915.github.io/search"
    },
    "description": "Learn Coding"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://AhnSang0915.github.io/">My Coding Practice Gym</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-javascript" role="menuitem"><a href="/tag/javascript/">Javascript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "practice-3": {
        "title": "Python으로 웹 스크래퍼 만들기-2",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python으로 웹 스크래퍼 만들기-2indeed.py파일import osimport csvimport requestsfrom bs4 import BeautifulSoupos.system(\"clear\")def write_company(company):    file = open(f\"{company['name']}.csv\", mode=\"w\")    writer = csv.writer(file)    writer.writerow([\"place\", \"title\", \"time\", \"pay\", \"date\"])    for job in company[\"jobs\"]:      writer.writerow(list(job.values()))    print(f\"Completed....{company['name']}\")alba_url = \"http://www.alba.co.kr\"alba_request = requests.get(alba_url)alba_soup = BeautifulSoup(alba_request.text, \"html.parser\")main = alba_soup.find(\"div\", {\"id\": \"MainSuperBrand\"})brands = main.find_all(\"li\", {\"class\": \"impact\"})for brand in brands:    link = brand.find(\"a\", {\"class\": \"goodsBox-info\"})    name = brand.find(\"span\", {\"class\": \"company\"})    if link and name:        link = link[\"href\"]        name = name.text        if \"/\" in name :          name = name.replace(\"/\",\" \")        company = {'name': name, 'jobs': []}        jobs_request = requests.get(link)        jobs_soup = BeautifulSoup(jobs_request.text, \"html.parser\")        tbody = jobs_soup.find(\"div\", {\"id\": \"NormalInfo\"}).find(\"tbody\")        rows = tbody.find_all(\"tr\", {\"class\": \"\"})        for row in rows:            local = row.find(\"td\", {\"class\": \"local\"})            if local:                local = local.text            title = row.find(\"td\", {\"class\": \"title\"})            if title:                title = title.find(\"a\").find(\"span\", {                    \"class\": \"company\"                }).text.strip()            time = row.find(\"td\", {\"class\": \"data\"})            if time:                time = time.text            pay = row.find(\"td\", {\"class\": \"pay\"})            if pay:                pay = pay.text            date = row.find(\"td\", {\"class\": \"regDate\"})            if date:                date = date.text            job = {                \"place\": local,                \"title\": title,                \"time\": time,                \"pay\": pay,                \"date\": date            }            company['jobs'].append(job)        write_company(company)",
        "url": "/practice-3"
    }
    ,
    
    "python-basic43": {
        "title": "Python - Python 모듈과 패키지 만들기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기모듈과 패키지 만들기파이썬 스크립트를 작성할 때마다 매번 비슷한 클래스와 함수를 작성한다면 코드도 길어지고 중복되는 부분이 생긴다. 이런 경우 공통되는 부분을 빼내 모듈과 패키지로 만든다. 이후 코드를 다시 만들지 않고 모듈과 패키지만 가져와서 사용하면 편리하다.모듈(module)은 변수, 함수, 클래스 등을 모아 놓은 스크립트 파일이고, 패키지(package)는 여러 모듈을 묶은 것이다. 모듈은 간단한 기능을 담을 때 사용하고, 패키지는 코드가 많고 복잡할 때 사용한다. 즉, 패키지는 기능들이 모듈 여러 개로 잘게 나누어져 있고, 관련된 모듈끼리 폴더에 모여 있는 형태이다.1.모듈 만들기그럼 간단하게 2의 거듭제곱을 구하는 모듈을 만들어보자. 다음 내용을 작업환경에 저장한다. square2로 저장한다.base = 2          # 변수 def square(n):    # 함수    return base ** n모듈 사용하기위에서 만든 모듈과 같은 폴더에 파일을 저장하고 실행해보자.  import 모듈  모듈.변수  모듈.함수()import square2               # import로 square2 모듈을 가져옴 print(square2.base)          # 모듈.변수 형식으로 모듈의 변수 사용print(square2.square(10))    # 모듈.함수() 형식으로 모듈의 함수 사용 2의10승실행 결과21024from import로 변수, 함수 가져오기모듈에서 from import로 변수와 함수를 가져온 뒤 모듈 이름을 붙이지 않고 사용할 수도 있다.  from 모듈 import 변수, 함수from square2 import base, squareprint(base)2square(10)1024모듈에 클래스 작성하기그럼 이번에는 모듈에 클래스를 작성하고 사용해보자. 다음 내용을 작업 폴더 안에 person.py 파일로 저장한다.class Person:    # 클래스    def __init__(self, name, age, address):        self.name = name        self.age = age        self.address = address     def greeting(self):        print('안녕하세요. 저는 {0}입니다.'.format(self.name))이제 main2 파일을 다음과 같이 작성해 실행한다.  import 모듈  모듈.클래스()모듈의 클래스를 사용하는 방법도 변수, 함수와 같다. 즉, 모듈.클래스()형식으로 모듈의 클래스를 사용하며, 클래스로 인스턴스를 만들 때는 person.Person(‘마리아’, 20, ‘서울시 서초구 반포동’)와 같이 사용하면 된다.from import로 클래스 가져오기물론 모듈에서 from import로 클래스를 가져온 뒤 모듈 이름을 붙이지 않고 사용할 수도 있다.  from 모듈 import 클래스from person import Personmaria = Person('마리아', 20, '서울시 서초구 반포동')maria.greeting()안녕하세요. 저는 마리아입니다.–2.모듈과 시작점 알아보기인터넷에 있는 파이썬 코드를 보다 보면 if name == ‘main‘:으로 시작하는 부분을 자주본다.if __name__ == '__main__':    코드위 코드는 현재 스크립트 파일이 실행되는 상태를 파악하기 위해 사용한다.먼저 __name__부터 알아보자. 다음 내용을 작업폴더에 hello파일로 저장한다.print('hello 모듈 시작')print('hello.py __name__:', __name__)    # __name__ 변수 출력print('hello 모듈 끝')그리고 hello파일의 내용을 main3에 저장한뒤 실행해보자.실행을 해보면 hello.py 파일과 main3.py 파일의 __name__ 변수 값이 출력된다.파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행된다. 따라서 hello 모듈을 가져오면 hello.py 안의 코드가 실행된다. 따라서 hello.py의 __name__ 변수에는 ‘hello’가 들어가고, main3.py의 __name__ 변수에는 ‘__main3__‘이 들어간다.import hello    # hello 모듈을 가져옴 print('main.py __name__:', __name__)    # __name__ 변수 출력# 실행 결과hello 모듈 시작hello.py __name__: hellohello 모듈 끝main.py __name__: __main3__즉, __name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의 이름이 들어간다. 하지만 파이썬 파이썬 인터프리터로 스크립트 파일을 직접 실행했을 때는 모듈의 이름이 아니라 ‘__main__‘이 들어간다.좀 더 정확하게 알아보기 위해 콘솔에서 실행해보자. python main.py와 같이 파이썬으로 스크립트 파일을 직접 실행했다. 여기서도 hello.py 파일의 __name__ 변수에는 ‘hello’ 그리고 main.py 파일의 __name__ 변수에는 ‘__main__‘이 들어간다C:\\project&gt;python main.pyhello 모듈 시작hello.py __name__: hellohello 모듈 끝main.py __name__: __main__하지만 다음과 같이 python으로 hello.py파일을 실행해보면 결과가 달라진다. hello.py파일의 __name__ 변수에는 ‘hello’가 아니라 ‘__main__‘이 들어간다. 즉, 어떤 스크립트 파일이든 파이썬 인터프리터가 최초로 실행한 스크립트 파일의 name__에는 ‘__main‘이 들어간다. 이는 프로그램의 시작점(entry point)이라는 뜻이다.C:\\project&gt;python hello.pyhello 모듈 시작hello.py __name__: __main__hello 모듈 끝파이썬은 최초로 시작하는 스크립트 파일과 모듈의 차이가 없다. 어떤 스크립트 파일이든 시작점도 될 수 있고, 모듈도 될 수 있다. 그래서 __name__ 변수를 통해 현재 스크립트 파일이 시작점인지 모듈인지 판단한다.if __name__ == ‘__main__‘:처럼 __name__ 변수의 값이 ‘__main__‘인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업이다. 즉, 스크립트 파일이 메인 프로그램으로 사용될 때와 모듈로 사용될 때를 구분하기 위한 용도이다.스크립트 파일로 실행하거나 모듈로 사용하는 코드 만들기그럼 스크립트 파일을 그대로 실행할 수도 있고, 모듈로도 사용할 수 있는 코드를 만들어보자. 다음 내용을 프로젝트 폴더(C:\\project) 안에 calc.py 파일로 저장한 뒤 실행해보자.def add(a, b):    return a + b def mul(a, b):    return a * b if __name__ == '__main__':    # 프로그램의 시작점일 때만 아래 코드 실행    print(add(10, 20))    print(mul(10, 20))# 실행 결과30200IDLE에서 실행하거나 python calc.py와 같이 파이썬 인터프리터로 실행하면 10, 20의 합과 곱이 출력된다. 즉, 프로그램의 시작점일 때는 if name == ‘main’: 아래의 코드가 실행된다.그럼 calc.py를 모듈로 사용하면 어떻게 될까요? 다음과 같이 import로 calc를 가져와보자.import calc#실행 결과모듈로 가져왔을때는 아무것도 출력되지 않는다. 왜냐하면 __name__ 변수 값이 ‘__main__‘일 때만 10, 20의 합과 곱을 출력하도록 만들었기 때문이다. 즉, 스크립트 파일을 모듈로 사용할 때는 calc.add, calc.mul처럼 함수만 사용하는 것이 목적임으로 10,20의 합과 곱을 출력하지 않는다.모듈로 사용하려면 다음과 같이 calc.add와 calc.mul함수에 원하는 값을 넣어서 사용하면 된다.calc.add(50, 60)110calc.mul(50, 60)30003. 패키지 만들기이번에는 패키지를 만들어보자. 모듈은 스크립트 파일이 한 개지만 패키지는 폴더(디렉토리)로 구성되어 있다.지금부터 만들 패키지의 폴더 구성은 다음과 같다.project &gt; main.py calcpkgcalcpkg&gt; __init__, operation.py, geometry.py먼저 프로젝트 폴더(C:\\project) 안에 calcpkg 폴더를 만들고 다음 내용을 calcpkg 폴더 안에 __init__.py 파일로 저장한다.폴더(디렉터리) 안에 init.py 파일이 있으면 해당 폴더는 패키지로 인식됩니다. 그리고 기본적으로 init.py 파일의 내용은 비워 둘 수 있다.# __init__.py 파일은 내용을 비워 둘 수 있음패키지에 모듈 만들기이제 calcpkg 패키지에 모듈을 두 개를 만들어야한다. 첫 번째 모듈은 덧셈, 곱셈 함수가 들어있는 operation 모듈이고, 두 번째 모듈은 삼각형, 사각형의 넓이 계산 함수가 들어있는 geometry 모듈이다.먼저 다음 내용을 calcpkg 폴더 안에 operation.py 파일로 저장한다.def add(a, b):    return a + b def mul(a, b):    return a * b그리고 다음 내용을 calcpkg 폴더 안에 geometry 파일로 저장한다.def triangle_area(base, height):    return base * height / 2 def rectangle_area(width, height):    return width * height패키지 사용하기이제 스크립트 파일에서 패키지의 모듈을 사용해보자. 다음 내용을 프로젝트 폴더(C:\\project) 안에 main.py 파일로 저장한 뒤 실행한다(main.py 파일을 calcpkg 패키지 폴더 안에 넣으면 안 된다).  import 패키지.모듈  패키지.모듈.변수  패키지.모듈.함수()  패키지.모듈.클래스()calcpkg 패키지의 operation 모듈과 geometry 모듈을 가져와서 안에 들어있는 함수를 호출했다.이처럼 패키지의 모듈을 가져올 때는 import 패키지.모듈 형식으로 가져온다. 그리고 패키지.모듈.함수() 형식으로 모듈의 함수를 사용한다(변수와 클래스도 같은 형식).import calcpkg.operation    # calcpkg 패키지의 operation 모듈을 가져옴import calcpkg.geometry     # calcpkg 패키지의 geometry 모듈을 가져옴 print(calcpkg.operation.add(10, 20))    # operation 모듈의 add 함수 사용print(calcpkg.operation.mul(10, 20))    # operation 모듈의 mul 함수 사용 print(calcpkg.geometry.triangle_area(30, 40))    # geometry 모듈의 triangle_area 함수 사용print(calcpkg.geometry.rectangle_area(30, 40))   # geometry 모듈의 rectangle_area 함수 사용# 실행 결과30200600.01200from import로 패키지의 모듈에서 변수, 함수, 클래스 가져오기물론 패키지의 모듈에서 from import로 함수(변수, 클래스)를 가져온 뒤 패키지와 모듈 이름을 붙이지 않고 사용할 수도 있다.  from 패키지.모듈 import 변수  from 패키지.모듈 import 함수  from 패키지.모듈 import 클래스다음은 calcpkg 패키지의 operation 모듈에서 add, mul 함수를 가져온다.from calcpkg.operation import add, muladd(10, 20)30mul(10, 20)200패키지의 모듈과 name패키지의 모듈에서는 name 변수에 패키지.모듈 형식으로 이름이 들어간다. 즉, calcpkg 패키지의 geometry.py에서 __name__의 값을 출력하도록 만들고, import로 가져오면 ‘calcpkg.geometry’가 나온다.4. 패키지에서 from import 응용하기지금까지 calcpkg 패키지의 모듈을 가져올 때 import calcpkg.operation처럼 import 패키지.모듈 형식으로 가져왔다. 그러면 그러면 import calcpkg처럼 import 패키지 형식으로 패키지만 가져와서 모듈을 사용할 수는 없을까? 이때는 calcpkg 패키지의 init.py 파일을 다음과 같이 수정한다.from . import operation    # 현재 패키지에서 operation 모듈을 가져옴from . import geometry     # 현재 패키지에서 geometry 모듈을 가져옴파이썬 에서 __init__.py파일은 폴더가 패키지로 인식되도록 하는 역할도 하고, 이름 그대로 패키지를 초기화하는 역할도 한다. 즉, import로 패키지를 가져오면 __init__.py 파일이 실행되므로 이 파일에서 from.import 모듈 형식으로 현재 패키지에서 모듈을 가져오게 만들어야 한다. 참고로 .(점)은 현재 패키지라는 뜻이다.이제 main.py에서 import calcpkg와 같이 패키지만 가져오도록 수정한 뒤 실행해보자.import calcpkg    # calcpkg 패키지만 가져옴 print(calcpkg.operation.add(10, 20))    # operation 모듈의 add 함수 사용print(calcpkg.operation.mul(10, 20))    # operation 모듈의 mul 함수 사용 print(calcpkg.geometry.triangle_area(30, 40))    # geometry 모듈의 triangle_area 함수 사용print(calcpkg.geometry.rectangle_area(30, 40))   # geometry 모듈의 rectangle_area 함수 사용calcpkg의 __init__.py에서 하위 모듈을 함께 가져오게 만들었으므로 import calcpkg로 패키지만 가져와도 calcpkg.operation.add(10, 20)처럼 사용할 수 있다.from import로 패키지에 속한 모든 변수, 함수, 클래스 가져오기앞에서 form import 문법 중에  *(애스터리스크)를 지정하여 모든 변수, 함수, 클래스를 가져오는 방법이 있었다. 패키지에 속한 모든 변수, 함수, 클래스를 가져오려면 먼저 main.py에서 import calcpkg를 from calcpkg import *와 같이 수정하고, 각 함수들도 앞에 붙은 calcpkg.operation, calcpkg.geometry를 삭제한 뒤 실행해보자.  from 패키지 import *from calcpkg import *    # calcpkg 패키지의 모든 변수, 함수, 클래스를 가져옴 print(add(10, 20))    # operation 모듈의 add 함수 사용print(mul(10, 20))    # operation 모듈의 mul 함수 사용 print(triangle_area(30, 40))    # geometry 모듈의 triangle_area 함수 사용print(rectangle_area(30, 40))   # geometry 모듈의 rectangle_area 함수 사용# 실행 결과Traceback (most recent call last):  File \"C:\\project\\main.py\", line 3, in &lt;module&gt;    print(add(10, 20))    # operation 모듈의 add 함수 사용NameError: name 'add' is not defined 실행을 해보면 add가 정의되지 않았다면서 에러가 발생한다. 왜냐하면 init.py에서 모듈만 가져왔을 뿐 모듈 안의 함수는 가져오지 않았기 때문이다.IDLE의 파이썬 프롬프트에서 dir 함수를 호출하여 현재 네임스페이스(namespace, 이름공간)를 확인해보자(main.py 안에서 print(dir())을 호출하고 main.py를 실행해도 됨).&gt;&gt;&gt; dir()['__annotations__', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'geometry', 'operation']현재 네임스페이스에는 operation, geometry만 들어있어서 add, mul처럼 함수 이름만으로는 호출할 수가 없다.이때는 __init__.py에서 모듈 안의 함수를 가져오게 만들어야 한다. 특히 현재 패키지(calcpkg)라는 것을 명확하게 나타내기 위해 모듈 앞에 .(점)을 붙인다.  from .모듈 import 변수, 함수, 클래스이제 main.py 파일을 실행해보면 결과도 잘 출력되고 add, mul, triangle_area, rectangle_area처럼 함수 이름 그대로 호출할 수 있다.# 현재 패키지의 operation, geometry 모듈에서 각 함수를 가져옴from .operation import add, mulfrom .geometry import triangle_area, rectangle_area# 실행 결과30200600.01200물론 init.py 파일에서 특정 함수(변수, 클래스)를 지정하지 않고 *을 사용해서 모든 함수(변수, 클래스)를 가져와도 상관없다.  from .모듈 import *from .operation import *    # 현재 패키지의 operation 모듈에서 모든 변수, 함수, 클래스를 가져옴from .geometry import *     # 현재 패키지의 geometry 모듈에서 모든 변수, 함수, 클래스를 가져옴이렇게 패키지의 __init__.py에서 from .모듈 import 변수, 함수, 클래스 또는 from .모듈 import * 형식으로 작성했다면 패키지를 가져오는 스크립트에서는 패키지.함수() 형식으로 사용할 수 있습니다(변수, 클래스도 같은 형식). 이때는 import calcpkg와 같이 패키지만 가져오면 됩니다.  import 패키지  패키지.변수  패키지.함수()  패키지.클래스()__init__.py에서 from .모듈 import 변수, 함수, 클래스 또는 from .모듈 import * 형식으로 모듈을 가져오면 calcpkg 패키지의 네임스페이스에는 add, mul, triangle_area, rectangle_area가 들어간다. 따라서 모듈을 거치지 않고 calcpkg.add처럼 패키지에서 함수를 바로 사용할 수 있다.import calcpkg    # calcpkg 패키지만 가져옴 print(calcpkg.add(10, 20))   # 패키지.함수 형식으로 operation 모듈의 add 함수 사용print(calcpkg.mul(10, 20))   # 패키지.함수 형식으로 operation 모듈의 mul 함수 사용 print(calcpkg.triangle_area(30, 40)) # 패키지.함수 형식으로 geometry 모듈의 triangle_area 함수 사용print(calcpkg.rectangle_area(30, 40))# 패키지.함수 형식으로 geometry 모듈의 rectangle_area 함수 사용# 실행 결과30200600.01200__all__로 필요한 것만 공개하기패키지의 init.py에서 from .모듈 import 로 모든 변수, 함수, 클래스를 가져오면 패키지 외부에 공개하고 싶지 않은 것까지 공개하게 된다. 이때는 __all__에 공개할 모듈, 변수, 함수, 클래스를 리스트 형태로 지정해주면 된다. __all__이라는 이름 그대로 모든 것()을 가져갈 때의 목록을 정한다.__all__ = ['add', 'triangle_area']    # calcpkg 패키지에서 add, triangle_area 함수만 공개 from .operation import *    # 현재 패키지의 operation 모듈에서 모든 변수, 함수, 클래스를 가져옴from .geometry import *     # 현재 패키지의 geometry 모듈에서 모든 변수, 함수, 클래스를 가져옴from calcpkg import *    # calcpkg 패키지의 모든 변수, 함수, 클래스를 가져옴 print(add(10, 20))    # add 함수는 공개되어 있으므로 사용할 수 있음print(mul(10, 20))    # 에러: mul 함수는 공개되어 있지 않으므로 사용할 수 없음 print(triangle_area(30, 40))    # triangle_area 함수는 공개되어 있으므로 사용할 수 있음print(rectangle_area(30, 40))   # 에러: rectangle_area 함수는 공개되어 있으므로 사용할 수 있음main.py에서 from calcpkg import *로 패키지의 모든 변수, 함수, 클래스를 가져온다 하더라도 __all__에 지정된 add, triangle_area 함수만 사용할 수 있다.30Traceback (most recent call last):  File \"C:\\project\\main.py\", line 4, in &lt;module&gt;    print(mul(10, 20))    # 에러: mul 함수는 공개되어 있지 않으므로 사용할 수 없음NameError: name 'mul' is not defined하위 패키지 사용하기파이썬의 패키지는 패키지 안에 하위 패키지를 만들 수 있다. 즉, 패키지 안에 폴더(디렉터리)를 만들고 init.py와 모듈을 넣으면 하위 패키지가 된다.예를 들어서 다음과 같이 calcpkg 안에 operation과 geometry 하위 패키지가 있고, 그 아래에 모듈이 들어있다.import로 하위 패키지의 모듈을 가져올 때는 계층 순서대로 .(점)을 붙여서 가져오면 됩니다.  import 패키지.하위패키지.모듈즉, import calcpkg.operation.element와 같은 식입니다. 함수를 사용할 때는 calcpkg.operation.element.add(10, 20)이 되겠다.만약, import calcpkg처럼 패키지만 가져와서 사용하고 싶다면 calcpkg/__init__.py에서 하위 패키지의 모듈에 들어있는 변수, 함수, 클래스를 모두 가져오게 만들면 된다.from .operation.element import *from .operation.logic import *from .geometry.shape import *from .geometry.vector import *이렇게 하면 calcpkg.add(10, 20), calcpkg.triangle_area(30, 40) 또는, add(10, 20), triangle_area(30, 40)처럼 사용할 수 있다.참고로 하위 패키지 안에서 옆에 있는 패키지의 요소를 가져와서 사용하려면 ..을 사용해야 합니다. ..은 상위 폴더(디렉터리)라는 뜻이며 ..패키지 또는 ..모듈은 상위 폴더에 있는 패키지, 모듈이라는 뜻이다. 즉, 현재 패키지와 같은 계층의 패키지 또는 모듈이다. 그리고 …은 상위 폴더의 상위 폴더라는 뜻이며 위로 갈 수록 .이 하나씩 늘어난다.      from ..패키지 import 모듈        from ..패키지.모듈 import 클래스, 변수, 함수        from ..패키지.모듈 import *  예를 들어 calcpkg/geometry/shape.py에서 옆에 있는 calcpkg/operation 패키지의 element 모듈을 사용한다면 다음과 같이 from ..operation import element로 지정해준다. 또는, from ..operation.element import mul과 같이 지정하면 mul을 함수 그대로 사용할 수 있다.from ..operation import element             # from ..operation.element import mul로도 가능 def triangle_area(base, height):    return element.mul(base, height) / 2    # mul(base, height)로도 가능 def rectangle_area(width, height):    return element.mul(width, height)       # mul(width, height)로도 가능모듈과 패키지의 독스트링모듈의 독스트링은 모듈 파일의 첫 줄에 “”” “”“(큰따옴표 세 개) 또는 ‘’’ ‘’‘(작은따옴표 세 개)를 사용하여 문자열을 넣는다.'''모듈의 독스트링'''패키지의 독스트링은 __init__.py 파일의 첫 줄에 “”” “”“(큰따옴표 세 개) 또는 ‘’’ ‘’‘(작은따옴표 세 개)를 사용하여 문자열을 넣는다.'''패키지의 독스트링'''모듈과 패키지의 독스트링을 출력하려면 모듈 또는 패키지의 __doc__를 출력하면 된다.모듈.__doc__패키지.__doc__예제1다음 소스 코드를 완성하여 from database import * 형식으로 패키지를 사용할 수 있게 만드세요. 여기서는 database 패키지 안에 sqlite 패키지가 들어있습니다.# database/__init__.py _______________________                                # database/sqlite/__init__.py# 내용이 비어 있음# database/sqlite/dbapi.pydef connect(database):    print(database)# practice_package.pyfrom database import * connect(':memory:')# 실행 결과:memmory:답from .sqlite.dbapi import *예제2표준 입력으로 정수가 입력됩니다. 주어진 calcpkg 패키지를 활용하여 입력된 정수의 제곱근과 입력된 정수를 반지름으로 하는 원의 넓이가 출력되게 만드세요. 제곱근은 calcpkg 패키지에서 operation 모듈의 squareroot 함수를 사용하고, 원의 넓이는 calcpkg 패키지에서 geometry 모듈의 circle_area 함수를 사용하세요(calcpkg 패키지를 사용하지 않고 계산하면 결과가 맞더라도 틀린 것으로 처리됩니다. 반드시 calcpkg 패키지를 사용하세요).# calcpkg/__init__.py# 내용이 비어 있음# calcpkg/operation.pyimport math def squareroot(n):    return math.sqrt(n)# calcpkg/geometry.pyimport math def circle_area(radius):    return radius * radius * math.pi________________________________________________# 표준 입력2# 표준 출력1.414213562373095112.566370614359172답import calcpkg.operationimport calcpkg.geometryn = int(input())print(calcpkg.operation.squareroot(n))print(calcpkg.geometry.circle_area(n))",
        "url": "/python-basic43"
    }
    ,
    
    "python-basic42": {
        "title": "Python - Python 모듈과 패키지 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기모듈과 패키지 사용하기파이썬 내장함수로는 할 수 있는게 별로없다. 그래서 좀 더 복잡한 프로그램을 만들려면 파이썬의 모듈과 패키지를 사용해야 한다. 중간에 사용했던 random, turtle, pickle 등이 바로 모듈과 패키지이다.모듈(module)은 각종 변수, 함수, 클래스를 담고 있는 파일이고, 패키지(package)는 여러 모듈을 묶은 것이다. 파이썬을 설치할 때 다양한 모듈과 패키지가 기본으로 설치된다. 만약 기본 모듈과 패키지로 부족하다면 다른 사람이 만든 유명 모듈과 패키지를 설치해서 쓸 수도 있다.      모듈: 특정 기능을 .py 파일 단위로 작성한 것입니다.        패키지: 특정 기능과 관련된 여러 모듈을 묶은 것입니다. 패키지는 모듈에 네임스페이스(namespace, 이름공간)를 제공합니다.        파이썬 표준 라이브러리: 파이썬에 기본으로 설치된 모듈과 패키지, 내장 함수를 묶어서 파이썬 표준 라이브러리(Python Standard Library, PSL)라 부릅니다.  1.import로 모듈 가져오기모듈은 import 키워드로 가져올 수 있다.  import 모듈  import 모듈1, 모듈2  모듈.변수  모듈.함수()  모듈.클래스()그럼 간단한 파이썬 표준 라이브러리의 수학 모듈 math를 가져와 원주율을 출력해보자.import에 모듈 이름을 지정하면 해당 모듈을 가져올 수 있으며 math.pi와 같이 모듈.변수 형식으로 모듈의 변수를 사용한다.import mathmath.pi3.141592653589793이번에는 math 모듈의 제곱근 함수 sqrt를 사용해보자.모듈의 함수는 math.sqrt(4.0)와 같이 모듈.함수() 형식으로 사용한다.import mathmath.sqrt(4.0)2.0math.sqrt(2.0)1.4142135623730951import as로 모듈 이름 지정하기모듈의 함수를 사용할 때 매번 math를 입력하지 않아도 impor as로 모듈의 이름을 지정할 수 있다.  import 모듈 as 이름이제 math 모듈을 m으로 줄여보자. import math as m과 같이 모듈을 가져오면서 as 뒤에 이름을 지정해준다. 이후 math 모듈을 사용할 때 m으로 줄여서 사용할 수 있다.import math as m    # math 모듈을 가져오면서 이름을 m으로 지정m.sqrt(4.0)         # m으로 제곱근 함수 사용2.0m.sqrt(2.0)         # m으로 제곱근 함수 사용1.4142135623730951from import로 모듈의 일부만 가져오기from math import pi와 같이 from 뒤에 모듈 이름을 지정하고 import 뒤에 가져올 변수를 입력한다. 이후 가져온 변수를 사용할 때는 pi와 같이 모듈 이름을 붙이지 않고 바로 사용하면된다.  from 모듈 import 변수다음은 math 모듈에서 변수 pi만 가져온다. from math import pi와 같이 from 뒤에 모듈 이름을 지정하고 import 뒤에 가져올 변수를 입력한다. 이후 가져온 변수를 사용할 때는 pi와 같이 모듈 이름을 붙이지 않고 바로 사용하면 된다.from math import pi    # math 모듈에서 변수 pi만 가져옴pi                     # pi를 바로 사용하여 원주율 출력3.141592653589793이번에는 모듈의 함수를 가져와보자.  from 모듈 import 함수  from 모듈 import 클래스다음은 math 모듈에서 sqrt 함수만 가져왔다. math 모듈에서 sqrt 함수만 가져왔으므로 sqrt(4.0)처럼 앞에 math를 붙이지 않고 함수를 바로 사용할 수 있다.from math import sqrt    # math 모듈에서 sqrt 함수만 가져옴sqrt(4.0)                # sqrt 함수를 바로 사용2.0sqrt(2.0)                # sqrt 함수를 바로 사용1.4142135623730951변수나 함수 하나를 가져오는게 아닌 여러개를 import 뒤에 가져올 변수, 함수, 클래스를 콤마로 구분하여 한번에 불러올 수 있다.  from 모듈 import 변수, 함수, 클래스다음은 math 모듈에서 pi, sqrt를 가져온다. from math import pi, sqrt와 같이 pi와 sqrt 두 개를 가져왔다.from math import pi, sqrt    # math 모듈에서 pi, sqrt를 가져옴pi                           # pi로 원주율 출력3.141592653589793sqrt(4.0)                    # sqrt 함수 사용2.0sqrt(2.0)                    # sqrt 함수 사용1.4142135623730951변수, 함수, 클래스가 수십가지라면 위의 방법으로 입력하기 불편하다. for import를 사용하면 모듈의 모든 변수, 함수, 클래스를 가져올 수 있다.  from 모듈 import *다음은 math 모듈의 모든 변수, 함수, 클래스를 가져온다. from math import *와 같이 지정하면 math 모듈의 모든 함수, 변수, 클래스를 가져온다.from math import *    # math 모듈의 모든 변수, 함수, 클래스를 가져옴pi                    # pi로 원주율 출력3.141592653589793sqrt(4.0)             # sqrt 함수 사용2.0sqrt(2.0)             # sqrt 함수 사용1.4142135623730951from import로 모듈의 일부만 가져오기이번에는 from import로 변수, 함수, 클래스를 가져온 뒤 이름을 지정해보자.  from 모듈 import 변수 as 이름  from 모듈 import 함수 as 이름  from 모듈 import 클래스 as 이름다음은 math 모듈에서 sqrt 함수를 가져오면서 이름을 s로 지정한다. from import로 가져온 변수, 함수, 클래스 뒤에 as로 이름을 지정해주면 된다.from math import sqrt as s    # math 모듈에서 sqrt 함수를 가져오면서 이름을 s로 지정s(4.0)                        # s로 sqrt 함수 사용2.0s(2.0)                        # s로 sqrt 함수 사용1.4142135623730951여러개를 가져올 경우 각 변수, 함수, 클래스 등을 콤마로 구분하여 as를 여러 개 지정하면 된다.  from 모듈 import 변수 as 이름1, 함수 as 이름2, 클래스 as 이름3다음은 math 모듈의 pi를 가져오면서 이름을 p로, sqrt를 가져오면서 이름을 s로 지정한다.from math import pi as p, sqrt as sp         # p로 원주율 출력3.141592653589793s(4.0)    # s로 sqrt 함수 사용2.0s(2.0)    # s로 sqrt 함수 사용1.4142135623730951가져온 모듈 해제하기, 다시 가져오기import로 가져온 모듈(변수, 함수, 클래스)은 del로 해제할 수 있다.import mathdel math모듈을 다시 가져오려면 importlib.reload를 사용한다.import importlibimport mathimportlib.reload(math)–2.import로 패키지 가져오기패키지는 특정 기능과 관련된 여러 모듈을 묶은 것인데, 패키지에 들어있는 모듈도 import를 사용하여 가져온다.  import 패키지.모듈  import 패키지.모듈1, 패키지.모듈2  패키지.모듈.변수  패키지.모듈.함수()  패키지.모듈.클래스()파이썬 표준 라이브러리에서 urllib 패키지의 request 모듈을 가져와 url주소의 응답을 받아왔다.패키지에 들어있는 모듈은 import urllib.request와 같이 패키지.모듈 형식으로 가져온다. 마찬가지로 모듈의 함수를 사용할 때도 urllib.request.urlopen()과 같이 패키지.모듈.함수() 형식으로 패키지 이름과 모듈 이름을 모두 입력해준다.import urllib.requestresponse = urllib.request.urlopen('http://www.google.co.kr')response.status200import as로 패키지 모듈 이름 지정하기패키지 안에 들어있는 모듈도 import as를 사용하여 이름을 지정할 수 있다.  import 패키지.모듈 as 이름다음은 urllib 패키지의 request 모듈을 가져오면서 이름을 r로 지정한다.import urllib.request as r    # urllib 패키지의 request 모듈을 가져오면서 이름을 r로 지정response = r.urlopen('http://www.google.co.kr')    # r로 urlopen 함수 사용response.status200from import로 패키지의 모듈에서 일부만 가져오기패키지도 from import를 사용하여 모듈에서 변수, 함수, 클래스를 가져올 수 있다.  from 패키지.모듈 import 변수  from 패키지.모듈 import 함수  from 패키지.모듈 import 클래스  from 패키지.모듈 import 변수, 함수, 클래스다시 urllib 패키지의 request 모듈에서 urlopen 함수와 Request 클래스를 가져와 보겠자.from urllib.request import Request, urlopen    # urlopen 함수, Request 클래스를 가져옴req = Request('http://www.google.co.kr')       # Request 클래스를 사용하여 req 생성response = urlopen(req)                        # urlopen 함수 사용response.status200참고로 urlopen 함수에 URL을 바로 넣어도 되고, Request(‘http://www.google.co.kr’)와 같이 Request 클래스에 URL을 넣은 뒤에 req를 생성해서 urlopen 함수에 넣어도 된다.패키지의 모듈에서 모든 변수, 함수, 클래스를 가져오는 방법은 다음과 같다.  from 패키지.모듈 import *다음은 urllib의 request 모듈에서 모든 변수, 함수, 클래스를 가져온다.from urllib.request import *     # urllib의 request 모듈에서 모든 변수, 함수, 클래스를 가져옴req = Request('http://www.google.co.kr')    # Request를 사용하여 req 생성response = urlopen(req)                     # urlopen 함수 사용response.status2003. 파이썬 패키지 인덱스에서 패키지 설치하기파이썬은 파이썬 표준 라이브러리(Python Standard Library, PSL) 이외에도 파이썬 패키지 인덱스(Python Package Index, PyPI)를 통해 다양한 패키지를 사용할 수 있다. 특히 명령만 입력하면 원하는 패키지를 인터넷에서 다운로드하여 설치해줄 뿐만 아니라 관련된 패키지(의존성)까지 자동으로 설치해주므로 매우 편리하다.pip 설치하기pip는 파이썬 패키지 인덱스의 패키지 관리 명령어이며 Windows용 파이썬에는 기본으로 내장되어 있다. 리눅스와 macOS에서는 콘솔(터미널)에서 다음과 같은 방법으로 설치하면 된다.$ curl -O https://bootstrap.pypa.io/get-pip.py$ sudo python3 get-pip.pypip로 패키지 설치하기이제 pip install 명령으로 패키지를 설치해보자.  pip install 패키지Windows에서는 명령 프롬프트를 실행(윈도우 키+R을 누른 뒤 cmd를 입력)하고, 리눅스와 macOS에서는 콘솔(터미널)을 실행한 뒤 pip install requests 명령을 입력한다(pip 명령은 파이썬 셸 »&gt;에 입력하면 안 된다. 반드시 명령 프롬프트, 콘솔, 터미널에 입력).참고로 requests는 파이썬 표준 라이브러리의 urllib.request와 비슷한 역할을 하는 패키지인데 좀 더 기능이 많고 편리하다.C:\\Users\\dojang&gt;pip install requests리눅스, macOS에서는 앞에 sudo를 붙여서 관리자 권한으로 실행합니다.$ sudo pip install requests또는, python에 -m 옵션을 지정해서 pip를 실행할 수도 있다. -m 옵션은 모듈을 실행하는 옵션이며 pip도 모듈이다.C:\\Users\\dojang&gt;python -m pip install requests리눅스, macOS에서는 python3으로 실행하고, 앞에 sudo를 붙여서 관리자 권한으로 실행한다.$ sudo python3 -m pip install requests명령을 입력하면 패키지 다운로드 및 설치 상황이 표시되는데, 다음과 같이 출력되면 정상적으로 설치된 것이다.Collecting requests  Downloading requests-2.9.1-py2.py3-none-any.whl (501kB)    100% |################################| 503kB 974kB/sInstalling collected packages: requestsSuccessfully installed requests-2.9.1import로 패키지 가져오기이제 파이썬 코드에서 패키지를 사용해보자.  import 패키지보통 pip install 명령으로 설치한 패키지는 import 패키지 또는 import 패키지.모듈 형식으로 사용하면 된다. 단, 패키지마다 구성이 다를 수 있으므로 해당 패키지의 웹 사이트에서 사용 방법을 찾아봐야한다.import requests                                # pip로 설치한 requests 패키지를 가져옴r = requests.get('http://www.google.co.kr')    # requests.get 함수 사용r.status_code200예제1다음 소스 코드를 완성하여 소수점 이하를 올림, 버림한 숫자가 출력되게 만드세요. 올림 함수는 math 모듈의 ceil, 버림 함수는 math 모듈의 floor 함수입니다. _______________________                                x = 1.5 print(ceil(x), floor(x))#실행 결과2 1답from math import ceil, floor예제2표준 입력으로 URL 문자열이 입력 입력됩니다. 입력된 URL이 올바르면 True, 잘못되었으면 False를 출력하는 프로그램을 만드세요. 이 심사문제에서 판단해야 할 URL의 규칙은 다음과 같습니다.  http:// 또는 https://로 시작  도메인은 도메인.최상위도메인 형식이며 영문 대소문자, 숫자, -로 되어 있어야 함  도메인 이하 경로는 /로 구분하고, 영문 대소문자, 숫자, -, _, ., ?, =을 사용함________________________________________________# 입력http://www.example.com/hello/world.do?key=python# 결과True# 입력https://example/hello/world.html# 결과False내가 쓴 답import reurl = input()p = re.compile('^[a-zA-Z0-9]+\\:\\/\\/[a-zA-Z0-9.]+\\.[a-zA-Z0-9.-_?=/]')print(p.match(url) != None, end=' ')답import rep = re.compile('^(http?://)[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+/[a-zA-Z0-9-_/.?=]*')print(p.match(input()) != None)먼저 URL은 http:// 또는 https://로 시작한다고 했으므로 정규표현식은 ^https?://로 시작합니다. 여기서 맨 앞에 ^를 붙였으므로 http 또는 https로 시작하는지 판단합니다. 그리고 https?와 같이 만들면 s가 0개 또는 1개 있어야 합니다. 따라서 http와 https를 둘 다 판별할 수 있습니다.이제 도메인을 판단합니다. 도메인 부분은 [a-zA-Z0-9-]+.[a-zA-Z0-9-.]+/와 같이 만들어줍니다. 먼저 [a-zA-Z0-9-]+와 같이 영문 대소문자, 숫자, -이면서 문자 1개 이상인지 판단합니다. 그리고 중간에 .를 넣어서 도메인.최상위도메인 형식인지 판단합니다. 여기서 .은 정규표현식에 사용하는 특수 문자이므로 앞에 반드시 \\를 붙여야 합니다. 특히 최상위 도메인은 여러 단계일 수도 있으므로 [a-zA-Z0-9-.]+/와 같이 범위에 .을 넣어줍니다. 그리고 도메인과 도메인 이하 경로를 구분할 수 있도록 /를 붙여줍니다.도메인 이하 경로는 영문 대소문자, 숫자, -, _, ., ?, =을 사용한다고 했으므로 [a-zA-Z0-9-_/.?=]*와 같이 만들어줍니다. 특히 하위 경로가 더 나올 수 있으므로 범위 안에 /를 넣어야 합니다.지금까지 만든 정규표현식을 차례대로 연결해서 re.match 함수로 url을 판단해주면 됩니다. 그리고 re.match 함수의 반환값이 있으면(None이 아니면) True를 출력하고, None이면 False를 출력하면 됩니다.",
        "url": "/python-basic42"
    }
    ,
    
    "python-basic41": {
        "title": "Python - Python 정규표현식 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기정규표현식 사용하기정규표현식(regular expression)은 일정한 규칙(패턴)을 가진 문자열을 표현하는 방법이다. 복잡한 문자열 속에서 특정한 규칙으로 된 문자열을 검색한 뒤 추출하거나 바꿀 때 사용한다. 또는, 문자열이 정해진 규칙에 맞는지 판단할 때도 사용한다.1.문자열 판단하기간단하게 문자열에 특정 문자열이 포함되어 있는지 판단해보자. 정규표현식은 re모튤을 가져와서 사용하며 match함수에 정규표현식 패턴과 판단할 문자열을 넣는다.(re는 regular expression의 약자).  re.match(‘패턴’, ‘문자열’)다음은 ‘Hello, world!’ 문자열에 ‘Hello’와 ‘Python’이 있는지 판단한다.import rere.match('Hello', 'Hello, world!')     # 문자열이 있으므로 정규표현식 매치 객체가 반환됨&lt;_sre.SRE_Match object; span=(0, 5), match='Hello'&gt;re.match('Python', 'Hello, world!')    # 문자열이 없으므로 아무것도 반환되지 않음문자열이 맨 앞에 오는지 맨 뒤에 오는지 판단하기정규표현식은 특정 문자열이 맨 앞에 오는지 맨 뒤에 오는지 판단할 수 있다.문자열 앞에 ^를 붙이면 문자열이 맨 앞에 오는지 판단하고, 문자열 뒤에 $를 붙이면 문자열이 맨 뒤에 오는지 판단힌다(특정 문자열로 끝나는지).  ^문자열  문자열$‘^Hello’는 ‘Hello, world!’가 ‘Hello’로 시작하는지 판단하고, ‘world!$’는 ‘Hello, world!’가 ‘world!’로 끝나는지 판단한다.re.search('^Hello', 'Hello, world!')     # Hello로 시작하므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 5), match='Hello'&gt;re.search('world!$', 'Hello, world!')    # world!로 끝나므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(7, 13), match='world!'&gt;지정된 문자열이 하나라도 포함되는지 판단하기|는 특정 문자열에서 지정된 문자열(문자)이 하나라도 포함되는지 판단한다. 기본 개념은 OR 연산자와 같다.                              문자열          문자열, 대상문자열                                                  문자열          문자열          문자열          문자열, 대상문자열                                ‘hello      world’는 문자열에서 ‘hello’ 또는 ‘world’가 포함되는지 판단한다.      re.match('hello|world', 'hello')    # hello 또는 world가 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 5), match='hello'&gt;–2.범위 판단하기이번에는 문자열이 숫자로 되어있는지 판한해보자. 다음과 같이 [] 대괄호 안에 숫자 범위를 넣으며 * 또는 +를 붙인다. 숫자 범위는 0-9처럼 표현하며 *는 문자(숫자)가 0개 이상 있는지, +는 1개 이상 있는지 판단한다.  [0-9]*  [0-9]+re.match('[0-9]*', '1234')    # 1234는 0부터 9까지 숫자가 0개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 4), match='1234'&gt;re.match('[0-9]+', '1234')    # 1234는 0부터 9까지 숫자가 1개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 4), match='1234'&gt;re.match('[0-9]+', 'abcd')    # abcd는 0부터 9까지 숫자가 1개 이상 없으므로 패턴에 매칭되지 않음그럼 *와 +의 사용은 다음과 같이 a*b와 a+b를 확인해보면 쉽게 알 수 있다.a*b, a+b에서 b는 무조건 있어야 하는 문자고, a*는 a가 0개 이상 있어야 하므로 b는 매칭이 된다. 하지만 a+는 a가 1개 이상 있어야 하므로 b는 매칭되지 않는다. 그리고 ‘ab’, ‘aab’, ‘aaab’처럼 a가 0개 이상 또는 1개 이상 있을 때는 a*b와 a+b를 모두 만족한다.re.match('a*b', 'b')      # b에는 a가 0개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 1), match='b'&gt;re.match('a+b', 'b')      # b에는 a가 1개 이상 없으므로 패턴에 매칭되지 않음re.match('a*b', 'aab')    # aab에는 a가 0개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 3), match='aab'&gt;re.match('a+b', 'aab')    # aab에는 a가 1개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 3), match='aab'&gt;문자가 한 개만 있는지 판단하기문자가 여러 개 있는지 판단할 때는 *과 +를 사용했지만, 문자가 한 개만 있는지 판단할 때는 ?와 .을 사용한다. ?는 ? 앞의 문자(범위)가 0개 또는 1개인지 판단하고, .은 .이 있는 위치에 아무 문자(숫자)가 1개 있는지 판단한다.  문자?  [0-9]?  .re.match('abc?d', 'abd')         # abd에서 c 위치에 c가 0개 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 3), match='abd'&gt;re.match('ab[0-9]?c', 'ab3c')    # [0-9] 위치에 숫자가 1개 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 4), match='ab3c'&gt;re.match('ab.d', 'abxd')         # .이 있는 위치에 문자가 1개 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 4), match='abxd'&gt;문자 개수 판단하기문자(숫자)가 정확히 몇 개 있는지 판단하고 싶을 때는 문자 뒤에 {개수} 형식을 지정한다. 문자열의 경우에는 문자열을 괄호로 묶고 뒤에 {개수} 형식을 지정한다.  문자{개수}  (문자열){개수}h{3}은 h가 3개 있는지 판단하고, (hello){3}은 hello가 3개 있는지 판단한다.re.match('h{3}', 'hhhello')&lt;_sre.SRE_Match object; span=(0, 3), match='hhh'&gt;re.match('(hello){3}', 'hellohellohelloworld')&lt;_sre.SRE_Match object; span=(0, 15), match='hellohellohello'&gt;특정 범위의 문자(숫자)가 몇 개 있는지 판단할 수도 있다. 이때는 범위 [ ] 뒤에 {개수} 형식을 지정한다.  [0-9]{개수}다음은 휴대전화의 번호 형식에 맞는지 판단한다.re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-1000')    # 숫자 3개-4개-4개 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 13), match='010-1000-1000'&gt;re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-100')   # 숫자 3개-4개-4개 패턴에 매칭되지 않음이 기능은 문자(숫자)의 개수 범위도 지정할 수 있다. {시작개수,끝개수} 형식으로 시작 개수와 끝 개수를 지정해주면 특정 개수 사이에 들어가는지 판단한다.  (문자){시작개수,끝개수}  (문자열){시작개수,끝개수}  [0-9]{시작개수,끝개수}다음은 일반전화의 번호 형식에 맞는지 판단한다.re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-100-1000')    # 2~3개-3~4개-4개 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 11), match='02-100-1000'&gt;re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-10-1000')  # 2~3개-3~4개-4개 패턴에 매칭되지 않음숫자와 영문 문자를 조합해서 판단하기지금까지 숫자 범위만 판단해보았으니 이제 숫자와 영문 문자를 조합해서 판단해보자. 영문 문자 범위는 a-z, A-Z와 같이 표현한다.  a-z  A-Zre.match('[a-zA-Z0-9]+', 'Hello1234')    # a부터 z, A부터 Z, 0부터 9까지 1개 이상 있으므로&lt;_sre.SRE_Match object; span=(0, 9), match='Hello1234'&gt;                        # 패턴에 매칭됨re.match('[A-Z0-9]+', 'hello')    # 대문자, 숫자는 없고 소문자만 있으므로 패턴에 매칭되지 않음이처럼 숫자, 영문 문자 범위는 a-zA-Z0-9 또는 A-Z0-9와 같이 붙여 쓰면 된다.그럼 한글은 영문 문자와 방법이 같다. 가-힣처럼 나올 수 있는 한글 조합을 정해주면 된다.  가-힣re.match('[가-힣]+', '홍길동')    # 가부터 힣까지 1개 이상 있으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 3), match='홍길동'&gt;특정 문자 범위에 포함되지 않는지 판단하기지금까지 정규표현식으로 특정 문자 범위에 포함되는지 살펴보았다. 그럼 특정 문자 범위에 포함되지 않는지 판단하려면 어떻게 해야 할까? 다음과 같이 문자(숫자) 범위 앞에 ^를 붙이면 해당 범위를 제외한다.  [^범위]*  [^범위]+즉, ‘[^A-Z]+’는 대문자를 제외한 모든 문자(숫자)가 1개 이상 있는지 판단한다.re.match('[^A-Z]+', 'Hello')    # 대문자를 제외. 대문자가 있으므로 패턴에 매칭되지 않음re.match('[^A-Z]+', 'hello')    # 대문자를 제외. 대문자가 없으므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 5), match='hello'&gt;앞에서 특정 문자열로 시작하는지 판단할 때도 ^를 사용했었는데 문법이 비슷해서 이 부분은 헷갈리기 쉽다. 범위를 제외할 때는 ‘[^A-Z]+’와 같이 [ ] 안에 넣어주고, 특정 문자 범위로 시작할 때는 ‘^[A-Z]+’와 같이 [ ] 앞에 붙여준다. 그래서 다음과 같이 ‘^[A-Z]+’는 영문 대문자로 시작하는지 판단한다.  ^[범위]*  ^[범위]+re.search('^[A-Z]+', 'Hello')        # 대문자로 시작하므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 1), match='H'&gt;특정 문자(숫자) 범위로 끝나는지 확인할 때는 정규표현식 뒤에 $를 붙이면 된다.  [범위]*$  [범위]+$re.search('[0-9]+$', 'Hello1234')    # 숫자로 끝나므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(5, 9), match='1234'&gt;특수 문자 판단하기특수 문자 *, +, ?, ., ^, $, (, ) [, ], - 등을 판단하려면 특수 문자 앞에 \\를 붙이면 된다. 단, [ ] 안에서는 \\를 붙이지 않아도 되지만 에러가 발생하는 경우에는 \\를 붙인다.  \\특수문자re.search('\\*+', '1 ** 2')                    # *이 들어있는지 판단&lt;_sre.SRE_Match object; span=(2, 4), match='**'&gt;re.match('[$()a-zA-Z0-9]+', '$(document)')    # $, (, )와 문자, 숫자가 들어있는지 판단&lt;_sre.SRE_Match object; span=(0, 11), match='$(document)'&gt;지금까지 범위를 지정하면서 a-zA-Z0-9처럼 대소문자와 숫자를 모두 나열했다. 이런 방식으로 범위를 정하면 정규표현식이 길어지고 복잡해진다. 단순히 숫자인지 문자인지 판단할 때는 \\d, \\D, \\w, \\W를 사용하면 편리하다.  \\d: [0-9]와 같음. 모든 숫자  \\D: [^0-9]와 같음. 숫자를 제외한 모든 문자  \\w: [a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자  \\W: [^a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자를 제외한 모든 문자re.match('\\d+', '1234')          # 모든 숫자이므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 4), match='1234'&gt;re.match('\\D+', 'Hello')         # 숫자를 제외한 모든 문자이므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 5), match='Hello'&gt;re.match('\\w+', 'Hello_1234')    # 영문 대소문자, 숫자, 밑줄 문자이므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 10), match='Hello_1234'&gt;re.match('\\W+', '(:)')    # 영문 대소문자, 숫자, 밑줄문자를 제외한 모든 문자이므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 3), match='(:)'&gt;공백 처리하기이번에는 공백을 처리해보겠다. 공백은 ‘ ‘처럼 공백 문자를 넣어도 되고, \\s 또는 \\S로 표현할 수도 있다.  \\s: [ \\t\\n\\r\\f\\v]와 같음. 공백(스페이스), \\t(탭) \\n(새 줄, 라인 피드), \\r(캐리지 리턴), \\f(폼피드), \\v(수직 탭)을 포함  \\S: [^ \\t\\n\\r\\f\\v]와 같음. 공백을 제외하고 \\t, \\n, \\r, \\f, \\v만 포함re.match('[a-zA-Z0-9 ]+', 'Hello 1234')     # ' '로 공백 표현&lt;_sre.SRE_Match object; span=(0, 10), match='Hello 1234'&gt;re.match('[a-zA-Z0-9\\s]+', 'Hello 1234')    # \\s로 공백 표현&lt;_sre.SRE_Match object; span=(0, 10), match='Hello 1234'&gt;같은 정규표현식 패턴을 자주 사용할 때매번 match나 search 함수에 정규표현식 패턴을 지정하는 방법은 비효율적이다. 같은 패턴을 자주 사용할 때는 compile 함수를 사용하여 정규표현식 패턴을 객체로 만든 뒤 match 또는 search 메서드를 호출하면 된다.      객체 = re.compile(‘패턴’)        객체.match(‘문자열’)        객체.search(‘문자열’)  p = re.compile('[0-9]+')    # 정규표현식 패턴을 객체로 만듦p.match('1234')             # 정규표현식 패턴 객체에서 match 메서드 사용&lt;_sre.SRE_Match object; span=(0, 4), match='1234'&gt;p.search('hello')           # 정규표현식 패턴 객체에서 search 메서드 사용3. 그룹 사용하기규표현식을 그룹으로 묶는 방법을 알아보겠다. 정규표현식 그룹은 해당 그룹과 일치하는 문자열을 얻어올 때 사용한다.패턴 안에서 정규표현식을 ( )(괄호)로 묶으면 그룹이 된다.  (정규표현식) (정규표현식)다음은 공백으로 구분된 숫자를 두 그룹으로 나누어서 찾은 뒤 각 그룹에 해당하는 문자열(숫자)을 가져온다.  매치객체.group(그룹숫자)매치 객체의 group 메서드에 숫자를 지정하면 해당 그룹에 매칭된 문자열을 반환한다. 숫자를 지정하지 않거나 0을 지정하면 매칭된 문자열을 한꺼번에 반환한다.m = re.match('([0-9]+) ([0-9]+)', '10 295')m.group(1)    # 첫 번째 그룹(그룹 1)에 매칭된 문자열을 반환'10'm.group(2)    # 두 번째 그룹(그룹 2)에 매칭된 문자열을 반환'295'm.group()     # 매칭된 문자열을 한꺼번에 반환'10 295'm.group(0)    # 매칭된 문자열을 한꺼번에 반환'10 295'그리고 groups 메서드는 각 그룹에 해당하는 문자열을 튜플로 반환한다.  매치객체.groups()m.groups()    # 각 그룹에 해당하는 문자열을 튜플 형태로 반환('10', '295')그룹 개수가 많아지면 숫자로 그룹을 구분하기가 힘들어진다. 이때는 그룹에 이름을 지으면 편리하다. 그룹의 이름은 ( )(괄호) 안에 ?P 형식으로 지정한다.  (?P정규표현식)다음은 함수를 호출하는 코드 print(1234)에서 함수의 이름 print와 인수 1234를 추출한다.  매치객체.group(‘그룹이름’)m = re.match('(?P&lt;func&gt;[a-zA-Z_][a-zA-Z0-9_]+)\\((?P&lt;arg&gt;\\w+)\\)', 'print(1234)')m.group('func')    # 그룹 이름으로 매칭된 문자열 출력'print'm.group('arg')     # 그룹 이름으로 매칭된 문자열 출력'1234'(?P)와 (?P)처럼 각 그룹에 이름을 짓고 m.group('func'), m.group('arg')로 매칭된 문자열을 출력했다. 참고로 함수 이름은 문자로만 시작해야 하므로 첫글자는 [a-zA-Z_]로 판단해준다. 또한, print 뒤에 붙은 (, )는 정규표현식에 사용하는 특수 문자이므로 앞에 \\를 붙여준다.패턴에 매칭되는 모든 문자열 가져오기지금까지 그룹에 해당하는 문자열을 가져왔다. 그러면 그룹 지정 없이 패턴에 매칭되는 모든 문자열을 가져오려면 findall 함수를 사용하며 매칭된 문자열을 리스트로 반환한다.  re.findall(‘패턴’, ‘문자열’)다음은 문자열에서 숫자만 가져온다.re.findall('[0-9]+', '1 2 Fizz 4 Buzz Fizz 7 8')['1', '2', '4', '7', '8']*, +와 그룹 활용하기정규표현식에서 +과 을 조합하여 사용할 때는 그룹으로 묶어서 사용합니다. (.[a-z]+)는 점과 영문 소문자가 1개 이상 있는지 판단하고, 이것 자체가 0개 이상인지 판단합니다. 즉, 규칙은 반드시 지켜야 하지만 있어도 되고 없어도 되는 상황에 사용합니다.re.match('[a-z]+(.[a-z]+)*$', 'hello.world')    # .world는 문자열이므로 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 11), match='hello.world'&gt;re.match('[a-z]+(.[a-z]+)*$', 'hello.1234')     # .1234는 숫자이므로 패턴에 매칭되지 않음re.match('[a-z]+(.[a-z]+)*$', 'hello')          # .뒤에 문자열이 없어도 패턴에 매칭됨&lt;_sre.SRE_Match object; span=(0, 5), match='hello'&gt;4. 문자열 바꾸기문자열을 바꿀 때는 sub 함수를 사용하며 패턴, 바꿀 문자열, 문자열, 바꿀 횟수를 넣어준다. 여기서 바꿀 횟수를 넣으면 지정된 횟수만큼 바꾸며 바꿀 횟수를 생략하면 찾은 문자열을 모두 바꿔준다.  re.sub(‘패턴’, ‘바꿀문자열’, ‘문자열’, 바꿀횟수)다음은 문자열에서 ‘apple’ 또는 ‘orange’를 찾아서 ‘fruit’로 바꾼다.re.sub('apple|orange', 'fruit', 'apple box orange tree')    # apple 또는 orange를 fruit로 바꿈'fruit box fruit tree'문자열에서 숫자만 찾아서 다른 문자로 바꿀 수 있다. 다음은 숫자만 찾아서 ‘n’으로 바꾼다.re.sub('[0-9]+', 'n', '1 2 Fizz 4 Buzz Fizz 7 8')    # 숫자만 찾아서 n으로 바꿈'n n Fizz n Buzz Fizz n n'sub 함수는 바꿀 문자열 대신 교체 함수를 지정할 수도 있다. 교체 함수는 매개변수로 매치 객체를 받으며 바꿀 결과를 문자열로 반환하면 된다. 다음은 문자열에서 숫자를 찾은 뒤 숫자를 10배로 만든다.  교체함수(매치객체)  re.sub(‘패턴’, 교체함수, ‘문자열’, 바꿀횟수)def multiple10(m):        # 매개변수로 매치 객체를 받음     n = int(m.group())    # 매칭된 문자열을 가져와서 정수로 변환     return str(n * 10)    # 숫자에 10을 곱한 뒤 문자열로 변환해서 반환re.sub('[0-9]+', multiple10, '1 2 Fizz 4 Buzz Fizz 7 8')'10 20 Fizz 40 Buzz Fizz 70 80'mutiple10 함수에서 group 메서드로 매칭된 문자열을 가져와서 정수로 바꾼다. 그리고 숫자에 10을 곱한 뒤 문자열로 변환해서 반환했다.교체 함수의 내용이 간단하다면 다음과 같이 람다 표현식을 만들어서 넣어도 된다.re.sub('[0-9]+', lambda m: str(int(m.group()) * 10), '1 2 Fizz 4 Buzz Fizz 7 8')'10 20 Fizz 40 Buzz Fizz 70 80'찾은 문자열을 결과에 다시 사용하기이번에는 정규표현식으로 찾은 문자열을 가져와서 결과에 다시 사용해보자. 먼저 정규표현식을 그룹으로 묶는다. 그러고 나면 바꿀 문자열에서 \\숫자 형식으로 매칭된 문자열을 가져와서 사용할 수 있다.  \\숫자다음은 ‘hello 1234’에서 hello는 그룹 1, 1234는 그룹 2로 찾은 뒤 그룹 2, 1, 2, 1 순으로 문자열의 순서를 바꿔서 출력한다.re.sub('([a-z]+) ([0-9]+)', '\\\\2 \\\\1 \\\\2 \\\\1', 'hello 1234')    # 그룹 2, 1, 2, 1 순으로 바꿈'1234 hello 1234 hello'다음은 ‘{ “name”: “james” }’을 ‘james’ 형식으로 바꾼다.외계어처럼 보이지만 부분부분 나눠서 보면 어렵지 않다. 이 정규표현식에서 그룹은 4개다. 맨 처음 ({\\s)은 {와 공백을 찾으므로 ‘{ ‘을 찾습니다. 그리고 마지막 (\\s})은 공백과 }를 찾으므로 ‘ }’를 찾는다. 중간에 있는 “(\\w+)”:\\s*”(\\w+)”은 :을 기준으로 양 옆의 name과 james를 찾습니다. 바꿀 문자열은 ‘&lt;\\2&gt;’과 같이 그룹 2 name과 그룹 3 james만 사용하고 그룹 1 ‘{ ‘, 그룹 4 ‘} ‘는 버린다.re.sub('({\\s*)\"(\\w+)\":\\s*\"(\\w+)\"(\\s*})', '&lt;\\\\2&gt;\\\\3&lt;/\\\\2&gt;', '{ \"name\": \"james\" }')'&lt;name&gt;james&lt;/name&gt;'만약 그룹에 이름을 지었다면 \\g 형식으로 매칭된 문자열을 가져올 수 있다(\\\\g 형식으로 숫자를 지정해도 된다).  \\g  \\gre.sub('({\\s*)\"(?P&lt;key&gt;\\w+)\":\\s*\"(?P&lt;value&gt;\\w+)\"(\\s*})', '&lt;\\\\g&lt;key&gt;&gt;\\\\g&lt;value&gt;&lt;/\\\\g&lt;key&gt;&gt;', '{ \"name\": \"james\" }')'&lt;name&gt;james&lt;/name&gt;'raw 문자열 사용하기정규표현식의 특수 문자를 판단하려면 \\를 붙여야 한다. 여기서 문자열 앞에 r을 붙여주면 원시(raw) 문자열이 되어 \\를 붙이지 않아도 특수 문자를 그대로 판단할 수 있게된다. 따라서 raw 문자열에서는 \\숫자, \\g, \\\\g는 \\숫자, \\g, \\g 형식처럼 \\를 하나만 붙여서 사용할 수 있다.  r’\\숫자 \\g \\g're.sub('({\\s*)\"(\\w+)\":\\s*\"(\\w+)\"(\\s*})', r'&lt;\\2&gt;\\3&lt;/\\2&gt;', '{ \"name\": \"james\" }')'&lt;name&gt;james&lt;/name&gt;'예제1다음 소스 코드를 완성하여 주어진 이메일 주소가 올바른지 판단하도록 만드세요. emails 리스트에서 앞의 다섯 개는 올바른 형식이며 마지막 세 개는 잘못된 형식입니다.import re p = re.compile(                                                  )emails = ['python@mail.example.com', 'python+kr@example.com',              # 올바른 형식          'python-dojang@example.co.kr', 'python_10@example.info',         # 올바른 형식          'python.dojang@e-xample.com',                                    # 올바른 형식          '@example.com', 'python@example', 'python@example-com']          # 잘못된 형식 for email in emails:    print(p.match(email) != None, end=' ')# 실행 결과True True True True True False False False답'^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'이메일은 계정@도메인.최상위도메인 형식이며 계정에 +, -, _, . 등의 문자를 붙이기도 합니다. 또한, 도메인에 - 문자를 사용할 수 있고, 최상위 도메인이 여러 단계일 수도 있습니다. 이러한 규칙에 맞추어서 정규표현식을 작성합니다.^[a-zA-Z0-9+-.]+@는 이메일에서 @을 기준으로 계정을 나타내며 앞에 ^가 붙었으므로 계정이 맨 앞에 오는지 판단합니다. 또한, [a-zA-Z0-9+-.]+와 같이 영문 대소문자, 숫자, +, -, _, .으로 되어 있어야 하고 문자 1개 이상인지 판단합니다.[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$는 도메인과 최상위 도메인(TLD)를 나타냅니다. 먼저 [a-zA-Z0-9-]+와 같이 영문 대소문자, 숫자, -이면서 문자 1개 이상인지 판단합니다. 그리고 중간에 .를 넣어서 도메인.최상위도메인 형식인지 판단합니다. 여기서 .은 정규표현식에 사용하는 특수 문자이므로 앞에 반드시 \\를 붙여야 합니다. 특히 최상위 도메인은 여러 단계일 수도 있으므로 [a-zA-Z0-9-.]+$와 같이 범위에 .을 넣어줍니다. 또한, $를 붙여서 최상위 도메인이 마지막에 오는지 판단합니다.예제2표준 입력으로 URL 문자열이 입력 입력됩니다. 입력된 URL이 올바르면 True, 잘못되었으면 False를 출력하는 프로그램을 만드세요. 이 심사문제에서 판단해야 할 URL의 규칙은 다음과 같습니다.  http:// 또는 https://로 시작  도메인은 도메인.최상위도메인 형식이며 영문 대소문자, 숫자, -로 되어 있어야 함  도메인 이하 경로는 /로 구분하고, 영문 대소문자, 숫자, -, _, ., ?, =을 사용함________________________________________________# 입력http://www.example.com/hello/world.do?key=python# 결과True# 입력https://example/hello/world.html# 결과False내가 쓴 답import reurl = input()p = re.compile('^[a-zA-Z0-9]+\\:\\/\\/[a-zA-Z0-9.]+\\.[a-zA-Z0-9.-_?=/]')print(p.match(url) != None, end=' ')답import rep = re.compile('^(http?://)[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+/[a-zA-Z0-9-_/.?=]*')print(p.match(input()) != None)먼저 URL은 http:// 또는 https://로 시작한다고 했으므로 정규표현식은 ^https?://로 시작합니다. 여기서 맨 앞에 ^를 붙였으므로 http 또는 https로 시작하는지 판단합니다. 그리고 https?와 같이 만들면 s가 0개 또는 1개 있어야 합니다. 따라서 http와 https를 둘 다 판별할 수 있습니다.이제 도메인을 판단합니다. 도메인 부분은 [a-zA-Z0-9-]+.[a-zA-Z0-9-.]+/와 같이 만들어줍니다. 먼저 [a-zA-Z0-9-]+와 같이 영문 대소문자, 숫자, -이면서 문자 1개 이상인지 판단합니다. 그리고 중간에 .를 넣어서 도메인.최상위도메인 형식인지 판단합니다. 여기서 .은 정규표현식에 사용하는 특수 문자이므로 앞에 반드시 \\를 붙여야 합니다. 특히 최상위 도메인은 여러 단계일 수도 있으므로 [a-zA-Z0-9-.]+/와 같이 범위에 .을 넣어줍니다. 그리고 도메인과 도메인 이하 경로를 구분할 수 있도록 /를 붙여줍니다.도메인 이하 경로는 영문 대소문자, 숫자, -, _, ., ?, =을 사용한다고 했으므로 [a-zA-Z0-9-_/.?=]*와 같이 만들어줍니다. 특히 하위 경로가 더 나올 수 있으므로 범위 안에 /를 넣어야 합니다.지금까지 만든 정규표현식을 차례대로 연결해서 re.match 함수로 url을 판단해주면 됩니다. 그리고 re.match 함수의 반환값이 있으면(None이 아니면) True를 출력하고, None이면 False를 출력하면 됩니다.",
        "url": "/python-basic41"
    }
    ,
    
    "python-basic40": {
        "title": "Python - Python 데코레이터 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기데코레이터 사용하기파이썬은 데코레이터(decorator)라는 기능을 제공한다. 장식하는 도구 정도로 생각하면 되고 전에 배운 내용중 클래스에서 메서드를 만들 때 @staticmethod, @classmethod, @abstractmethod 등을 붙여 사용했는데 이렇게 @로 시작하는 것들이 데코레이터 이다. 데이코레이터는 장식자 라고도 부른다.class Calc:    @staticmethod    # 데코레이터    def add(a, b):        print(a + b)1.데코레이터 만들기데코레이터는 함수를 수정하지 않은 상태에서 추가 기능을 구현할 때 사용한다. 예를 들어서 함수의 시작과 끝을 출력하고 싶다면 다음과 같이 함수 시작, 끝 부분에 print를 넣어준다.def hello():    print('hello 함수 시작')    print('hello')    print('hello 함수 끝') def world():    print('world 함수 시작')    print('world')    print('world 함수 끝') hello()world()# 실행 결과hello 함수 시작hellohello 함수 끝world 함수 시작worldworld 함수 끝위 코드에서 다른 함수도 시작과 끝을 출력하고 싶다면 함수를 만들 때마다 print를 넣어야 한다. 따라서 함수가 많아지면 번거롭기 때문에 이런 경우는 데코레이터를 활용한다. 다음은 함수 시작과 끝을 출력하는 데코레이터이다.def trace(func):                             # 호출할 함수를 매개변수로 받음    def wrapper():                           # 호출할 함수를 감싸는 함수        print(func.__name__, '함수 시작')    # __name__으로 함수 이름 출력        func()                               # 매개변수로 받은 함수를 호출        print(func.__name__, '함수 끝')    return wrapper                           # wrapper 함수 반환 def hello():    print('hello') def world():    print('world') trace_hello = trace(hello)    # 데코레이터에 호출할 함수를 넣음trace_hello()                 # 반환된 함수를 호출trace_world = trace(world)    # 데코레이터에 호출할 함수를 넣음trace_world()                 # 반환된 함수를 호출# 실행 결과hello 함수 시작hellohello 함수 끝world 함수 시작worldworld 함수 끝먼저 데코레이터 trace는 호출할 함수를 매개변수로 받는다. trace함수 안에서는 호출할 함수를 감싸는 함수 wrapper를 만든다. 이제 wrapper함수 에서는 함수의 시작을 알리는 문자열을 출력하고, trace에서 매개변수로 받은 func를 호출한다. 그다음에 함수의 끝을 알리는 문자열을 출력한다. 여기서 매개변수로 받은 함수의 원래 이름을 출력할 때는 __name__ 속성을 활용한다. 마지막으로 wrapper 함수를 다 만들었으면 return을 사용하여 wrapper 함수 자체를 반환한다.def trace(func):                             # 호출할 함수를 매개변수로 받음    def wrapper():                           # 호출할 함수를 감싸는 함수        print(func.__name__, '함수 시작')    # __name__으로 함수 이름 출력        func()                               # 매개변수로 받은 함수를 호출        print(func.__name__, '함수 끝')    return wrapper                           # wrapper 함수 반환즉, 함수 안에서 함수를 만들고 반환하는 클로저 이다.데코레이터를 사용할 때는 trace에 호출할 함수 hello또는 world를 넣는다. 그다음에 데코레이터에서 반환된 함수를 호출한다. 이렇게 하면 데코레이터에 인수로 넣은 함수를 호출하고 시작과 끝을 출력한다.@로 데코레이터 사용하기이제 @을 사용하여 좀 더 간편하게 데코레이터를 사용해보자. 다음과 같이 호출할 함수 위에 @데코레이터 형식으로 지정한다.@데코레이터def 함수이름():    코드def trace(func):                             # 호출할 함수를 매개변수로 받음    def wrapper():        print(func.__name__, '함수 시작')    # __name__으로 함수 이름 출력        func()                               # 매개변수로 받은 함수를 호출        print(func.__name__, '함수 끝')    return wrapper                           # wrapper 함수 반환 @trace    # @데코레이터def hello():    print('hello') @trace    # @데코레이터def world():    print('world') hello()    # 함수를 그대로 호출world()    # 함수를 그대로 호출# 실행 결과hello 함수 시작hellohello 함수 끝world 함수 시작worldworld 함수 끝hello와 world함수 위에 @trace를 붙인 뒤에 hello 와 world함수를 그대로 호출하면 끝이다.@trace    # @데코레이터def hello():    print('hello') @trace    # @데코레이터def world():    print('world') hello()    # 함수를 그대로 호출world()    # 함수를 그대로 호출데코레이터를 여러 개 지정하기함수에는 데코레이터를 여러 개 지정할 수 있다. 다음과 같이 함수 위에 데코레이터를 여러 줄로 지정해준다. 이때 데코레이터가 실행되는 순서는 위에서 아래 순서.@데코레이터1@데코레이터2def 함수이름():    코드def decorator1(func):    def wrapper():        print('decorator1')        func()    return wrapper def decorator2(func):    def wrapper():        print('decorator2')        func()    return wrapper # 데코레이터를 여러 개 지정@decorator1@decorator2def hello():    print('hello') hello()# 실행 결과decorator1decorator2hello–2.매개변수와 반환값을 처리하는 데코레이터 만들기지금까지 매개변수와 반환값이 없는 함수의 데코레이터를 만들었다. 이번에는 매개변수와 반환값을 처리하는 데코레이터 만드는 방법에 대해 알아보자. 다음은 함수의 매개변수와 반환값을 출력하는 데코레이터다.def trace(func):          # 호출할 함수를 매개변수로 받음    def wrapper(a, b):    # 호출할 함수 add(a, b)의 매개변수와 똑같이 지정        r = func(a, b)    # func에 매개변수 a, b를 넣어서 호출하고 반환값을 변수에 저장        print('{0}(a={1}, b={2}) -&gt; {3}'.format(func.__name__, a, b, r))  # 매개변수와 반환값 출력        return r          # func의 반환값을 반환    return wrapper        # wrapper 함수 반환 @trace              # @데코레이터def add(a, b):      # 매개변수는 두 개    return a + b    # 매개변수 두 개를 더해서 반환 print(add(10, 20))# 실행 결과add(a=10, b=20) -&gt; 3030add 함수를 호출했을 때 데코레이터를 통해서 매개변수와 반환값이 출력되었다. 매개변수와 반환값을 처리하는 데코레이터를 만들때는 먼저 안쪽 wrapper함수의 개개변수를 호출할 함수 add(a, b)의 매개변수와 똑같이 만들어준다.def trace(func):          # 호출할 함수를 매개변수로 받음    def wrapper(a, b):    # 호출할 함수 add(a, b)의 매개변수와 똑같이 지정wrapper 함수 안에서는 func를 호출하고 반환값을 변수에 저장한다. 그다음에 print로 매개변수와 반환값을 출력한다. 이때 func에는 매개변수 a와 b를 그대로 넣어준다. 또한, add 함수는 두 수를 더해서 반환해야 하므로 func의 반환값을 return으로 반환해준다.def trace(func):          # 호출할 함수를 매개변수로 받음    def wrapper(a, b):    # 호출할 함수 add(a, b)의 매개변수와 똑같이 지정        r = func(a, b)    # func에 매개변수 a, b를 넣어서 호출하고 반환값을 변수에 저장        print('{0}(a={1}, b={2}) -&gt; {3}'.format(func.__name__, a, b, r))    # 매개변수와 반환값 출력        return r          # func의 반환값을 반환    return wrapper        # wrapper 함수 반환만약 wrapper 함수에서 func의 반환값을 반환하지 않으면 add 함수를 호출해도 반환값이 나오지 않으므로 주의해야 한다. 참고로 wrapper 함수에서 func의 반환값을 출력할 필요가 없으면 return func(a, b)처럼 func를 호출하면서 바로 반환해도 된다.데코레이터를 사용할 때는 @로 함수 위에 지정해주면 된다. 또한, @로 데코레이터를 사용했으므로 add 함수는 그대로 호출해준다.@trace              # @데코레이터def add(a, b):      # 매개변수는 두 개    return a + b    # 매개변수 두 개를 더해서 반환가변 인수 함수 데코레이터def add(a, b):는 매개변수의 개수가 고정된 함수다. 그러면 매개변수(인수)가 고정되지 않은 함수는 어떻게 처리할까? 이때는 wrapper 함수를 가변 인수 함수로 만들면 된다.def trace(func):                     # 호출할 함수를 매개변수로 받음    def wrapper(*args, **kwargs):    # 가변 인수 함수로 만듦        r = func(*args, **kwargs)    # func에 args, kwargs를 언패킹하여 넣어줌        print('{0}(args={1}, kwargs={2}) -&gt; {3}'.format(func.__name__, args, kwargs, r))                                     # 매개변수와 반환값 출력        return r                     # func의 반환값을 반환    return wrapper                   # wrapper 함수 반환 @trace                   # @데코레이터def get_max(*args):      # 위치 인수를 사용하는 가변 인수 함수    return max(args) @trace                   # @데코레이터def get_min(**kwargs):   # 키워드 인수를 사용하는 가변 인수 함수    return min(kwargs.values()) print(get_max(10, 20))print(get_min(x=10, y=20, z=30))# 실행 결과get_max(args=(10, 20), kwargs={}) -&gt; 2020get_min(args=(), kwargs={'x': 10, 'y': 20, 'z': 30}) -&gt; 1010get_max 함수와 get_min 함수는 가변 인수 함수다. 따라서 데코레이터도 가변 인수 함수로 만들어준다. 이때 위치 인수와 키워드 인수를 모두 받을 수 있도록 *args와 **kwargs를 지정해준다.def trace(func):                     # 호출할 함수를 매개변수로 받음    def wrapper(*args, **kwargs):    # 가변 인수 함수로 만듦        r = func(*args, **kwargs)    # func에 args, kwargs를 언패킹하여 넣어줌        print('{0}(args={1}, kwargs={2}) -&gt; {3}'.format(func.__name__, args, kwargs, r))                                     # 매개변수와 반환값 출력        return r                     # func의 반환값을 반환    return wrapper                   # wrapper 함수 반환이렇게 만든 데코레이터 trace는 위치 인수와 키워드 인수를 모두 처리할 수 있다. 따라서 가변 인수 함수뿐만 아니라 일반적인 함수에도 사용할 수 있다.@trace def add(a, b):    return a + badd(10, 20)add(args=(10, 20), kwargs={}) -&gt; 3030메서드에 데코레이터 사용하기클래스를 만들면서 메서드에 데코레이터를 사용할 때는 self를 주의해야 한다. 인스턴스 메서드는 항상 self를 받으므로 데코레이터를 만들 때도 wrapper 함수의 첫 번째 매개변수는 self로 지정해야 한다(클래스 메서드는 cls). 마찬가지로 func를 호출할 때도 self와 매개변수를 그대로 넣어야 한다.def trace(func):    def wrapper(self, a, b):   # 호출할 함수가 인스턴스 메서드이므로 첫 번째 매개변수는 self로 지정        r = func(self, a, b)   # self와 매개변수를 그대로 넣어줌        print('{0}(a={1}, b={2}) -&gt; {3}'.format(func.__name__, a, b, r))   # 매개변수와 반환값 출력        return r               # func의 반환값을 반환    return wrapper class Calc:    @trace    def add(self, a, b):    # add는 인스턴스 메서드        return a + b c = Calc()print(c.add(10, 20))# 실행 결과add(a=10, b=20) -&gt; 30303. 매개변수가 있는 데코레이터 만들기매개변수가 있는 데코레이터를 만들어 보자. 이런 방식의 데코레이터는 값을 지정해서 동작을 바꿀 수 있다. 다음은 함수의 반환값이 특정 수의 배수인지 확인하는 데코레이터아다.def is_multiple(x):              # 데코레이터가 사용할 매개변수를 지정    def real_decorator(func):    # 호출할 함수를 매개변수로 받음        def wrapper(a, b):       # 호출할 함수의 매개변수와 똑같이 지정            r = func(a, b)       # func를 호출하고 반환값을 변수에 저장            if r % x == 0:       # func의 반환값이 x의 배수인지 확인                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, x))            else:                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, x))            return r             # func의 반환값을 반환        return wrapper           # wrapper 함수 반환    return real_decorator        # real_decorator 함수 반환 @is_multiple(3)     # @데코레이터(인수)def add(a, b):    return a + b print(add(10, 20))print(add(2, 5))# 실행 결과add의 반환값은 3의 배수입니다.30add의 반환값은 3의 배수가 아닙니다.7실행을 해보면 add 함수의 반환값이 3의 배수인지 아닌지 알수있다. 지금까지 데코레이터를 만들 때 함수 안에 함수를 하나만 만들었다. 하지만 매개변수가 있는 데코레이터를 만들 때는 함수를 하나 더 만들어야 한다.먼저 is_multiple 함수를 만들고 데코레이터가 사용할 매개변수 x를 지정하고 is_multiple 함수 안에서 실제 데코레이터 역할을 하는 real_decorator를 만든다. 즉, 이 함수에서 호출할 함수를 매개변수로 받는다. 그다음에 real_decorator 함수 안에서 wrapper 함수를 만들어주면 된다.def is_multiple(x):              # 데코레이터가 사용할 매개변수를 지정    def real_decorator(func):    # 호출할 함수를 매개변수로 받음        def wrapper(a, b):       # 호출할 함수의 매개변수와 똑같이 지정wrapper함수 안에서는 먼저 func의 결과가 데코레이터 매개변수 x의 배수인지 확인한다. 그다음에 func의 반환값을 반환하게된다.def is_multiple(x):              # 데코레이터가 사용할 매개변수를 지정    def real_decorator(func):    # 호출할 함수를 매개변수로 받음        def wrapper(a, b):       # 호출할 함수의 매개변수와 똑같이 지정            r = func(a, b)       # func를 호출하고 반환값을 변수에 저장            if r % x == 0:       # func의 반환값이 x의 배수인지 확인                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, x))            else:                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, x))            return r             # func의 반환값을 반환여기서는 real_decorator, wrapper 함수를 두 개 만들었으므로 함수를 만든 뒤에 return으로 두 함수를 반환해준다.        return wrapper           # wrapper 함수 반환    return real_decorator        # real_decorator 함수 반환데코레이터를 사용할 때는 데코레이터에 ( )(괄호)를 붙인 뒤 인수를 넣어주면 된다.@데코레이터(인수)def 함수이름():    코드@is_multiple(3)     # @데코레이터(인수)def add(a, b):    return a + b여기서는 is_multiple에 3을 지정해서 add 함수의 반환값이 3의 배수인지 확인했다. 물론 is_multiple에 다른 숫자를 넣으면 함수의 반환값이 해당 숫자의 배수인지 확인해준다.매개변수가 있는 데코레이터를 여러 개 지정하기매개변수가 있는 데코레이터를 여러 개 지정할 때는 다음과 같이 인수를 넣은 데코레이터를 여러 줄로 지정해준다.@데코레이터1(인수)@데코레이터2(인수)def 함수이름():    코드@is_multiple(3)@is_multiple(7)def add(a, b):    return a + b add(10, 20)실행 결과add의 반환값은 7의 배수가 아닙니다.wrapper의 반환값은 3의 배수입니다.@을 사용하지 않았을 때는 다음 코드와 동작이 같다.decorated_add = is_multiple(3)(is_multiple(7)(add))decorated_add(10, 20)원래 함수 이름이 안나온다면?데코레이터를 여러 개 사용하면 데코레이터에서 반환된 wrapper 함수가 다른 데코레이터로 들어간다. 따라서 함수의 __name__을 출력해보면 wrapper가 나온다.add의 반환값은 7의 배수가 아닙니다.wrapper의 반환값은 3의 배수입니다.함수의 원래 이름을 출력하고 싶다면 functools 모듈의 wraps 데코레이터를 사용해야 한다. 다음과 같이 @functools.wraps에 func를 넣은 뒤 wrapper 함수 위에 지정해준다(from functools import wraps로 데코레이터를 가져왔다면 @wraps(func)를 지정).import functools def is_multiple(x):    def real_decorator(func):        @functools.wraps(func)    # @functools.wraps에 func를 넣은 뒤 wrapper 함수 위에 지정        def wrapper(a, b):            r = func(a, b)            if r % x == 0:                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, x))            else:                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, x))            return r        return wrapper    return real_decorator @is_multiple(3)@is_multiple(7)def add(a, b):    return a + b add(10, 20)# 실행 결과add의 반환값은 7의 배수가 아닙니다.add의 반환값은 3의 배수입니다.@functools.wraps는 원래 함수의 정보를 유지시켜준다. 따라서 디버깅을 할 때 유용하므로 데코레이터를 만들 때는 @functools.wraps를 사용하는 것이 좋다.4. 클래스로 데코레이터 만들기클래스로 데코레이터를 만드는 방법을 알아보자. 특히 클래스를 활용할 때는 인스턴스를 함수처럼 호출하게 해주는 __call__메서드를 구현해야 한다.다음은 함수의 시작과 끝을 출력하는 데코레이터 이다.class Trace:    def __init__(self, func):    # 호출할 함수를 인스턴스의 초깃값으로 받음        self.func = func         # 호출할 함수를 속성 func에 저장     def __call__(self):        print(self.func.__name__, '함수 시작')    # __name__으로 함수 이름 출력        self.func()                               # 속성 func에 저장된 함수를 호출        print(self.func.__name__, '함수 끝') @Trace    # @데코레이터def hello():    print('hello') hello()    # 함수를 그대로 호출# 실행 결과hello 함수 시작hellohello 함수 끝클래스로 데코레이터를 만들 때는 먼저 __init__ 메서드를 만들고 호출할 함수를 초깃값으로 받는다. 그리고 매개변수로 받은 함수를 속성으로 저장한다.class Trace:    def __init__(self, func):    # 호출할 함수를 인스턴스의 초깃값으로 받음        self.func = func         # 호출할 함수를 속성 func에 저장이제 인스턴스를 호출할 수 있도록 __call__ 메서드를 만든다. __call__ 메서드에서는 함수의 시작을 알리는 문자열을 출력하고, 속성 func에 저장된 함수를 호출한다. 그다음에 함수의 끝을 알리는 문자열을 출력한다.    def __call__(self):        print(self.func.__name__, '함수 시작')    # __name__으로 함수 이름 출력        self.func()                               # 속성 func에 저장된 함수를 호출        print(self.func.__name__, '함수 끝')데코레이터를 사용하는 방법은 클로저 형태의 데코레이터와 같다. 호출할 함수 위에 @을 붙이고 데코레이터를 지정하면 된다.@데코레이터def 함수이름():    코드@Trace    # @데코레이터def hello():    print('hello')@으로 데코레이터를 지정했으므로 함수는 그대로 호출해줍니다.hello()    # 함수를 그대로 호출참고로 클래스로 만든 데코레이터는 @을 지정하지 않고, 데코레이터의 반환값을 호출하는 방식으로도 사용할 수 있다. 다음과 같이 데코레이터에 호출할 함수를 넣어서 인스턴스를 생성한 뒤 인스턴스를 호출해주면 된다. 즉, 클래스에 __call__ 메서드를 정의했으므로 함수처럼 ( )(괄호)를 붙여서 호출할 수 있다.def hello():    # @데코레이터를 지정하지 않음    print('hello') trace_hello = Trace(hello)    # 데코레이터에 호출할 함수를 넣어서 인스턴스 생성trace_hello()                 # 인스턴스를 호출. __call__ 메서드가 호출됨5. 클래스로 매개변수와 반환값을 처리하는 데코레이터 만들기클래스로 만든 데코레이터도 매개변수와 반환값을 처리할 수 있다. 다음은 함수의 매개변수를 출력하는 데코레이터다(여기서는 위치 인수와 키워드 인수를 모두 처리하는 가변 인수로 만들었다).class Trace:    def __init__(self, func):    # 호출할 함수를 인스턴스의 초깃값으로 받음        self.func = func         # 호출할 함수를 속성 func에 저장     def __call__(self, *args, **kwargs):    # 호출할 함수의 매개변수를 처리        r = self.func(*args, **kwargs) # self.func에 매개변수를 넣어서 호출하고 반환값을 변수에 저장        print('{0}(args={1}, kwargs={2}) -&gt; {3}'.format(self.func.__name__, args, kwargs, r))                                            # 매개변수와 반환값 출력        return r                            # self.func의 반환값을 반환 @Trace    # @데코레이터def add(a, b):    return a + b print(add(10, 20))print(add(a=10, b=20))# 실행 결과add(args=(10, 20), kwargs={}) -&gt; 3030add(args=(), kwargs={'a': 10, 'b': 20}) -&gt; 3030클래스로 매개변수와 반환값을 처리하는 데코레이터를 만들 때는 __call__ 메서드에 매개변수를 지정하고, self.func에 매개변수를 넣어서 호출한 뒤에 반환값을 반환해주면 된다. 여기서는 매개변수를 *args, **kwargs로 지정했으므로 self.func에 넣을 때는 언패킹하여 넣어준다.    def __call__(self, *args, **kwargs):    # 호출할 함수의 매개변수를 처리        r = self.func(*args, **kwargs) # self.func에 매개변수를 넣어서 호출하고 반환값을 변수에 저장        print('{0}(args={1}, kwargs={2}) -&gt; {3}'.format(self.func.__name__, args, kwargs, r))                                            # 매개변수와 반환값 출력        return r                            # self.func의 반환값을 반환물론 가변 인수를 사용하지 않고, 고정된 매개변수를 사용할 때는 def __call__(self, a, b):처럼 만들어도 된다.클래스로 매개변수가 있는 데코레이터 만들기마지막으로 매개변수가 있는 데코레이터를 만들어보자. 다음은 함수의 반환값이 특정 수의 배수인지 확인하는 데코레이터다.class IsMultiple:    def __init__(self, x):         # 데코레이터가 사용할 매개변수를 초깃값으로 받음        self.x = x                 # 매개변수를 속성 x에 저장     def __call__(self, func):      # 호출할 함수를 매개변수로 받음        def wrapper(a, b):         # 호출할 함수의 매개변수와 똑같이 지정(가변 인수로 작성해도 됨)            r = func(a, b)         # func를 호출하고 반환값을 변수에 저장            if r % self.x == 0:    # func의 반환값이 self.x의 배수인지 확인                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, self.x))            else:                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, self.x))            return r               # func의 반환값을 반환        return wrapper             # wrapper 함수 반환 @IsMultiple(3)    # 데코레이터(인수)def add(a, b):    return a + b print(add(10, 20))print(add(2, 5))# 실행 결과add의 반환값은 3의 배수입니다.30add의 반환값은 3의 배수가 아닙니다.7먼저 __init__ 메서드에서 데코레이터가 사용할 매개변수를 초깃값으로 받습니다. 그리고 매개변수를 __call__ 메서드에서 사용할 수 있도록 속성에 저장합니다.    def __init__(self, x):         # 데코레이터가 사용할 매개변수를 초깃값으로 받음        self.x = x                 # 매개변수를 속성 x에 저장지금까지 __init__에서 호출할 함수를 매개변수로 받았는데 여기서는 데코레이터가 사용할 매개변수를 받는다는 점 꼭 기억하자.이제 __call__ 메서드에서는 호출할 함수를 매개변수로 받는다. 그리고 __call__ 메서드 안에서 wrapper 함수를 만들어준다. 이때 wrapper 함수의 매개변수는 호출할 함수의 매개변수와 똑같이 지정해준다(가변 인수로 작성해도 됨).    def __call__(self, func):      # 호출할 함수를 매개변수로 받음        def wrapper(a, b):         # 호출할 함수의 매개변수와 똑같이 지정(가변 인수로 작성해도 됨)wrapper 함수 안에서는 func의 반환값이 데코레이터 매개변수 x의 배수인지 확인한다. 이때 데코레이터 매개변수 x는 속성에 저장되어 있으므로 self.x와 같이 사용해야 한다. 그리고 배수 확인이 끝났으면 func의 반환값을 반환한다. 마지막으로 wrapper 함수를 다 만들었으면 return으로 wrapper 함수를 반환한다.    def __call__(self, func):      # 호출할 함수를 매개변수로 받음        def wrapper(a, b):         # 호출할 함수의 매개변수와 똑같이 지정(가변 인수로 작성해도 됨)            r = func(a, b)         # func를 호출하고 반환값을 변수에 저장            if r % self.x == 0:    # func의 반환값이 self.x의 배수인지 확인                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, self.x))            else:                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, self.x))            return r               # func의 반환값을 반환        return wrapper             # wrapper 함수 반환데코레이터를 사용할 때는 데코레이터에 ( )(괄호)를 붙인 뒤 인수를 넣어주면 됩니다.@데코레이터(인수)def 함수이름():    코드@IsMultiple(3)    # 데코레이터(인수)def add(a, b):    return a + b예제1다음 소스 코드에서 데코레이터 type_check를 작성하세요. type_check는 함수의 매개변수가 지정된 자료형(클래스)이면 함수를 정상적으로 호출하고, 지정된 자료형과 다르면 RuntimeError 예외를 발생시키면서 ‘자료형이 다릅니다.’ 에러 메시지를 출력해야 합니다. 여기서 type_check에 지정된 첫 번째 int는 호출할 함수에서 첫 번째 매개변수의 자료형을 뜻하고, 두 번째 int는 호출할 함수에서 두 번째 매개변수의 자료형을 뜻합니다._________________________________..._________________________________ @type_check(int, int)def add(a, b):    return a + b print(add(10, 20))print(add('hello', 'world'))# 실행 결과30Traceback (most recent call last):  File \"C:\\project\\practice_decorator.py\", line 16, in &lt;module&gt;    print(add('hello', 'world'))  File \"C:\\project\\practice_decorator.py\", line 7, in wrapper    raise RuntimeError('자료형이 올바르지 않습니다.')RuntimeError: 자료형이 올바르지 않습니다.답def type_check(type_a, type_b):    def real_decorator(func):        def wrapper(a, b):            if isinstance(a, type_a) and isinstance(b, type_b):                return func(a, b)            else:                raise RuntimeError('자료형이 올바르지 않습니다.')        return wrapper    return real_decorator예제2표준 입력으로 HTML 태그 이름 두 개가 입력됩니다. 다음 소스 코드에서 함수의 반환값을 HTML 태그로 감싸는 데코레이터를 만드세요. HTML 태그는 웹 페이지에 사용하는 문법이며 문자열, &lt;p&gt;문자열&lt;/p&gt;처럼 으로 시작하며 으로 끝납니다.________________________________________________________________________________________________________________________________________________________________________________________________________________a, b = input().split() @html_tag(a)@html_tag(b)def hello():    return 'Hello, world!' print(hello())# 입력p span# 결과&lt;p&gt;&lt;span&gt;Hello, world!&lt;/span&gt;&lt;/p&gt;# 입력b i# 결과&lt;b&gt;&lt;i&gt;Hello, world!&lt;/i&gt;&lt;/b&gt;답def html_tag(tag):    def real_decorator(func):        def wrapper():            result = '&lt;{0}&gt;{1}&lt;/{2}&gt;'.format(tag, func(), tag)            return result        return wrapper    return real_decorator",
        "url": "/python-basic40"
    }
    ,
    
    "python-basic39": {
        "title": "Python - Python 코루틴 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기코루틴 사용하기다음과 같이 calc 함수 안에서 add 함수를 호출했을 때 add 함수가 끝나면 다시 calc 함수로 돌아온다. 특히 add 함수가 끝나면 이 함수에 들어있던 변수와 계산식은 모두 사라진다. 아래 소스 코드에서 calc 함수와 add함수의 관계를 살펴보자. calc가 메인루틴(main routine)이면 add는 calc의 서브루틴(sub routine)이다.def add(a, b):    c = a + b    # add 함수가 끝나면 변수와 계산식은 사라짐    print(c)    print('add 함수') def calc():    add(1, 2)    # add 함수가 끝나면 다시 calc 함수로 돌아옴    print('calc 함수') calc()메인 루틴에서 서브 루틴을 호출하면 서브 루틴의 코드를 실행한 뒤 다시 메인 루틴으로 돌아온다. 특히 서브 루틴이 끝나면 서브 루틴의 내용은 모두 사라진다. 즉, 서브 루틴은 메인 루틴에 종속된 관계이다.코루틴은 방식이 위와는 조금 다르다. 코루틴(coroutine)은 cooperative routine을 의미하는데 서로 협력하는 루틴이라는 뜻이다. 즉, 메인루틴과 서브 루틴처럼 종속된 관계가 아니고 서로 대등한 관계이며 특정 시점에 상대방의 코드를 실행한다. 코루틴은 함수가 종료되지 않은 상태에서 메인 루틴의 코드를 실행한 뒤 다시 돌아와서 코루틴의 코드를 실행한다. 따라서 코루틴이 종료되지 않았으므로 코루틴의 내용도 계속 유지된다.일반 함수를 호출하면 코드를 한 번만 실행할 수 있지만, 코루틴은 코드를 여러 번 실행할 수 있다. 참고로 함수의 코드를 실행하는 지점을 진입점(entry point)이라고 하는데, 코루틴은 진입점이 여러 개인 함수이다.1.코루틴에 값 보내기코루틴은 제너레이터의 특별한 형태이다. 제너레이터는 yield로 값을 발생시켰지만 코루틴은 yield로 값을 받아올 수 있다. 다음과 같이 코루틴에 값을 보내면서 코드를 실행할 때는 send 메서드를 사용한다. sand 메서드가 보낸 값을 받아오려면(yield) 형식으로 yield를 괄호로 묶어준 뒤 변수에 저장한다.  코루틴객체.send(값)  변수 = (yield)그럼 코루틴에 숫자 1, 2, 3을 보내서 출력해보겠다.def number_coroutine():    while True:        # 코루틴을 계속 유지하기 위해 무한 루프 사용        x = (yield)    # 코루틴 바깥에서 값을 받아옴, yield를 괄호로 묶어야 함        print(x) co = number_coroutine()next(co)      # 코루틴 안의 yield까지 코드 실행(최초 실행) co.send(1)    # 코루틴에 숫자 1을 보냄co.send(2)    # 코루틴에 숫자 2을 보냄co.send(3)    # 코루틴에 숫자 3을 보냄# 실행 결과123코루틴 number_coroutine은 while True:로 무한히 반복하도록 만든다. 왜냐하면 코루틴을 종료하지 않고 계속 유지시키기 위해 무한 루프를 사용한다. 그리고 x = (yield)와 같이 코루틴 바깥에서 보낸 값을 받아서 x에 저장하고, print로 x의 값을 출력한다.def number_coroutine():    while True:        # 코루틴을 계속 유지하기 위해 무한 루프 사용        x = (yield)    # 코루틴 바깥에서 값을 받아옴, yield를 괄호로 묶어야 함        print(x)코루틴 바깥에서는 co = number_coroutine()과 같이 코루틴 객체를 생성한 뒤 next(co)로 코루틴 안의 코드를 최초로 실행하여 yield까지 코드를 실행한다.  next(코루틴객체)co = number_coroutine()next(co)      # 코루틴 안의 yield까지 코드 실행(최초 실행)그다음에 co.send로 숫자 1, 2, 3을 보내면 코루틴 안에서 숫자를 받은 뒤 print로 출력한다.co.send(1)    # 코루틴에 숫자 1을 보냄co.send(2)    # 코루틴에 숫자 2을 보냄co.send(3)    # 코루틴에 숫자 3을 보냄먼저 next(co)로 코루틴의 코드를 최초로 실행하면 x = (yield)의 yield에서 대기하고 다시 메인 루틴으로 돌아온다. 그다음에 메인 루틴에서 co.send(1)로 1을 보내면 코루틴은 대기 상태에서 풀리고 x = (yield)의 x = 부분이 실행된 뒤 print(x)로 숫자를 출력한다. 이 코루틴은 while True:로 반복하는 구조이므로 다시 x = (yield)의 yield에서 대기한다. 그러고 나서 메인 루틴으로 돌아옵니다. 이런 과정으로 send가 보낸 값을 (yield)가 받게 된다. 계속 같은 과정으로 send를 사용하여 값을 보내면 코루틴에서 값을 받아서 출력한다.정리하자면 next 함수(__next__ 메서드)로 코루틴의 코드를 최초로 실행하고, send 메서드로 코루틴에 값을 보내면서 대기하고 있던 코루틴의 코드를 다시 실행한다.send로 코루틴의 코드를 최초로 실행하기지금까지 코루틴의 코드를 최초로 실행할 때 next 함수(next 메서드)를 사용했지만, 코루틴객체.send(None)과 같이 send 메서드에 None을 지정해도 코루틴의 코드를 최초로 실행할 수 있다.2.코루틴 바깥으로 값 전달하기코루틴에서 바깥으로 값을 전달해보자. 다음과 같이 (yield 변수) 형식으로 yield에 변수를 지정한 뒤 괄호로 묶어주면 값을 받아오면서 바깥으로 값을 전달한다. 그리고 yield를 사용하여 바깥으로 전달한 값은 next 함수(next 메서드)와 send 메서드의 반환값으로 나온다.  변수 = (yield 변수)  변수 = next(코루틴객체)  변수 = 코루틴객체.send(값)그럼 코루틴에 숫자를 보내고, 코루틴은 받은 숫자를 누적해서 바깥에 전달해보자.def sum_coroutine():    total = 0    while True:        x = (yield total)    # 코루틴 바깥에서 값을 받아오면서 바깥으로 값을 전달        total += x co = sum_coroutine()print(next(co))      # 0: 코루틴 안의 yield까지 코드를 실행하고 코루틴에서 나온 값 출력 print(co.send(1))    # 1: 코루틴에 숫자 1을 보내고 코루틴에서 나온 값 출력print(co.send(2))    # 3: 코루틴에 숫자 2를 보내고 코루틴에서 나온 값 출력print(co.send(3))    # 6: 코루틴에 숫자 3을 보내고 코루틴에서 나온 값 출력# 실행 결과0136코루틴에서 값을 누적할 변수 total을 만들고 0을 할당한다. 그리고 x = (yield total)과 같이 값을 받아오면서 바깥으로 값을 전달하도록 만든다. 즉, 바깥에서 send가 보낸 값은 x에 저장되고, 코루틴 바깥으로 보낼 값은 total이다. 그 다음에 total += x 와 같이 받은 값을 누적해 준다.def sum_coroutine():    total = 0    while True:        x  = (yield total)    # 코루틴 바깥에서 값을 받아오면서 바깥으로 값을 전달        total += x코루틴 바깥에서는 co = sum_coroutine()과 같이 코루틴 객체를 생성한 뒤 next(co)로 코루틴 안의 코드를 최초로 실행하여 yield까지 코드를 실행하고, print로 next(co)에서 변환된 값을 출력한다. 그다음에 co.send로 숫자 1, 2, 3을 보내고 print로 co.send에서 반환된 값을 출력한다.co = sum_coroutine()print(next(co))      # 0: 코루틴 안의 yield까지 코드를 실행하고 코루틴에서 나온 값 출력 print(co.send(1))    # 1: 코루틴에 숫자 1을 보내고 코루틴에서 나온 값 출력print(co.send(2))    # 3: 코루틴에 숫자 2를 보내고 코루틴에서 나온 값 출력print(co.send(3))    # 6: 코루틴에 숫자 3을 보내고 코루틴에서 나온 값 출력next와 send의 차이를 살펴보면 next는 코루틴의 코드를 실행하지만 값을 보내지 않을 때 사용하고, send는 값을 보내면서 코루틴의 코드를 실행할 때 사용한다.먼저 next(co)로 코루틴의 코드를 최초로 실행하면 x = (yield total)의 yield에서 total을 메인 루틴으로 전달하고 대기한다. 그다음에 메인 루틴에서 print(next(co))와 같이 코루틴에서 나온 값을 출력한다. 여기서는 total에 0이 들어있으므로 0을 받아와서 출력한다.그리고 co.send(1)로 1을 보내면 코루틴은 대기 상태에서 풀리고 x = (yield total)의 x = 부분이 실행된뒤 total += x로 숫자를 누적한다. 이 코루틴은 while True:로 반복하는 구조이므로 다시 x=(yield total)의 yield에서 total을 메인 루틴으로 전달하고 대기한다. 그다음에 메인 루틴에서 print(co.send(1))과 같이 코루틴에서 나온 값을 출력한다. 여기서는 total에 1이들어가 있으므로 1을 받아와서 출력한다.이런 과정으로 (yield total)이 바깥으로 전달한 값을 next와 send의 반환값으로 받고, send가 보낸 값을 x = (yield total)의 x가 받게 된다.제너레이터와 코루틴의 차이점을 정리해보자.  제너레이터는 next 함수(__next__ 메서드)를 반복 호출하여 값을 얻어내는 방식  코루틴은 next 함수(__next__ 메서드)를 한 번만 호출한 뒤 send로 값을 주고 받는 방식값을 보내지 않고 코루틴의 코드 실행하기값을 보내지 않으면서 코루틴의 코드를 실행할 때는 next 함수(next 메서드)만 사용하면 된다. 잘 생각해보면 이 방식이 일반적인 제너레이터이다.3. 코루틴을 종료하고 예외 처리하기보통 코루틴은 실행 상태를 유지하기 위해 while:True:를 사용해서 끝나지 않는 무한 루프로 동작한다. 만약 코루틴을 강제로 종료하고 싶다면 close메서드를 사용한다.  코루틴객체.close()다음은 코루틴에 숫자를 20개 보낸 뒤 코루틴을 종료한다. 코루틴 객체에서 close 메서드를 사용하면 코루틴이 종료된다. 사실 파이썬 스크립트가 끝나면 코루틴도 끝나기 때문에 close를 사용하지 않은 것과 별 차이가 없다. 하지만 close는 코루틴의 종료 시점을 아아야 할 때 사용하면 편리하다.def number_coroutine():    while True:        x = (yield)        print(x, end=' ') co = number_coroutine()next(co) for i in range(20):    co.send(i) co.close()    # 코루틴 종료# 실행 결과0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19GeneratorExit 예외 처리하기코루틴 객체에서 close 메서드를 호출하면 코루틴이 종료될 때 GeneratorExit 예외가 발생한다. 따라서 이 예외를 처리하면 코루틴의 종료 시점을 알 수 있다.def number_coroutine():    try:        while True:            x = (yield)            print(x, end=' ')    except GeneratorExit:    # 코루틴이 종료 될 때 GeneratorExit 예외 발생        print()        print('코루틴 종료') co = number_coroutine()next(co) for i in range(20):    co.send(i) co.close()0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 코루틴 종료코루틴 안에서 try except로 GeneratorExit 예외가 발생하면 ‘코루틴 종료’가 출력되도록 만들었다. 이렇게 하면 close 메서드로 코루틴을 종료할 때 원하는 코드를 실행할 수 있다.    except GeneratorExit:    # 코루틴이 종료 될 때 GeneratorExit 예외 발생        print()        print('코루틴 종료')코루틴 안에서 예외 발생시키기이번에는 코루틴 안에 예외를 발생시켜서 코루틴을 종료해보자.코루틴 안에 예외를 발생 시킬 때는 throw 메서드를 사용합니다. throw는 말그대로 던지다라는 뜻인데 예외를 코루틴 안으로 던진다. 이때 throw 메서드에 지정한 에러 메시지는 except as의 변수에 들어간다.  코루틴객체.throw(예외이름, 에러메시지)다음은 코루틴에 숫자를 보내서 누적하다가 RuntimeError 예외가 발생하면 에러 메시지를 출력하고 누적된 값을 코루틴 바깥으로 전달한다.def sum_coroutine():    try:        total = 0        while True:            x = (yield)            total += x    except RuntimeError as e:        print(e)        yield total    # 코루틴 바깥으로 값 전달 co = sum_coroutine()next(co) for i in range(20):    co.send(i) print(co.throw(RuntimeError, '예외로 코루틴 끝내기')) # 190                                                      # 코루틴의 except에서 yield로 전달받은 값# 실행 결과예외로 코루틴 끝내기190코루틴 안에서 try except로 RuntimeError 예외가 발생하면 print로 에러 메시지를 출력하고 yield를 사용하여 total을 바깥으로 전달하도록 만들었다.    except RuntimeError as e:        print(e)        yield total    # 코루틴 바깥으로 값 전달코루틴 바깥에서는 co.throw(RuntimeError, ‘에외로 코루틴 끝내기’)와 같이 throw 메서드에 RuntimeError 예외와 에러 메시지를 지정하면 코루틴 안에서 예외가 발생한다. 그리고 코루틴 안의 except에서 yield를 사용하여 바깥으로 전달한 값은 throw 메서드의 반환 값으로 나온다.여기서는 코루틴 안에서 예외 처리를 했으므로 ‘예외로 코루틴 끝내기’가 출력되고, 코루틴 바깥에서는 누적된 값 190이 출력된다.4. 하위 코루틴의 반환값 가져오기제너레이터에서 yield from을 사용하면 값을 바깥으로 여러 번 전달한다고 했습니다(‘40.3 yield from으로 값을 여러 번 바깥으로 전달하기’ 참조). 하지만 코루틴에서는 조금 다르게 사용한다. yield from에 코루틴를 지정하면 해당 코루틴에서 return으로 반환한 값을 가져온다(yield from은 파이썬 3.3 이상부터 사용 가능)  변수 = yield from 코루틴()다음은 코루틴에서 숫자를 누적한 뒤 합계를 yield from으로 가져온다.코루틴에 1부터 10까지 보내서 합계 55를 구하고, 다시 1부터 100까지 보내서 합계 5050을 구했다.def accumulate():    total = 0    while True:        x = (yield)         # 코루틴 바깥에서 값을 받아옴        if x is None:       # 받아온 값이 None이면            return total    # 합계 total을 반환        total += x def sum_coroutine():    while True:        total = yield from accumulate()    # accumulate의 반환값을 가져옴        print(total) co = sum_coroutine()next(co) for i in range(1, 11):    # 1부터 10까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄 for i in range(1, 101):   # 1부터 100까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄# 실행 결과555050먼저 숫자를 받아서 누적할 코루틴을 만든다. x = (yield)와 같이 코루틴 바깥에서 값을 받아온 뒤 total에 계속 더한다. 특히 이 코루틴은 while True:로 무한히 반복하지만 코루틴을 끝낼 방법이 필요하다. 여기서는 코루틴 바깥에서 받아온 값이 None이면 return으로 total을 반환하고 코루틴을 끝낸다.def accumulate():    total = 0    while True:        x = (yield)         # 코루틴 바깥에서 값을 받아옴        if x is None:       # 받아온 값이 None이면            return total    # 합계 total을 반환, 코루틴을 끝냄        total += x이제 합계를 출력할 코루틴을 만든다. 먼저 while True:로 무한히 반복한다. 그리고 total = yield from accumulate()와 같이 yield from을 사용하여 코루틴 accumulate의 반환값을 가져온다.co = sum_coroutine()next(co) for i in range(1, 11):    # 1부터 10까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄코루틴에서 yield from을 사용하면 코루틴 바깥에서 send로 하위 코루틴까지 값을 보낼 수 있다. 따라서 co = sum_coroutine()으로 코루틴 객체를 만든 뒤 co.send로 값을 보내면 accumulate에서 값을 받는다.co = sum_coroutine()next(co) for i in range(1, 11):    # 1부터 10까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄co.send로 숫자를 계속 내보내다가 누적을 끝내고 싶으면 None을 보내면 된다.co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄이때 accumulate는 None을 받으면 코루틴이 완전히 끝나지만 sum_coroutine에서 무한 루프로 반복하고 있으므로 print로 total을 출력한 뒤 다시 yield from accumulate()로 accumulate를 실행하게 된다.def sum_coroutine():    while True:        total = yield from accumulate()    # accumulate가 끝나면 yield from으로 다시 실행        print(total)StopIteration 예외 발생시키기코루틴도 제너레이터이므로 return을 사용하면 StopIteration이 발생한다. 그래서 코루틴에서 return 값은 raise StopIteration(값)처럼 사용할 수도 있다(파이썬 3.6 이하). 이렇게 raise로 StopIteration 예외를 직접 발생시키고 값을 지정하면 yield from으로 값을 가져올 수 있다(단, 파이썬 3.7부터는 제너레이터 안에서 raise로 StopIteration 예외를 직접 발생시키면 RuntimeError로 바뀌므로 이 방법은 사용할 수 없다. 파이썬 3.7부터는 그냥 return 값을 사용하자)  raise StopIteration(값)def accumulate():    total = 0    while True:        x = (yield)                       # 코루틴 바깥에서 값을 받아옴        if x is None:                     # 받아온 값이 None이면            raise StopIteration(total)    # StopIteration에 반환할 값을 지정(파이썬 3.6 이하)        total += x def sum_coroutine():    while True:        total = yield from accumulate()    # accumulate의 반환값을 가져옴        print(total) co = sum_coroutine()next(co) for i in range(1, 11):    # 1부터 10까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄 for i in range(1, 101):   # 1부터 100까지 반복    co.send(i)            # 코루틴 accumulate에 숫자를 보냄co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄# 실행 결과555050accumulate에서 return total 대신 raise StopIteration(total)을 사용했다. 이때도 yield from은 accumulate의 total을 가져오게 된다.코루틴의 yield from으로 값을 발생시키기아래 예제에서는  x = (yield)와 같이 코루틴 바깥에서 보낸 값만 받아왔다. 하지만 코루틴에서 yield에 값을 지정해서 바깥으로 전달했다면 yield from은 해당 값을 다시 바깥으로 전달된다.def number_coroutine():    x = None    while True:        x = (yield x)    # 코루틴 바깥에서 값을 받아오면서 바깥으로 값을 전달        if x == 3:            return x def print_coroutine():    while True:        x = yield from number_coroutine()   # 하위 코루틴의 yield에 지정된 값을 다시 바깥으로 전달        print('print_coroutine:', x) co = print_coroutine()next(co) x = co.send(1)    # number_coroutine으로 1을 보냄print(x)          # 1: number_coroutine의 yield에서 바깥으로 전달한 값x = co.send(2)    # number_coroutine으로 2를 보냄print(x)          # 2: number_coroutine의 yield에서 바깥으로 전달한 값co.send(3)        # 3을 보내서 반환값을 출력하도록 만듦# 실행 결과12print_coroutine: 3예제1다음 소스 코드를 완성하여 문자열에서 특정 단어가 있으면 True, 없으면 False가 출력되게 만드세요. find 함수는 코루틴으로 작성해야 합니다._________________________________..._________________________________ f = find('Python')next(f) print(f.send('Hello, Python!'))print(f.send('Hello, world!'))print(f.send('Python Script')) f.close()                                                      실행 결과TrueFalseTrue답def find(word):    result = False    while True:        line = (yield result)        result = word in lineㅇ예제2표준 입력으로 사칙연산 계산식이 여러 개 입력됩니다. 다음 소스 코드에서 각 계산식의 결과를 구하는 코루틴을 만드세요. 계산식은 문자열 형태이며 값과 연산자는 공백으로 구분됩니다. 그리고 값은 정수로 변환하여 사용하고, 나눗셈은 / 연산자를 사용하세요.________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________expressions = input().split(', ') c = calc()next(c) for e in expressions:    print(c.send(e)) c.close()# 입력1 + 2, 4 - 9# 결과3-5# 입력3 * 4, 10 / 5, 20 + 39# 결과122.059답def calc():    result = 0    while True:        x = (yield result)        a, y, b = x.split()        if y == '+':            result = int(a) + int(b)        elif y == '-':            result = int(a) - int(b)        elif y == '/':            result = int(a) / int(b)        elif y == '*':            result = int(a) * int(b)코루틴으로 무한루프를 만들고 (yield 변수) 형식으로 바깥으로 값을 전달한다. 전달한 값은 next(c)함수와 send메서드의 반환값으로 들어가게 된다. expressions에 입력 받은 값을 split 함수로 각 문자열로 쪼개면 expressions[0].split()-&gt;[‘1’, ‘+’, ‘2’] 이런 형태가 되는데 a, y, b = x.split()로 각 요소를 a, y, b변수에 할당해 준다. 그리고 if와 elif 조건문으로 y의 값이 특정 값일때의 조건을 넣어주면 된다.",
        "url": "/python-basic39"
    }
    ,
    
    "python-basic38": {
        "title": "Python - Python 제너레이터 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기제너레이터 사용하기제너레이터는 이터레이터를 생서해주는 함수다. 이터레이터는 클래스에 __iter__, __next__ 또는 __getitem__ 메서드를 구현해야 하지만 제너레이터는 함수 안에서 yield라는 키워드만 사용하면 끝난다. 그래서 제너레이터는 이터레이터보다 훨씬 간단하게 작성할 수 있다. 제너레이터는 발생자 라고 부르기도 한다.1.제너레이터와 yield 알아보기함수 안에서 yield를 사용하면 함수는 제너레이터가 되며 yield에는 값(변수)을 지정한다.  yield 값yield를 사용해서 제너레이터를 만들고 for 반복문에 0, 1, 2숫자 세 개를 출력해 보자.for 반복문에 number_generator()를 지정해서 값을 출력해보면 yield에 지정했던 0, 1, 2가 나온다. 이터레이터와 사용 방법이 똑같다.def number_generator():    yield 0    yield 1    yield 2 for i in number_generator():    print(i)# 실행 결과012제너레이터 객체가 이터레이터인지 확인하기그럼 number_generator 함수로 만든 객체가 정말 이터레이터인지 살펴보자. 다음과 같이 dir 함수로 메서드 목록을 확인한다. number_generator 함수를 호출하면 제너레이터 객체(generator object)가 반환된다. 이 객체를 dir 함수로 살펴보면 이터레이터에서 볼 수 있는 iter, next 메서드가 들어있다.def number_generator():    yield 0    yield 1    yield 2 for i in number_generator():    print(i)g = number_generator()g&lt;generator object number_generator at 0x03A190F0&gt;dir(g)['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']실제로 제너레이터 객체의 __next__를 호출해보면 숫자 0, 1, 2가 나오다가 StopIteration 예외가 발생한다.g.__next__()0g.__next__()1g.__next__()2g.__next__()Traceback (most recent call last):  File \"&lt;pyshell#29&gt;\", line 1, in &lt;module&gt;    g.__next__()StopIteration위코드를 보면 제너레이터와 이터레이터의 동작이 같은걸 알 수 있다. 이렇게 yield를 사용해 간단한게 이터레이터를 구현할 수 있다. 단, 이터레이터는 __next__메서드 안에서 직접 return으로 값을 반환했지만 제너레이터는 yield에 지정한 값이 __next__ 메서드(next 함수)의 반환값으로 나온다. 또한, 이터레이터는 raise로 StopIteration 예외를 직접 발생시켰지만 제너레이터는 함수의 끝까지 도달하면 StopIteration 예외가 자동으로 발생한다. 제너레이터는 제너레이터 객체에서 __next__ 메서드를 호출할 때마다 함수 안의 yield까지 코드를 실행하며 yield에서 값을 발생시킨다(generate). 그래서 이름이 제너레이터(generator)이다.for와 제너레이터for 반복문과 제너레이터를 살펴보자. for 반복문은 반복할 때마다 __next__를 호출하므로 yield에서 발생시킨 값을 가져온다. 그리고 StopIteration 예외가 발생하면 반복을 끝낸다.참고로 제너레이터 객체에서 __iter__를 호출하면 self를 반환하므로 같은 객체가 나온다(제너레이터 함수 호출 &gt; 제너레이터 객체 &gt; __iter__는 self 반환 &gt; 제너레이터 객체).(yield는 생산하다라는 뜻과 함께 양보하다라는 뜻도 가지고 있다. 즉, yield를 사용하면 값을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보한다. 따라서 yield는 현재 함수를 잠시 중단하고 함수 바깥의 코드가 실행되도록 만든다.)yield의 동작 과정 알아보기yield의 동작 과정을 알아보기 위해 for반복문 대신 next함수로 __next__메서드를 직접 호출해 보자.  변수 = next(제너레이터객체)def number_generator():    yield 0    # 0을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보    yield 1    # 1을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보    yield 2    # 2를 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보 g = number_generator() a = next(g)    # yield를 사용하여 함수 바깥으로 전달한 값은 next의 반환값으로 나옴print(a)       # 0 b = next(g)print(b)       # 1 c = next(g)print(c)       # 2yield를 사용하여 바깥으로 전달한 값은 next 함수(__next__ 메서드)의 반환값으로 나온다고 했다. 따라서 next(g)의 반환값을 출력해보면 yield에 지정한 값 0, 1, 2가 차례대로 나옵니다. 즉, 제너레이터 함수가 실행되는 중간에 next로 값을 가져온다.제너레이터와 return제너레이터는 함수 끝까지 도달하면 StopIteration 예외가 발생한다. 마찬가지로 return도 함수를 끝내므로 return을 사용해서 함수 중간에 빠져나오면 StopIteration 예외가 발생한다.특히 제너레이터 안에서 return에 반환값을 지정하면 StopIteration 예외의 에러 메시지로 들어간다.def one_generator():    yield 1    return 'return에 지정한 값' try:    g = one_generator()    next(g)    next(g)except StopIteration as e:    print(e)    # return에 지정한 값#실행 결과return에 지정한 값2.제너레이터 만들기range(횟수)처럼 동작을 하는 제너레이터를 만들어 보자. 제너레이터 안에서 변수n을 만들고 초기값으로 0을 저장한다. 그리고 while n &lt; stop:과 같이 반복을 끝낼 숫자보다 작을 때 반복하도록 만든다. 반복문 안에서는 yield n으로 숫자를 바깥으로 전달한 뒤 n을 1 증가시키게 한다. 여기서 stop에 3이들어가기 떄문에 for 반복문도 3번 반복한다.def number_generator(stop):    n = 0              # 숫자는 0부터 시작    while n &lt; stop:    # 현재 숫자가 반복을 끝낼 숫자보다 작을 때 반복        yield n        # 현재 숫자를 바깥으로 전달        n += 1         # 현재 숫자를 증가시킴 for i in number_generator(3):    print(i)# 실행 결과012next 함수(__next__ 메서드)도 3번 사용할 수 있다.g = number_generator(3)next(g)0next(g)1next(g)2next(g)Traceback (most recent call last):  File \"&lt;pyshell#100&gt;\", line 1, in &lt;module&gt;    next(g)StopIterationyield에서 함수 호출하기yield에 함수(메서드)를 호출해보자.yield i.upper()와 같이 yield에서 함수(메서드)를 호출하면 해당 함수의 반환값을 바깥으로 전달한다. upper는 호출했을 때 대문자로 된 문자열을 반환하므로 yield는 이 문자열을 바깥으로 전달한다. 즉, yield에 무엇을 지정하든 결과만 바깥으로 전달한다(함수의 반환값, 식의 결과).def upper_generator(x):    for i in x:        yield i.upper()    # 함수의 반환값을 바깥으로 전달 fruits = ['apple', 'pear', 'grape', 'pineapple', 'orange']for i in upper_generator(fruits):    print(i)# 실행 결과APPLEPEARGRAPEPINEAPPLEORANGE3.yield from으로 값을 여러 번 바깥으로 전달하기값을 여러 번 바깥으로 전달할 때는 for 또는 while 반복문으로 반복하면서 yield를 사용했다. 아래 코드는 리스트의 요소를 바깥으로 전달한다.def number_generator():    x = [1, 2, 3]    for i in x:        yield i for i in number_generator():    print(i)#실행 결과123위와 같은 경우엔 매번 반복문을 사용하지 않고, yield from을 사용하면 된다. yield from에는 반복 가능한 객체, 이터레이터, 제너레이터 객체를 지정한다.  yield from 반복가능한객체  yield from 이터레이터  yield from 제너레이터객체그럼 yield from에 리스트를 지정해서 숫자 1, 2, 3을 바깥으로 전달해 보자. yield from x와 같이 yield from에 리스트(반복 가능한 객체)를 지정했다. 이렇게 하면 리스트에 들어있는 요소를 한 개씩 바깥으로 전달한다. 즉, yield from을 한 번 사용하여 값을 세 번 바깥으로 전달한다. 따라서 next 함수(__next__ 메서드)를 세 번 호출할 수 있다.def number_generator():    x = [1, 2, 3]    yield from x    # 리스트에 들어있는 요소를 한 개씩 바깥으로 전달 for i in number_generator():    print(i)# 실행 결과123&gt;&gt;&gt; g = number_generator()&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)2&gt;&gt;&gt; next(g)3&gt;&gt;&gt; next(g)Traceback (most recent call last):  File \"&lt;pyshell#105&gt;\", line 1, in &lt;module&gt;    next(g)StopIterationyield from에 제너레이터 객체 지정하기yield from에 제너레이터 객체를 지정해보자. 제너레이터 number_generator는 매개변수로 받은 숫자 직전까지 숫자를 만들어낸다. three_generator에서는 yield from number_generator(3)과 같이 yield from에 제너레이터 객체를 지정했다.number_generator(3)은 숫자를 세 개를 만들어내므로 yield from number_generator(3)은 숫자를 세 번 바깥으로 전달한다. 따라서 for 반복문에 three_generator()를 사용하면 숫자를 세 번 출력한다(next 함수 또는 next 메서드도 세 번 호출 가능).def number_generator(stop):    n = 0    while n &lt; stop:        yield n        n += 1 def three_generator():    yield from number_generator(3)    # 숫자를 세 번 바깥으로 전달 for i in three_generator():    print(i)#실행 결과012제너레이터 표현식리스트 표현식을 사용할 때  를 사용했다. 같은 리스트 표현식을 ( )(괄호)로 묶으면 제너레이터 표현식이 된다. 리스트 표현식은 처음부터 리스트의 요소를 만들어내지만 제너레이터 표현식은 필요할 때 요소를 만들어내므로 메모리를 절약할 수 있다.  (식 for 변수 in 반복가능한객체)&gt;&gt;&gt; [i for i in range(50) if i % 2 == 0][0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]&gt;&gt;&gt; (i for i in range(50) if i % 2 == 0)&lt;generator object &lt;genexpr&gt; at 0x024F02A0&gt;예제1다음 소스 코드에서 words.txt 파일을 한 줄씩 읽은 뒤 내용을 함수 바깥에 전달하는 제너레이터를 작성하세요. 파일의 내용을 출력할 때 파일에서 읽은 \\n은 출력되지 않아야 합니다(단어 사이에 줄바꿈이 두 번 일어나면 안 됨).# words.txtcompatibilityexperiencephotographyspotlightdef file_read():    with open('words.txt') as file:        ______________________                                  ...        ______________________                            for i in file_read():    print(i)                                                      #실행 결과compatibilityexperiencephotographyspotlight답while True:    line = file.readline()    if line == '':        break    yield line.strip('\\n')예제2표준 입력으로 정수 두 개가 입력됩니다(첫 번째 입력 값의 범위는 10~1000, 두 번째 입력 값의 범위는 100~1000이며 첫 번째 입력 값은 두 번째 입력 값보다 항상 작습니다). 다음 소스 코드에서 첫 번째 정수부터 두 번째 정수 사이의 소수(prime number)를 생성하는 제너레이터를 만드세요. 소수는 1과 자기자신만으로 나누어 떨어지는 1보다 큰 양의 정수입니다.________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________start, stop = map(int, input().split()) g = prime_number_generator(start, stop)print(type(g))for i in g:    print(i, end=' ')#입력50 100#결과&lt;class 'generator'&gt;53 59 61 67 71 73 79 83 89 97 #입력950 1000#결과&lt;class 'generator'&gt;953 967 971 977 983 991 997 답def isPrime(number): # 아래 prime_number_generator함수에서 i의 값이 매개변수로 들어간다.    if number == 1:        return False #소수는 1보다 큰 자연수 중 1과 자기자신만을 약수로 가지는 수이다.                      #1은 1보다 크지 않기 때문에 소수가 아니다.    for i in range(2, number): # 2부터 전달된 number의 값까지 i에 전달하고         if number % i == 0: # 전달된 number를 number전의 수까지로 나누어 0이 되면 소수가 아니다.            return False    return Truedef prime_number_generator(start, stop):    for i in range(start, stop+1):        if isPrime(i):            yield i",
        "url": "/python-basic38"
    }
    ,
    
    "python-basic37": {
        "title": "Python - Python 이터레이터 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기이터레이터 사용하기이터레이터((iterator)는 값을 차례대로 꺼낼 수 있는 객체(object)이다. 지금까지 for반복문을 사용할 때 range를 사용했다. 만약 100번을 반복한다면 for i in range(100): 처럼 만들었다. 이 for 반복문을 설명할 때 for i in range(100):은 0부터 99까지 연속된 숫자를 만들어 낸다고 했는데, 사실은 숫자를 모두 만들어 내는 것이 아니라 0부터 99까지 값을 차례대로 꺼낼 수 있는 이터레이터를 하나만 만들어낸다. 이후 반복할 때만다 이터레이터에서 숫자를 하나씩 꺼내서 반복한다.만약 연속된 숫자를 미리 만들면 숫자가 적을 때는 상관없지만 숫자가 아주 많을 때는 메모리를 많이 사용하게 되므로 성능에도 불리하다. 그래서 파이썬에서는 이터레이터만 생성하고 값이 필요한 시점이 되었을 때 값을 만드는 방식을 사용한다. 즉, 데이터 생성을 뒤로 미루는 것인데 이런 방식을 지연 평가(lazy evaluation)라고 한다.참고로 이터레이터는 반복자라고 부르기도 한다.1. 반복 가능한 객체 알아보기이터레이터를 만들기 전에 먼저 반복 가능한 객체(iterable)에 대해 알아보자. 반복 가능한 객체는 말 그대로 반복할 수 있는 객체인데 우리가 흔히 사용하는 문자열, 리스트, 딕셔너리, 세트가 반복 가능한 객체이다. 즉, 요소가 여러 개 들어가있고, 한 번에 하나씩 꺼낼 수 있는 객체이다.객체가 반복 가능한 객체인지 알아보는 방법은 객체에 __iter__ 메서드가 들어있는지 확인해보면 된다. 다음과 같이 dir 함수를 사용하면 객체의 메서드를 확인할 수 있다.  dir(객체)리스트 [1, 2, 3]을 dir로 살펴보면 __iter__ 메서드가 들어있습니다. 이 리스트에서 __iter__를 호출해보면 이터레이터가 나온다.dir([1, 2, 3])['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'][1, 2, 3].__iter__()&lt;list_iterator object at 0x03616630&gt;리스트의 이터레이터를 변수에 저장한 뒤 __next__ 메서드를 호출해보면 요소를 차례대로 꺼낼 수 있다. it에서 __next__를 호출할 때마다 리스트에 들어있는 1, 2, 3이 나옵니다. 그리고 3 다음에 __next__를 호출하면 StopIteration 예외가 발생한다. 즉, [1, 2, 3]이므로 1, 2, 3 세 번 반복한다.이처럼 이터레이터는 __next__로 요소를 계속 꺼내다가 꺼낼 요소가 없으면 StopIteration 예외를 발생시켜서 반복을 끝낸다.it = [1, 2, 3].__iter__()it.__next__()1it.__next__()2it.__next__()3it.__next__()Traceback (most recent call last):  File \"&lt;pyshell#48&gt;\", line 1, in &lt;module&gt;    it.__next__()StopIteration물론, 리스트뿐만 아니라 문자열, 딕셔너리, 세트도 __iter__를 호출하면 이터레이터가 나온다. 그리고 이터레이터에서 __next__를 호출하면 차례대로 값을 꺼낸다.'Hello, world!'.__iter__()&lt;str_iterator object at 0x03616770&gt;{'a': 1, 'b': 2}.__iter__() # key만 출력&lt;dict_keyiterator object at 0x03870B10&gt;{1, 2, 3}.__iter__()&lt;set_iterator object at 0x03878418&gt;리스트, 문자열, 딕셔너리, 세트는 요소가 눈에 보이는 반복 가능한 객체다. 이번에는 요소가 눈에 보이지 않는 range를 살펴보자. 다음과 같이 range(3)에서 __iter__로 이터레이터를 얻어낸 뒤 __next__ 메서드를 호출했다.it = range(3).__iter__()it.__next__()0it.__next__()1it.__next__()2it.__next__()Traceback (most recent call last):  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;    it.__next__()StopIterationit에서 __next__를 호출할 때마다 0부터 숫자가 증가해서 2까지 나왔다. 그리고 2 다음에 __next__를 호출했을 때 StopIteration 예외가 발생했다. 즉, range(3)이므로 0, 1, 2 세 번 반복하며 요소가 눈에 보이지 않지만 지정된 만큼 숫자를 꺼내서 반복할 수 있다.for와 반복 가능한 객체이제 for에 반복 가능한 객체를 사용했을 때 동작 과정을 알아보겠다. 다음과 같이 for에 range(3)을 사용했다면 먼저 range에서 __iter__로 이터레이터를 얻는다. 그리고 한 번 반복할 때마다 이터레이터에서 __next__로 숫자를 꺼내서 i에 저장하고, 지정된 숫자 3이 되면 StopIteration을 발생시켜서 반복을 끝낸다.이렇듯 반복 가능한 객체는 __iter__ 메서드로 이터레이터를 얻고, 이터레이터의 __next__ 메서드로 반복한다. 여기서는 반복 가능한 객체와 이터레이터가 분리되어 있지만 클래스에 __iter__와 __next__ 메서드를 모두 구현하면 이터레이터를 만들 수 있다. 특히 __iter__, __next__를 가진 객체를 이터레이터 프로토콜(iterator protocol)을 지원한다고 말한다.정리하자면 반복 가능한 객체는 요소를 한 번에 하나씩 가져올 수 있는 객체이고, 이터레이터는 __next__ 메서드를 사용해서 차례대로 값을 꺼낼 수 있는 객체다. 반복 가능한 객체(iterable)와 이터레이터(iterator)는 별개의 객체이므로 둘은 구분해야 힌다. 즉, 반복 가능한 객체에서 __iter__ 메서드로 이터레이터를 얻는다.시퀀스 객체와 반복 가능한 객체의 차이리스트, 튜플, range, 문자열은 시퀀스 객체라고 했는데, 이 유닛에서는 반복 가능한 객체라고 했다.시퀀스 객체와 반복 가능한 객체의 차이는 리스트, 튜플, range, 문자열은 반복 가능한 객체이면서 시퀀스 객체다. 하지만, 딕셔너리와 세트는 반복 가능한 객체이지만 시퀀스 객체는 아니다. 왜냐하면 시퀀스 객체는 요소의 순서가 정해져 있고 연속적(sequence)으로 이어져 있어야 하는데, 딕셔너리와 세트는 요소(키)의 순서가 정해져 있지 않기 때문이다. 따라서 시퀀스 객체가 반복 가능한 객체보다 좁은 개념이다. 즉, 요소의 순서가 정해져 있고 연속적으로 이어져 있으면 시퀀스 객체, 요소의 순서와는 상관없이 요소를 한 번에 하나씩 꺼낼 수 있으면 반복 가능한 객체다.2.이터레이터 만들기iter, next 메서드를 구현해서 직접 이터레이터를 만들어보자. 간단하게 range(횟수)처럼 동작하는 이터레이터다.class 이터레이터이름:    def __iter__(self):        코드     def __next__(self):        코드코드를 실행하면 012가 나온다. 이렇게 0부터 지정된 숫자 직전까지 반복하는 이터레이터 counter를 정의헀다.class Counter:    def __init__(self, stop):        self.current = 0    # 현재 숫자 유지, 0부터 지정된 숫자 직전까지 반복        self.stop = stop    # 반복을 끝낼 숫자     def __iter__(self):        return self         # 현재 인스턴스를 반환     def __next__(self):        if self.current &lt; self.stop:    # 현재 숫자가 반복을 끝낼 숫자보다 작을 때            r = self.current            # 반환할 숫자를 변수에 저장            self.current += 1           # 현재 숫자를 1 증가시킴            return r                    # 숫자를 반환        else:                           # 현재 숫자가 반복을 끝낼 숫자보다 크거나 같을 때            raise StopIteration         # 예외 발생 for i in Counter(3):    print(i, end=' ')# 실행 결과0 1 2먼저 클래스로 이터레이터를 작성하려면 __init__ 메서드를 만든다. 여기서는 Counter(3)처럼 반복을 끝낼 숫자를 받았으므로 self.stop에 stop을 넣어준다. 그리고 반복할 때마다 현재 숫자를 유지해야 하므로 속성 self.current에 0을 넣어준다(0부터 지정된 숫자 직전까지 반복하므로 0을 넣는다).    def __init__(self, stop):        self.current = 0    # 현재 숫자 유지, 0부터 지정된 숫자 직전까지 반복        self.stop = stop    # 반복을 끝낼 숫자그리고 __iter__ 메서드를 만드는데 여기서는 self만 반환하면 끝이다. 이 객체는 리스트, 문자열, 딕셔너리, 세트, range처럼 __iter__를 호출해줄 반복 가능한 객체(iterable)가 없으므로 현재 인스턴스를 반환하면 된다. 즉, 이 객체는 반복 가능한 객체이면서 이터레이터다.    def __iter__(self):        return self         # 현재 인스턴스를 반환그다음에 __next__ 메서드를 만든다. __next__에서는 조건에 따라 숫자를 만들어내거나 StopIteration 예외를 발생시킨다. 현재 숫자 self.current가 반복을 끝낼 숫자 self.stop보다 작을 때는 self.current를 1 증가시키고 현재 숫자를 반환한다. 이때 1 증가한 숫자를 반환하지 않도록 숫자를 증가시키기 전에 r = self.current처럼 반환할 숫자를 변수에 저장해 놓는다. 그다음에 self.current가 self.stop보다 크거나 같아질 때는 raise StopIteration으로 예외를 발생시킨다.    def __next__(self):        if self.current &lt; self.stop:    # 현재 숫자가 반복을 끝낼 숫자보다 작을 때            r = self.current            # 반환할 숫자를 변수에 저장            self.current += 1           # 현재 숫자를 1 증가시킴            return r                    # 숫자를 반환        else:                           # 현재 숫자가 반복을 끝낼 숫자보다 크거나 같을 때            raise StopIteration         # 예외 발생for 반복문에 Counter(3)을 지정해 실행하면 3번 반복하면서 0, 1, 2가 출력된다.for i in Counter(3):    print(i)이터레이터를 만들 때는 __init__ 메서드에서 초깃값, __next__ 메서드에서 조건식과 현재값 부분을 주의해야 한다.이터레이터 언패킹참고로 이터레이터는 언패킹(unpacking)이 가능하다. 즉, 다음과 같이 Counter()의 결과를 변수 여러 개에 할당할 수 있다. 물론 이터레이터가 반복하는 횟수와 변수의 개수는 같아야 한다.a, b, c = Counter(3)print(a, b, c)0 1 2a, b, c, d, e = Counter(5)print(a, b, c, d, e)0 1 2 3 4자주 사용하는 map도 이터레이터다. 그래서 a, b, c = map(int, input().split())처럼 언패킹으로 변수 여러 개에 값을 할당할 수 있다.반환값을 _에 저장하는 이유함수를 호출한 뒤 반환값을 저장할 때 _(밑줄 문자)를 사용하는 경우가 있다._, b = range(2)b1사실 이 코드는 a, b = range(2)와 같다. 반환값을 언패킹했을 때 _에 할당하는 것은 특정 순서의 반환값 사용하지 않고 무시하겠다는 관례적 표현이다. 예를 들어 다음과 같은 코드는 언패킹 했을 때 두 번째 변수는 사용하지 않겠다는 뜻이다.a, _, c, d =  range(4)a, c, d(0, 2, 3)3.인덱스로 접근할 수 있는 이터레이터 만들기getitem 메서드를 구현하여 인덱스로 접근할 수 있는 이터레이터를 만들어보자.앞에서 만든 Counter 이터레이터를 인덱스로 접근할 수 있도록 다시 만들었다.class 이터레이터이름:    def __getitem__(self, 인덱스):        코드Counter(3)[0]을 출력했을 때 0이 나왔다. 마찬가지로 Counter(3)[1]은 1, Counter(3)[2]는 2가 나왔다. 그리고 for 반복문에 Counter를 사용했을 때도 1, 2, 3이 나왔다.class Counter:    def __init__(self, stop):        self.stop = stop     def __getitem__(self, index):        if index &lt; self.stop:            return index        else:            raise IndexError print(Counter(3)[0], Counter(3)[1], Counter(3)[2]) for i in Counter(3):    print(i, end=' ').#실행 결과0 1 20 1 2소스 코드를 잘 보면 __init__ 메서드와 __getitem__ 메서드만 있는데도 동작이 잘 된다. 클래스에서 getitem__만 구현해도 이터레이터가 되며 __iter, next__는 생략해도 된다(초깃값이 없다면 __init__도 생략 가능). 그럼 __init 메서드부터 살펴보겠습니다. 여기서는 Counter(3)처럼 반복을 끝낼 숫자를 받았으므로 self.stop에 stop을 넣어준다.class Counter:    def __init__(self, stop):        self.stop = stop             # 반복을 끝낼 숫자이제 클래스에서 __getitem__ 메서드를 구현하면 인덱스로 접근할 수 있는 이터레이터가 된다. 먼저 __getitem__은 매개변수로 인덱스 index를 받는다. 그리고 지정된 index가 반복을 끝낼 숫자 self.stop보다 작을 때 index를 반환한다. index가 self.stop보다 크거나 같으면 IndexError를 발생시킨다. 즉, Counter(3)과 같이 반복을 끝낼 숫자가 3이면 인덱스는 2까지 지정할 수 있다.    def __getitem__(self, index):    # 인덱스를 받음        if index &lt; self.stop:        # 인덱스가 반복을 끝낼 숫자보다 작을 때            return index             # 인덱스를 반환        else:                        # 인덱스가 반복을 끝낼 숫자보다 크거나 같을 때            raise IndexError         # 예외 발생이렇게 하면 Counter(3)[0]처럼 이터레이터를 인덱스로 접근할 수 있다.4.iter, next 함수 활용하기이번에는 파이썬 내장 함수 iter, next에 대해 알아보자. iter는 객체의 iter 메서드를 호출해주고, next는 객체의 next 메서드를 호출해준다. 그럼 range(3)에 iter와 next를 사용해보자.it = iter(range(3))next(it)0next(it)1next(it)2next(it)Traceback (most recent call last):  File \"&lt;pyshell#6&gt;\", line 1, in &lt;module&gt;    next(it)StopIteration반복 가능한 객체에서 __iter__를 호출하고 이터레이터에서 __next__를 호출한 것과 똑같다. 즉 iter는 반복 가능한 객체에서 이터레이터를 반환하고, next는 이터레이터에서 값을 차례대로 꺼낸다. iter와 next는 이런 기능 이외에도 다양한 방식으로 사용할 수 있다.iteriter는 반복을 끝낼 값을 지정하면 특정 값이 나올 때 반복을 끝낸다. 이 경우에는 반복 가능한 객체 대신 호출 가능한 객체(callable)를 넣어준다. 참고로 반복을 끝낼 값은 sentinel이라고 부르는데 감시병이라는 뜻이다. 즉, 반복을 감시하다가 특정 값이 나오면 반복을 끝낸다고 해서 sentinel이다.  iter(호출가능한객체, 반복을끝낼값)random.randint(0, 5)와 같이 0부터 5까지 무작위로 숫자를 생성할 때 2가 나오면 반복을 끝내도록 만들었다. 이때 호출 가능한 객체를 넣어야 하므로 매개변수가 없는 함수 또는 람다 표현식으로 만들어준다.import randomit = iter(lambda : random.randint(0, 5), 2)next(it)0next(it)3next(it)1next(it)Traceback (most recent call last):  File \"&lt;pyshell#37&gt;\", line 1, in &lt;module&gt;    next(it)StopIterationnext(it)로 숫자를 계속 만들다가 2가 나오면 StopIteration이 발생한다. 물론 숫자가 무작위로 생성되므로 next(it)를 호출하는 횟수도 매번 다르다. 물론 다음과 같이 for 반복문에 넣어서 사용할 수도 있다.import randomfor i in iter(lambda : random.randint(0, 5), 2):     print(i, end=' ')3 1 4 0 5 3 3 5 0 4 1 이렇게 iter 함수를 활용하면 if 조건문으로 매번 숫자가 2인지 검사하지 않아도 되므로 코드가 좀 더 간단해진다. 즉, 다음 코드와 동작이 같다.import random while True:    i = random.randint(0, 5)    if i == 2:        break    print(i, end=' ')nextnext는 기본값을 지정할 수 있다. 기본값을 지정하면 반복이 끝나더라도 StopIteration이 발생하지 않고 기본값을 출력한다. 즉, 반복할 수 있을 때는 해당 값을 출력하고, 반복이 끝났을 때는 기본값을 출력한다. 다음은 range(3)으로 0, 1, 2세번 반복하는데 next에 기본값을 10으로 지정했다.  next(반복가능한객체, 기본값)it = iter(range(3))next(it, 10)0next(it, 10)1next(it, 10)2next(it, 10)10next(it, 10)100, 1, 2까지 나온 뒤에도 next(it, 10)을 호출하면 예외가 발생하지 않고 계속 10이 나온다.지금까지 반복 가능한 객체의 개념과 이터레이터를 만드는 방법을 배웠다. 여기서는 이터레이터를 만들 때 __iter__, __next__ 메서드 또는 __getitem__ 메서드를 구현해야 한다는 점만 기억하면 된다.예제1다음 소스 코드에서 특정 수의 배수를 만드는 이터레이터를 작성하세요. 배수는 0부터 지정된 숫자보다 작을 때까지 만들어야 합니다.class MultipleIterator:    def __init__(self, stop, multiple):        ①                                ...                                      def __iter__(self):        return self     def __next__(self):        ②                                                    ...                                                      for i in MultipleIterator(20, 3):    print(i, end=' ') print()for i in MultipleIterator(30, 5):    print(i, end=' ')#실행 결과3 6 9 12 15 18 5 10 15 20 25 답①  self.stop = stop   self.multiple = multiple   self.current = 0②  self.current += 1   if self.current * self.multiple &lt; self.stop:       return self.current * self.multiple   else:       raise StopIteration반복을 끝낼숫자는 20(stop)이고 배수는3(multiple)이다. 먼저 __init__ 메서드에서 self.stop에 stop을 저장하고, self.multiple에 multiple을 저장한다. 그리고 몇 번 반복했는지를 저장해야 하므로 self.current를 만들고 0을 저장한다.__next__ 메서드에서 배수를 구한다. 배수는 self.current와 self.multiple의 곱을 구하면된다. 단,self.current가 0부터 시작했음으로 0에 self.multiple을 곱하면 0이되기 때문에 self.current += 1을 해 1부터 곱하도록 만든다. 반복을 끝내는 조건은 stop보다 작을떄 반복하고 커지면 중단하게 헤애 하기 때문에 if self.current * self.multiple &lt; self.stop: 이된다.예제2표준 입력으로 정수 세 개가 입력됩니다(첫 번째 정수는 시작하는 초, 두 번째 정수는 반복을 끝낼 초, 세 번째 정수는 인덱스이며 입력되는 초의 범위는 0~100000, 입력되는 인덱스의 범위는 0~10입니다). 다음 소스 코드에서 시간 값을 생성하는 이터레이터를 만드세요.  시간 값은 문자열이고 시:분:초 형식입니다. 만약 숫자가 한 자리일 경우 앞에 0을 붙입니다(예: 12:01:08).  1초는 00:00:01입니다. 23:59:59를 넘길 경우 00:00:00부터 다시 시작해야 합니다.  시간은 반복을 끝낼 초 직전까지만 출력해야 합니다(반복을 끝낼 초는 포함되지 않음).________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________start, stop, index = map(int, input().split()) for i in TimeIterator(start, stop):    print(i) print('\\n', TimeIterator(start, stop)[index], sep='')#입력10 10 20 20 30 30 40 40#결과42.42640687119285#입력100 100 200 200 300 300 400 400#결과424.26406871192853답class TimeIterator:  def __init__(self, start, stop):    self.start = start    self.stop = stop  def __getitem__(self, index):    hour = (self.start + index) // 60 // 60 % 24    min = (self.start + index) // 60 % 60    sec = (self.start + index) % 60    if index &lt; self.stop - self.start:      return '{0:02d}:{1:02d}:{2:02d}'.format(hour, min, sec)    else:      raise IndexError",
        "url": "/python-basic37"
    }
    ,
    
    "python-basic36": {
        "title": "Python - Python 예외 처리 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기예외 처리 사용하기예외(exception)란 코드를 실행하는 중에 발생한 에러를 뜻한다. 다음과 같이 10을 어떤 값으로 나누는 함수 ten_div가 있을 때 인수에 따라 정상으로 동작하기도 하고 에러가 나기도 한다.def ten_div(x):     return 10 / x이 함수에 2를 넣으면 5.0이 나온다.def ten_div(x):     return 10 / xten_div(2)5.0하지만 0을 넣으면 실행하는 중에 에러가 발생한다. 이런 상황을 예외라고 하는데 여기서는 어떤 숫자를 0으로 나누어서 ZeroDivisionError 예외가 발생했다.def ten_div(x):     return 10 / xten_div(0)Traceback (most recent call last):  File \"&lt;pyshell#121&gt;\", line 1, in &lt;module&gt;    ten_div(0)  File \"&lt;pyshell#119&gt;\", line 2, in ten_div    return 10 / xZeroDivisionError: division by zero ZeroDivisionError뿐만 아니라 지금까지 만난 AttributeError, NameError, TypeError 등 다양한 에러들도 모두 예외다.예외가 발생했을 때도 스크립트 실행을 중단하지 않고 계속 실행하게 해주는 예외 처리 방법에 대해 알아보자.1. try except로 사용하기예외 처리를 하려면 다음과 같이 try에 실행할 코드를 넣고 except에 예외가 발생했을 때 처리하는 코드를 넣는다try:    실행할 코드except:    예외가 발생했을 때 처리하는 코드이제 숫자를 0으로 나누었을 때 발생하는 예외를 처리해보자.try:    x = int(input('나눌 숫자를 입력하세요: '))    y = 10 / x    print(y)except:    # 예외가 발생했을 때 실행됨    print('예외가 발생했습니다.')소스 코드를 실행한 뒤 0을 입력하고 엔터를 누르면 eroDivisionError 예외가 발생한다. 여기서는 except에서 예외 처리를 하도록 만들었으므로 ‘예외가 발생했습니다.’가 출력된다.나눌 숫자를 입력하세요: 0 (입력)예외가 발생했습니다.특히 예외가 발생하면 해당 줄에서 코드 실행을 중단하고 바로 except로 가서 코드를 실행한다. 즉, try의 y = 10 / x 를 비롯하여 그 아래줄에 있는 print(y)도 실행되지 않는다.다시 소스 코드를 실행한 뒤 2를 입력하면 예외가 발생하지 않고 계산 결과가 잘 출력된다. 이처럼 try의 코드가 에러 없이 잘 실행 되면 except의 코드는 실행되지 않고 그냥 넘어간다. 즉, try의 코드에서 에러가 발생했을 때만 except의 코드가 실행된다.나눌 숫자를 입력하세요: 2 (입력)5.0특정 예외만 처리하기이번에는 except에 예외 이름을 지정해서 특정 예외가 발생했을 때만 처리 코드를 실행하도록 만들어보겠다.try:    실행할 코드except 예외이름:    예외가 발생했을 때 처리하는 코드다음과 같이 정수 두 개를 입력받아서 하나는 리스트의 인덱스로 사용하고, 하나는 나누는 값으로 사용한다. 그리고 except를 두 개 사용하고 각각 ZeroDivisionError와 IndexError를 지정한다.y = [10, 20, 30] try:    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())    print(y[index] / x)except ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨    print('숫자를 0으로 나눌 수 없습니다.')except IndexError:           # 범위를 벗어난 인덱스에 접근하여 에러가 발생했을 때 실행됨    print('잘못된 인덱스입니다.')소스 코드를 실행한 뒤 2와 0을 입력하고 엔터 키를 눌러 실행한다. 2 0을 입력하면 30 / 0이 되므로 숫자를 0으로 나누게 된다. 이때는 except ZeroDivisionError:의 처리 코드가 실행된다.인덱스와 나눌 숫자를 입력하세요: 2 0 (입력)숫자를 0으로 나눌 수 없습니다.다시 소스 코드를 실행한 뒤 3 5를 입력하고 엔터 키를 누른다. y = [10, 20, 30]은 요소가 3개 들어있는 리스트다. 따라서 인덱스에 3을 지정하면 범위를 벗어나게 된다. 이때는 except IndexError:의 처리 코드가 실행된다.인덱스와 나눌 숫자를 입력하세요: 3 5 (입력)잘못된 인덱스입니다.예외의 에러 메시지 받아오기특히 except에서 as 뒤에 변수를 지정하면 발생한 예외의 에러 메시지를 받아올 수 있다.try:    실행할 코드except 예외 as 변수:    예외가 발생했을 때 처리하는 코드앞에서 만든 코드의 except에 as e를 넣는다. 보통 예외( exception)의 e를 따서 변수 이름을 e로 짓는다. 2 와0, 3 과5처럼 예외가 발생하는 숫자를 넣어보면 해당 예외에 해당하는 에러 메시지가 출력된다. 단, 예외가 여러 개 발생하더라도 먼저 발생한 예외의 처리 코드만 실행됩니다(또는, 예외 중에서 높은 계층의 예외부터 처리. 기반 클래스 &gt; 파생 클래스 순).y = [10, 20, 30] try:    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())    print(y[index] / x)except ZeroDivisionError as e:                    # as 뒤에 변수를 지정하면 에러를 받아옴    print('숫자를 0으로 나눌 수 없습니다.', e)    # e에 저장된 에러 메시지 출력except IndexError as e:    print('잘못된 인덱스입니다.', e)#실행 결과인덱스와 나눌 숫자를 입력하세요: 2 0 (입력)숫자를 0으로 나눌 수 없습니다. division by zero#실행 결과인덱스와 나눌 숫자를 입력하세요: 3 5 (입력)잘못된 인덱스입니다. list index out of range참고로 모든 예외의 에러 메시지를 출력하고 싶다면 다음과 같이 except에 Exception을 지정하고 as 뒤에 변수를 넣으면 된다.except Exception as e:    # 모든 예외의 에러 메시지를 출력할 때는 Exception을 사용    print('예외가 발생했습니다.', e)이처럼 예외 처리는 에러가 발생하더라도 스크립트의 실행을 중단시키지 않고 계속 실행하고자 할 때 사용한다.2.else와 finally 사용하기이번에는 예외가 발생하지 않았을 때 코드를 실행하는 else를 사용해보자. 다음과 같이 else는 except바로 다음에 와야 하며 except를 생략할 수 없다.try:    실행할 코드except:    예외가 발생했을 때 처리하는 코드else:    예외가 발생하지 않았을 때 실행할 코드그럼 10을 입력된 숫자로 나누고 예외가 발생하지 않으면 계산 결과를 출력해보자.try:    x = int(input('나눌 숫자를 입력하세요: '))    y = 10 / xexcept ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨    print('숫자를 0으로 나눌 수 없습니다.')else:                        # try의 코드에서 예외가 발생하지 않았을 때 실행됨    print(y)소스 코드를 실행한 뒤 2를 입력하고 엔터 키를 눌러 실행하면 2를 입력했으므로 y = 10 / x에서 예외가 발생하지 않았다. 따라서 else의 코드가 실행되고 계산 결과가 출력된다.나눌 숫자를 입력하세요: 2 (입력)5.0물론 0을 입력해서 예외가 발생하면 except의 코드만 실행되고 else의 코드는 실행되지 않는다.나눌 숫자를 입력하세요: 0 (입력)숫자를 0으로 나눌 수 없습니다.예외와는 상관없이 항상 코드 실행하기이번에는 예외 발생 여부와 상관없이 항상 코드를 실행하는 finally를 사용해보겠다. 특히 finally는 except와 else를 생략할 수 있다.try:    실행할 코드except:    예외가 발생했을 때 처리하는 코드else:    예외가 발생하지 않았을 때 실행할 코드finally:    예외 발생 여부와 상관없이 항상 실행할 코드다음은 try의 코드가 끝나면 항상 ‘코드 실행이 끝났습니다.’를 출력한다.try:    x = int(input('나눌 숫자를 입력하세요: '))    y = 10 / xexcept ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨    print('숫자를 0으로 나눌 수 없습니다.')else:                        # try의 코드에서 예외가 발생하지 않았을 때 실행됨    print(y)finally:                     # 예외 발생 여부와 상관없이 항상 실행됨    print('코드 실행이 끝났습니다.')소스 코드를 실행한 뒤 2를 입력하고 실행하면 예외가 발생하지 않았으므로 계산 결과가 출력되고, ‘코드 실행이 끝났습니다.’도 출력된다.나눌 숫자를 입력하세요: 2 (입력)5.0코드 실행이 끝났습니다.다시 소스 코드를 실행한 뒤 0을 입력하고 실행하면 숫자를 0으로 나눠서 예외가 발생했지만 finally는 항상 실행되므로 ‘코드 실행이 끝났습니다.’가 출력된다.나눌 숫자를 입력하세요: 0 (입력)숫자를 0으로 나눌 수 없습니다.코드 실행이 끝났습니다.3.예외 발생시키기위에서 숫자를 0으로 나눴을때 에러, 리스트의 범위를 벗어난 인덱스에 접근했을 때 에러 등 파이썬에서 정해진 예외만 처리했다. 이번에는 직접 예외를 발생시켜 보자.예외를 발생시킬 때는 raise에 예외를 지정하고 에러 메시지를 넣는다(에러 메시지는 생략 할 수 있음).  raise 예외(‘에러메시지’)그럼 3의 배수를 입력받은 뒤 숫자가 3의 배수가 아니면 예외를 발생시켜보자.try:    x = int(input('3의 배수를 입력하세요: '))    if x % 3 != 0:                                 # x가 3의 배수가 아니면        raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴    print(x)except Exception as e:                             # 예외가 발생했을 때 실행됨    print('예외가 발생했습니다.', e)소스 코드를 실행하고 5를 입력한뒤 실행하면 5는 3의 배수가 아니므로 raise Exception(‘3의 배수가 아닙니다.’)로 예외를 발생시켰다. 이때 Exception에 넣은 에러 메시지는 except Exception as e:의 e에 들어가게된다. 그리고 raise로 예외를 발생시키면 raise 아래에 있는 코드는 실행되지 않고 바로 except로 넘어간다. 따라서 try의 print(x)는 실행되지 않는다.3의 배수를 입력하세요: 5 (입력)예외가 발생했습니다. 3의 배수가 아닙니다.참고로 이 예제에서는 예외로 Exception을 사용했는데 RuntimeError, NotImplementedError 등 다른 예외를 사용해도 상관없다.raise의 처리 과정raise의 처리 과정을 알아보자. 다음은 함수 안에서 raise를 사용하지만 함수 안에서는 try except가 없는 상환이다.def three_multiple():    x = int(input('3의 배수를 입력하세요: '))    if x % 3 != 0:                                 # x가 3의 배수가 아니면        raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴    print(x)                                       # 현재 함수 안에는 except가 없으므로                                                   # 예외를 상위 코드 블록으로 넘김 try:    three_multiple()except Exception as e:                             # 하위 코드 블록에서 예외가 발생해도 실행됨    print('예외가 발생했습니다.', e)소스 코드를 실행한 뒤 5를 입력하고 실행하면 three_multiple 함수는 안에 try except가 없는 상태에서 raise로 예외를 발생시키게 되어 함수 바깥에 있는 except에서 예외가 처리가 된다. 즉, 예외가 발생하더라도 현재 코드 블록에서 처리해줄 except가 없다면 except가 나올 때까지 계속 상위 코드 블록으로 올라간다.3의 배수를 입력하세요: 5 (입력)예외가 발생했습니다. 3의 배수가 아닙니다.만약 함수 바깥에도 처리해줄 except가 없다면 코드 실행은 중지되고 에러가 표시된다. 다음은 파이썬 셸에서 직접 three_multiple 함수를 호출했으므로 except가 없는 상태다.\\three_multiple()3의 배수를 입력하세요: 5 (입력)Traceback (most recent call last):  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;    three_multiple()  File \"C:\\project\\try_except_function_raise.py\", line 4, in three_multiple    raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴Exception: 3의 배수가 아닙니다.현재 예외를 다시 발생시키기try except에서 처리한 예외를 다시 발생시키는 방법이다. except 안에서 raise를 사용하면 현재 예외를 다시 발생시킨다(re-raise).  raise다음은 three_multiple 코드 블록의 예외를 다시 발생시킨 뒤 상위 코드 블록에서 예외를 처리한다.def three_multiple():    try:        x = int(input('3의 배수를 입력하세요: '))        if x % 3 != 0:                                 # x가 3의 배수가 아니면            raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴        print(x)    except Exception as e:                             # 함수 안에서 예외를 처리함        print('three_multiple 함수에서 예외가 발생했습니다.', e)        raise    # raise로 현재 예외를 다시 발생시켜서 상위 코드 블록으로 넘김 try:    three_multiple()except Exception as e:             1             # 하위 코드 블록에서 예외가 발생해도 실행됨    print('스크립트 파일에서 예외가 발생했습니다.', e)소스 코드를 실행한 뒤 5를 입력하고 실행하면 three_multiple 함수 안에서 발생한 예외를 함수 안의 except에서 한 번 처리하고, raise로 예외를 다시 발생시켜서 상위 코드 블록으로 넘겼다. 그다음에 함수 바깥의 except에서 예외를 처리했다. 이런 방식으로 같은 예외를 계속 처리해줄 수 있다.        if x % 3 != 0:            raise Exception('3의 배수가 아닙니다.')        print(x)    except Exception as e:        print('three_multiple 함수에서 예외가 발생했습니다.', e)        raise RuntimeError('three_multiple 함수에서 예외가 발생했습니다.')참고로 raise만 사용하면 같은 예외를 상위 코드 블록으로 넘기지만 raise에 다른 예외를 지정하고 에러 메시지를 넣을 수도 있다.  raise 예외(‘에러메시지’)        if x % 3 != 0:            raise Exception('3의 배수가 아닙니다.')        print(x)    except Exception as e:        print('three_multiple 함수에서 예외가 발생했습니다.', e)        raise RuntimeError('three_multiple 함수에서 예외가 발생했습니다.')assert로 예외 발생시키기발생시키는 방법 중에는 assert를 사용하는 방법도 있다. assert는 지정된 조건식이 거짓일 때 AssertionError 예외를 발생시키며 조건식이 참이면 그냥 넘어간다. 보통 assert는 나와서는 안 되는 조건을 검사할 때 사용한다.다음은 3의 배수가 아니면 예외 발생, 3의 배수이면 그냥 넘어가게 된다.  assert 조건식  assert 조건식, 에러메시지x = int(input('3의 배수를 입력하세요: '))assert x % 3 == 0, '3의 배수가 아닙니다.'    # 3의 배수가 아니면 예외 발생, 3의 배수이면 그냥 넘어감print(x)3의 배수를 입력하세요: 5 (입력)Traceback (most recent call last):  File \"C:\\project\\assertion.py\", line 2, in &lt;module&gt;    assert x % 3 == 0, '3의 배수가 아닙니다.'AssertionError: 3의 배수가 아닙니다.4.예외 만들기지금까지 파이썬에 내장된 예외를 처리했는데, 이번에는 예외를 직접 만들어서 발생시켜보자. 프로그래머가 직접 만든 예외를 사용자 정의 예외라고 한다.예외를 만드는 방법은 간단하다. 그냥 Exception을 상속받아서 새로운 클래스를 만들면 된다. 그리고 __init__ 메서드에서 기반 클래스의 __init__ 메서드를 호출하면서 에러 메시지를 넣어주면 된다.class 예외이름(Exception):    def __init__(self):        super().__init__('에러메시지')그럼 입력된 숫자가 3의 배수가 아닐 때 발생시킬 예외를 만들어보자.class NotThreeMultipleError(Exception):    # Exception을 상속받아서 새로운 예외를 만듦    def __init__(self):        super().__init__('3의 배수가 아닙니다.') def three_multiple():    try:        x = int(input('3의 배수를 입력하세요: '))        if x % 3 != 0:                     # x가 3의 배수가 아니면            raise NotThreeMultipleError    # NotThreeMultipleError 예외를 발생시킴        print(x)    except Exception as e:        print('예외가 발생했습니다.', e) three_multiple()5를 입력하면 3의 배수가 아니므로 NotThreeMultipleError 예외가 발생한다.3의 배수를 입력하세요: 5 (입력)예외가 발생했습니다. 3의 배수가 아닙니다.먼저 Exception을 상속받아서 NotThreeMultipleError 예외를 만들었다. 그리고 __init__ 메서드 안에서 기반 클래스의 __init__ 메서드를 호출하면서 에러 메시지를 넣었다.class NotThreeMultipleError(Exception):    # Exception을 상속받아서 새로운 예외를 만듦    def __init__(self):        super().__init__('3의 배수가 아닙니다.')예외를 발생시킬 때는 raise NotThreeMultipleError와 같이 raise에 새로 만든 예외를 지정해주면 된다.참고로 다음과 같이 Exception만 상속받고 pass를 넣어서 아무것도 구현하지 않아도 된다.class NotThreeMultipleError(Exception):    # Exception만 상속받고    pass                                   # 아무것도 구현하지 않음이때는 예외를 발생시킬 때 에러 메시지를 넣어주면 됩니다.raise NotThreeMultipleError('3의 배수가 아닙니다.')    # 예외를 발생시킬 때 에러 메시지를 넣음지금까지 예외 처리에 대해 배웠다. 예외 처리는 에러가 발생하더라도 스크립트의 실행을 중단하지 않고 계속 실행하고자 할 때 사용한다는 점 꼭 기억하자.예제1다음 소스 코드를 완성하여 maria.txt 파일이 있으면 파일의 내용을 읽어서 출력하고, 파일이 없으면 ‘파일이 없습니다.’를 출력하도록 만드세요. 파일이 없을 때 발생하는 예외는 FileNotFoundError입니다.①         file = open('maria.txt', 'r')②                              print('파일이 없습니다.')③         s = file.read()    file.close()답① try:② except FileNotFoundError:③ else:예제2표준 입력으로 문자열이 입력됩니다. 다음 소스 코드를 완성하여 입력된 문자열이 회문이면 문자열을 그대로 출력하고, 회문이 아니면 ‘회문이 아닙니다.’를 출력하도록 만드세요. palindrome 함수와 NotPalindromeError 예외를 작성해야 합니다.________________________________________________________________________________________________________________try:    word = input()    palindrome(word)except NotPalindromeError as e:    print(e)#입력level#결과level#입력hello#결과회문이 아닙니다.내가 쓴 답class NotPalindromeError(Exception):    def __init__(self):        super().__init__('회문이 아닙니다.')        def palindrome(word):    if word != word[::-1]:        raise NotPalindromeError    print(word)",
        "url": "/python-basic36"
    }
    ,
    
    "python-basic35": {
        "title": "Python - Python 두 점 사이의 거리 구하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기두 점 사이의 거리 구하기클래스를 활용하여 2차원 평면에서 위치를 표현한 뒤 두 점 사이의 거리를 구해보자.1. 두 점 사이의 거리 구하기두 점 사이의 거리를 구하기 전에 먼저 클래스로 점을 구현해보자.클래스로 점 구현하기2차원 평면에서 위치를 표현하려면 x와 y값이 필요하다. 다음과 같이 Point2D 클래스를 구현하고 x와 y를 속성으로 넣었다.class Point2D:    def __init__(self, x, y):        self.x = x        self.y = y이제 Point2D 클래스로 점 두 개를 만든다.class Point2D:    def __init__(self, x, y):        self.x = x        self.y = y p1 = Point2D(x=30, y=20)    # 점1p2 = Point2D(x=60, y=50)    # 점2 print('p1: {} {}'.format(p1.x, p1.y))    # 30 20print('p2: {} {}'.format(p2.x, p2.y))    # 60 50#실행 결과p1: 30 20p2: 60 50피타고라스의 정리로 두 점의 거리 구하기여기서 두 점의 거리를 구하려면 어떻게 해야 할까요? 학교에서 배운 피타고라스의 정리를 이용하면 된다.  임의의 직각삼각형에서 빗변을 한 변으로 하는 정사각형의 넓이는 다른 두 변을 각각 한 변으로 하는 정사각형의 넓이의 합과 같다.  a2(제곱) + b2(제곱) = c2(제곱)피타고라스의 정리에 대입하려면 먼저 선 a와 b의 길이를 구해야 한다. 우리는 Point2D 클래스의 인스턴스에 두 점의 좌표 정보가 들어있으므로 인스턴스(변수)를 활용하면 된다a = p2.x - p1.x    # 선 a의 길이b = p2.y - p1.y    # 선 b의 길이a는 p2의 x에서 p1의 x를 빼면 되고, b는 p2의 y에서 p1의 y를 빼면 된다.그다음에 피타고라스의 정리에서 c의 길이를 계산하려면 제곱근을 구해야 한다.그럼 √(루트)는 를 구현해야한다. 이때는 math 모듈의 sqrt 함수를 사용하면 편리하다. sqrt는 제곱근을 뜻하는 square root에서 따왔다.  math.sqrt(값)n  제곱근을 반환, 값이 음수이면 에러 발생이제 sqrt 함수까지 사용해서 p1과 p2의 거리를 구해보자.import math class Point2D:    def __init__(self, x, y):        self.x = x        self.y = y p1 = Point2D(x=30, y=20)    # 점1p2 = Point2D(x=60, y=50)    # 점2 a = p2.x - p1.x    # 선 a의 길이b = p2.y - p1.y    # 선 b의 길이 c = math.sqrt((a * a) + (b * b))    # (a * a) + (b * b)의 제곱근을 구함print(c)    # 42.42640687119285#실행 결과42.42640687119285이처럼 sqrt 함수에 값을 넣으면 해당 값의 제곱근을 구해준다. 여기서는 a의 제곱과 b의 제곱의 합을 (a * a) + (b * b)처럼 표현했는데 거듭제곱(power)을 구하는 pow 함수를 사용해도 된다.(math 모듈).  math.pow(값, 지수)n  값을 지수만큼 거듭제곱한 값을 반환즉, a2를 구하고 싶다면 pow(a, 2)처럼 사용한다. 앞에서 작성한 코드를 pow 함수로 다시 작성하면 다음과 같은 모양이 된다.c = math.sqrt(math.pow(a, 2) + math.pow(b, 2))물론 파이썬의 거듭제곱 연산자 **를 사용해도 됩니다.c = math.sqrt((a ** 2) + (b ** 2))만약 선의 위치를 구할 때 p2에서 p1을 빼는 것이 아닌 p1에서 p2를 빼도 상관없다. 30 - 60은 -30이고 20 - 50도 -30이다. 하지만 a2 + b2 = c2 식에서 a와 b는 같은 값을 두 번 곱하는데 음수(-)끼리 곱하면 항상 양수(+)가 되므로 부호는 상관하지 않아도 된다. 즉, 양수(+) * 양수(+) 또는 음수(-) * 음수(-) 상황밖에 없기 때문이다.a = p1.x - p2.x    # 선 a의 길이b = p1.y - p2.y    # 선 b의 길이절댓값 함수내장 함수 abs 또는 math 모듈의 fabs 함수를 사용하면 양수 또는 음수를 절댓값(absolute value)으로 만들 수 있다.  abs(값)정수는 절댓값을 정수로 반환, 실수는 절댓값을 실수로 반환  math.fabs(값)절댓값을 실수로 반환절댓값 함수파이썬에서는 각 요소에 이름을 지정해 줄 수 있는 튜플인 namedtuple을 제공한다( collections 모듈). namedtuple은 자료형 이름과 요소의 이름을 지정하면 클래스를 생성해준다. 여기서 자료형 이름은 문자열, 요소의 이름은 문자열 리스트로 넣어준다.  클래스 = collections.namedtuple(‘자료형이름’, [‘요소이름1’, ‘요소이름2’])namedtuple로 생성한 클래스는 값을 넣어서 인스턴스를 만들 수 있으며 인스턴스.요소이름 또는 인스턴스[인덱스] 형식으로 요소에 접근할 수 있다.      인스턴스 = 클래스(값1, 값2)        인스턴스 = 클래스(요소이름1=값1, 요소이름2=값2)        인스턴스.요소이름1        인스턴스[인덱스]  다음은 namedtuple을 사용하여 점을 표현한 뒤 두 점의 거리를 구한다.import mathimport collections Point2D = collections.namedtuple('Point2D', ['x', 'y'])    # namedtuple로 점 표현 p1 = Point2D(x=30, y=20)    # 점1p2 = Point2D(x=60, y=50)    # 점2 a = p1.x - p2.x    # 선 a의 길이b = p1.y - p2.y    # 선 b의 길이 c = math.sqrt((a * a) + (b * b))print(c)    # 42.42640687119285예제1다음 소스 코드를 완성하여 사각형의 넓이가 출력되게 만드세요.class Rectangle:    def __init__(self, x1, y1, x2, y2):        self.x1 = x1        self.y1 = y1        self.x2 = x2        self.y2 = y2 rect = Rectangle(x1=20, y1=20, x2=40, y2=30) ①                              ②                              ③                              print(area)# 실행 결과200답① width = abs(rect.x2 - rect.x1)② height = abs(rect.y2 - rect.y1)③ area = width * height예제2표준 입력으로 x, y 좌표 4개가 입력되어 Point2D 클래스의 인스턴스 리스트에 저장됩니다. 여기서 점 4개는 첫 번째 점부터 마지막 점까지 순서대로 이어져 있습니다. 다음 소스 코드를 완성하여 첫 번째 점부터 마지막 점까지 연결된 선의 길이가 출력되게 만드세요import math class Point2D:    def __init__(self, x=0, y=0):        self.x = x        self.y = y length = 0.0p = [Point2D(), Point2D(), Point2D(), Point2D()]p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y = map(int, input().split())________________________________________________________________print(length)#입력10 10 20 20 30 30 40 40#결과42.42640687119285#입력100 100 200 200 300 300 400 400#결과424.26406871192853내가 쓴 답for i in range(len(p)-1):    a = p[i + 1].x - p[i].x    b = p[i + 1].y - p[i].y    length += math.sqrt(math.pow(a, 2) + math.pow(b, 2))",
        "url": "/python-basic35"
    }
    ,
    
    "python-basic34": {
        "title": "Python - Python 클래스 상속 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기클래스 상속 사용하기지금까지 클래스의 기본적인 사용 방법을 알아보았다. 이번에는 클래스 상속(inheritance)을 사용해보자.상속은 무언가를 물려 받는다는 뜻이다. 클래스 상속은 물려받은 기능을 유지한채로 다른 기능을 추가할 때 사용한다. 여기서 기능을 물려주는  클래스를 기반 클래스(base class), 상속을 받아 새롭게 만드는 클래스를 파생 클래스(derived class)라고 한다.보통 기반 클래스는 부모클래스(parent class), 슈퍼 클래스(super class)라고 부르고, 파생 클래스는 자식 클래스(child class), 서브 클래스(subclass)라고도 부른다.새로운 기능이 필효할때 계속 클래스를 만든다면 중복되는 부분을 반복해서 만들어야 한다. 이럴 때 상속을 사용하면 중복되는 기능을 만들지 않아도 된다. 따라서 상속은 기존 기능을 재사용할 수 있어서 효율적이다.1. 사람 클래스로 학생 클래스 만들기클래스 상속은 다음과 같이 클래스를 만들 때()괄호 를 붙이고 안에 기반 클래스 이름을 넣는다.class 기반클래스이름:    코드 class 파생클래스이름(기반클래스이름):    코드그럼 간단하게 사람 클래스를 만들고 사람 클래스를 상속받아 학생 클래스를 만들어보자.student클래스를 만들 때 class student(Person):과 같이 ()괄호 안에 기반 클래스인 person클래스를 넣었다. 이렇게 하면 person클래스의 기능을 불려받은 Student클래스가 된다. Student 클래스에는 greeting 메서드가 없지만 Person 클래스를 상속받았으므로 greeting 메서드를 호출할 수 있다.class Person:    def greeting(self):        print('안녕하세요.') class Student(Person):    def study(self):        print('공부하기') james = Student()james.greeting()    # 안녕하세요.: 기반 클래스 Person의 메서드 호출james.study()       # 공부하기: 파생 클래스 Student에 추가한 study 메서드#실행 결과안녕하세요.공부하기이처럼 클래스 상속은 기반 클래스의 기능을 유지하면서 새로운 기능을 추가할 수 있다. 특히 클래스 상속은 연관되면서 동등한 기능일 때 사용한다. 즉, 학생은 사람이므로 연관된 개념이고, 학생은 사람에서 역할만 확장되었을 뿐 동등한 개념이다.상속 관계 확인하기클래스의 상속 관계를 확인하고 싶을 때는 issubclass 함수를 사용한다. 즉, 클래스가 기반 클래스의 파생 클래스인지 확인한다. 기반 클래스의 파생 클래스가 맞으면 True, 아니면 False를 반환한다.  issubclass(파생클래스, 기반클래스)Student가 Person의 파생 클래스이므로 issubclass는 True가 나오게된다.class Person:     passclass Student(Person):     passissubclass(Student, Person)True2. 상속 관계와 포함 관계 알아보기클래스 상속을 어디에 사용하는지 알아보자.상속 관계위에서 만든 Student 클래스는 Person 클래스를 상속받아서 만들었다. 여기서 학생 Student는 사람 Person이므로 같은 종류다. 이처럼 상속은 명확하게 같은 종류이며 동등한 관계일 때 사용한다. 즉, “학생은 사람이다.”라고 했을 때 말이 되면 동등한 관계다. 그래서 상속 관계를 영어로 is-a 관계라고 부른다(Student is a Person).class Person:    def greeting(self):        print('안녕하세요.') class Student(Person):    def study(self):        print('공부하기')포함 관계하지만 학생 클래스가 아니라 사람 목록을 관리하는 클래스를 만든다면 어떻게 할까? 다음과 같이 리스트 속성에 Person인스턴스를 넣어서 관리하면 된다.여기서는 상속을 사용하지 않고 속성에 인스턴스를 넣어서 관리하므로 PersonList가 Person을 포함하고 있다. 이러면 사람 목록 PersonList와 사람 Person은 동등한 관계가 아니라 포함 관계다. 즉, “사람 목록은 사람을 가지고 있다.”라고 말할 수 있다. 그래서 포함 관계를 영어로 has-a 관계라고 부른다(PersonList has a Person).정리하자면 같은 종류에 동등한 관계일 때는 상속을 사용하고, 그 이외에는 속성에 인스턴스를 넣는 포함 방식을 사용하면 되겠다.class Person:    def greeting(self):        print('안녕하세요.') class PersonList:    def __init__(self):        self.person_list = []    # 리스트 속성에 Person 인스턴스를 넣어서 관리     def append_person(self, person):    # 리스트 속성에 Person 인스턴스를 추가하는 함수        self.person_list.append(person)3. 기반 클래스의 속성 사용하기기반 클래스에 들어있는 인스턴스 속성을 사용해보자. 다음과 같이 Person 클래스에 hello속성이 있고, Person클래스를 상속받아 Student 클래스를 만든다. 그다음에 Student로 인스턴스를 만들고 hello 속성에 접근해본다.실행해보면 에러가 발생한다. 왜냐하면 기반 클래스 Person의 __init__ 메서드가 호출되지 않았기 때문이다. 실행 결과를 잘 보면 ‘Student __init__‘만 출력되었다. 즉, Person의 __init__ 메서드가 호출되지 않으면 self.hello = ‘안녕하세요.’도 실행되지 않아서 속성이 만들어지지 않는다.class Person:    def __init__(self):        print('Person __init__')        self.hello = '안녕하세요.' class Student(Person):    def __init__(self):        print('Student __init__')        self.school = '파이썬 코딩 도장' james = Student()print(james.school)print(james.hello)    # 기반 클래스의 속성을 출력하려고 하면 에러가 발생함Student __init__파이썬 코딩 도장Traceback (most recent call last):  File \"C:\\project\\class_inheritance_attribute_error.py\", line 14, in &lt;module&gt;    print(james.hello)AttributeError: 'Student' object has no attribute 'hello' super()로 기반 클래스 초기화하기이때는 super()를 사용해서 기반 클래스의 init 메서드를 호출해준다. 다음과 같이 super() 뒤에 .(점)을 붙여서 메서드를 호출하는 방식이다.  super().메서드()실행을 해보면 기반 클래스 Person의 속성인 hello가 잘 출력된다. super().__init__()와 같이 기반 클래스 Person의 __init__ 메서드를 호출해주면 기반 클래스가 초기화되어서 속성이 만들어진다. 실행 결과를 보면 ‘Student __init__‘과 ‘Person __init__‘이 모두 출력되었다.class Person:    def __init__(self):        print('Person __init__')        self.hello = '안녕하세요.' class Student(Person):    def __init__(self):        print('Student __init__')        super().__init__()                # super()로 기반 클래스의 __init__ 메서드 호출        self.school = '파이썬 코딩 도장' james = Student()print(james.school)print(james.hello)기반 클래스를 초기화하지 않아도 되는 경우만약 파생클래스에서 __init__ 메서드를 생략한다면 기반 클래스의 __init__이 자동으로 호출되므로 super()는 사용하지 않아도 된다. 이처럼 파생 클래스에 __init__ 메서드가 없다면 기반 클래스의 __init__이 자동으로 호출되므로 기반 클래스의 속성을 사용할 수 있다.class Person:    def __init__(self):        print('Person __init__')        self.hello = '안녕하세요.' class Student(Person):    pass james = Student()print(james.hello)#실행 결과Person __init__안녕하세요.좀 더 명확하게 super 사용하기super는 다음과 같이 파생 클래스와 self를 넣어서 현재 클래스가 어떤 클래스인지 명확하게 표시하는 방법도 있다. 물론 super()와 기능은 같다.  super(파생클래스, self).메서드~~~pythonclass Student(Person):    def init(self):        print(‘Student init’)        super(Student, self).init()     # super(파생클래스, self)로 기반 클래스의 메서드 호출        self.school = ‘파이썬 코딩 도장’---## 4. 메서드 오버라이딩 사용하기&lt;br&gt;&lt;br&gt;이번에는 파생 클래스에서 기반 클래스의 메서드를 새로 정의하는 메서드 오버라이딩에 대해 알아보자. 다음과 같이 Person의 greeting메서드가 있는 상태에서 Student에도 greeting 메서드를 만든다. james.greeting()처럼 Student의 greeting 메서드를 호출하니 '안녕하세요. 저는 학생입니다.'가 출력되었다. ~~~pythonclass Person:    def greeting(self):        print('안녕하세요.') class Student(Person):    def greeting(self):        print('안녕하세요. 저는 학생입니다.') james = Student()james.greeting()#실행 결과안녕하세요. 저는 학생입니다.오버라이딩(overriding)은 무시하다, 우선하다라는 뜻을 가지고 있는데 말 그대로 기반 클래스의 메서드를 무시하고 새로운 메서드를 만든다는 뜻이다. 여기서는 Person 클래스의 greeting 메서드를 무시하고 Student 클래스에서 새로운 greeting 메서드를 만들었다.오버라이딩은 프로그램에서 어떤 기능이 같은 메서드 이름으로 계속 사용되어야 할 때 메서드 오버라이딩을 활용한다. 만약 Student클래스에서 인사하는 메서드를 greeting2로 만들어야 한다면 모든 소스 코드에서 메서드 호출 부분을 greeting2로 수정해야한다.다시 Person 클래스의 greeting 메서드와 Student 클래스의 greeting 메서드를 보면 ‘안녕하세요.’라는 문구가 중복된다.    def greeting(self):        print('안녕하세요.')    def greeting(self):        print('안녕하세요. 저는 학생입니다.')이럴 때는 기반 클래스의 메서드를 재활용하면 중복을 줄일 수 있다. 다음과 같이 오버라이딩된 메서드에서 super()로 기반 클래스의 메서드를 호출해보자.class Person:    def greeting(self):        print('안녕하세요.') class Student(Person):    def greeting(self):        super().greeting()    # 기반 클래스의 메서드 호출하여 중복을 줄임        print('저는 학생입니다.') james = Student()james.greeting()#실행 결과안녕하세요.저는 학생입니다.Student의 greeting에서 super().greeting()으로 Person의 greeting을 호출했다. 즉, 중복되는 기능은 파생 클래스에서 다시 만들지 않고, 기반 클래스의 기능을 사용하면 된다.이처럼 메서드 오버라이딩은 원래 기능을 유지하면서 새로운 기능을 덧붙일 때 사용한다.5.다중 상속 사용하기다중 상속은 여러 기반 클래스로부터 상속을 받아서 파생 클래스를 만드는 방법이다. 다음과 같이 클래스를 만들 때 ( )(괄호) 안에 클래스 이름을 ,(콤마)로 구분해서 넣는다.class 기반클래스이름1:    코드 class 기반클래스이름2:    코드 class 파생클래스이름(기반클래스이름1, 기반클래스이름2):    코드그럼 사람 클래스와 대학교 클래스를 만든 뒤 다중 상속으로 대학생 클래스를 만들어보자.class Person:    def greeting(self):        print('안녕하세요.') class University:    def manage_credit(self):        print('학점 관리') class Undergraduate(Person, University):    def study(self):        print('공부하기') james = Undergraduate()james.greeting()         # 안녕하세요.: 기반 클래스 Person의 메서드 호출james.manage_credit()    # 학점 관리: 기반 클래스 University의 메서드 호출james.study()            # 공부하기: 파생 클래스 Undergraduate에 추가한 study 메서드#실행 결과안녕하세요.학점 관리공부하기먼저 기반 클래스 Person과 University를 만들었다. 그다음에 파생 클래스 Undergraduate를 만들 때 class Undergraduate(Person, University):와 같이 괄호 안에 Person과 University를 콤마로 구분해서 넣었다. 이렇게 하면 두 기반 클래스의 기능을 모두 상속받을 수 있다.다이아몬드 상속다이아몬드 상속에 대해 알아보자. 여기서는 편의상 클래스 이름을 A, B, C, D로 만들었다. 클래스 간의 관계가 다이아몬드 같이 생겼다 그래서 객체지향 프로그래밍에서는 이런 상속 관계를 다이아몬드 상속이라 부른다.class A:    def greeting(self):        print('안녕하세요. A입니다.') class B(A):    def greeting(self):        print('안녕하세요. B입니다.') class C(A):    def greeting(self):        print('안녕하세요. C입니다.') class D(B, C):    pass x = D()x.greeting()    # 안녕하세요. B입니다.#실행 결과안녕하세요. B입니다.기반 클래스 A가 있고, B, C는 A를 상속받는다. 그리고 다시 D는 B, C를 상속받는다. 이 관계를 그림으로 나타내면 다음과 같은 모양이 된다.여기서는 클래스 A를 상속받아서 B, C를 만들고, 클래스 B와 C를 상속받아서 D를 만들었다. 그리고 A, B, C 모두 greeting이라는 같은 메서드를 가지고 있다면 D는 어떤 클래스의 메서드를 호출해야 할지 조금 애매하다. 프로그래밍에서는 이렇게 명확하지 않고 애매한 상태를 좋아하지 않는다. 프로그램이 어떨 때는 A의 메서드를 호출하고, 또 어떨 때는 B 또는 C의 메서드를 호출한다면 큰 문제가 생긴다. 그래서 다이아몬드 상속은 문제가 많다고 해서 죽음의 다이아몬드라고도 부른다.메서드 탐색 순서 확인하기많은 프로그래밍 언어들이 다이아몬드 상속에 대한 해결책을 제시하고 있는데 파이썬에서는 메서드 탐색 순서(Method Resolution Order, MRO)를 따른다. 다음과 같이 클래스 D에 메서드 mro를 사용해보면 메서드 탐색 순서가 나온다(클래스.mro 형식도 같은 내용)  클래스.mro()~~~pythonD.mro()[&lt;class ‘main.D’&gt;, &lt;class ‘main.B’&gt;, &lt;class ‘main.C’&gt;, &lt;class ‘main.A’&gt;, &lt;class ‘object’&gt;]MRO에 따르면 D의 메서드 호출 순서는 자기 자신 D, 그 다음이 B다. 따라서 D로 인스턴스를 만들고 greeting을 호출하면 B의 greeting이 호출된다( D는 greeting 메서드가 없으므로).~~~pythonx = D()x.greeting()    # 안녕하세요. B입니다.파이썬은 다중 상속을 한다면 class D(B, C):의 클래스 목록 중 왼쪽에서 오른쪽 순서로 메서드를 찾는다. 그러므로 같은 메서드가 있다면 B가 우선한다. 만약 상속 관계가 복잡하게 얽혀 있다면 MRO를 살펴보는 것이 편리하다.object 클래스파이썬에서 object는 모든 클래스의 조상이다. 그래서 int의 MRO를 출력해보면 int 자기 자신과 object가 출력된다.&gt;&gt;&gt; int.mro()[&lt;class 'int'&gt;, &lt;class 'object'&gt;]파이썬 3에서 모든 클래스는 object 클래스를 상속받으므로 기본적으로 object를 생략한다. 다음과 같이 클래스를 정의한다면class X:    pass괄호 안에 object를 넣은 것과 같다.class X(object):    pass    파이썬 3에서는 괄호 안에 object를 넣어도 되고 넣지 않아도 된다.6.추상 클래스 사용하기파이썬은 추상 클래스(abstract class)라는 기능을 제공한다. 추상 클래스는 메서드의 목록만 가진 클래스이며 상속받는 클래스에서 메서드 구현을 강제하기 위해 사용된다.먼저 추상 클래스를 만들려면 import로 abc 모듈을 가져와야 한다( abc는 abstract base class의 약자입니다). 그리고 클래스의 ( )(괄호) 안에 metaclass=ABCMeta를 지정하고, 메서드를 만들 때 위에 @abstractmethod를 붙여서 추상 메서드로 지정한다.여기서는 from abc import *로 abc 모듈의 모든 클래스와 메서드를 가져왔다. 만약 import abc로 모듈을 가져왔다면 abc.ABCMeta, @abc.abstractmethod로 사용해야 한다.from abc import * class 추상클래스이름(metaclass=ABCMeta):    @abstractmethod    def 메서드이름(self):        코드import abcclass 클래스이름(metaclass=abc.ABCMeta):그럼 학생 추상 클래스 StudentBase를 만들고, 이 추상 클래스를 상속받아 학생 클래스 Student를 만들어보자.from abc import * class StudentBase(metaclass=ABCMeta):    @abstractmethod    def study(self):        pass     @abstractmethod    def go_to_school(self):        pass class Student(StudentBase):    def study(self):        print('공부하기') james = Student()james.study()#실행 결과Traceback (most recent call last):  File \"C:\\project\\class_abc_error.py\", line 16, in &lt;module&gt;    james = Student()TypeError: Can't instantiate abstract class Student with abstract methods go_to_school 실행을 해보면 에러가 발생한다. 왜냐하면 추상 클래스 StudentBase에서는 추상 메서드로 study와 go_to_school을 정의했다. 하지만 StudentBase를 상속받은 Student에서는 study 메서드만 구현하고, go_to_school 메서드는 구현하지 않았으므로 에러가 발생한다.따라서 추상 클래스를 상속받았다면 @abstractmethod가 붙은 추상 메서드를 모두 구현해야 한다. 다음과 같이 Student에서 go_to_school 메서드도 구현해준다.from abc import * class StudentBase(metaclass=ABCMeta):    @abstractmethod    def study(self):        pass     @abstractmethod    def go_to_school(self):        pass class Student(StudentBase):    def study(self):        print('공부하기')     def go_to_school(self):        print('학교가기') james = Student() # 추상클래스의 추상 매서드를 모두 구현했는지 확인하는 시점james.study()james.go_to_school()#실행 결과공부하기학교가기모든 추상 메서드를 구현하니 실행이 잘 된다.StudentBase는 학생이 반드시 해야 하는 일들을 추상 메서드로 만들었습니다. 그리고 Student에는 추상 클래스 StudentBase의 모든 추상 메서드를 구현하여 학생 클래스를 작성했다. 이처럼 추상 클래스는 파생 클래스가 반드시 구현해야 하는 메서드를 정해줄 수 있다.참고로 추상 클래스의 추상 메서드를 모두 구현했는지 확인하는 시점은 파생 클래스가 인스턴스를 만들 때 이다. 따라서 james = Student()에서 확인한다(구현하지 않았다면 TypeError 발생).추상 메서드를 빈 메서드로 만드는 이유그리고 또 한 가지 중요한 점이 있는데 추상 클래스는 인스턴스로 만들 수가 없다는 점이다. 다음과 같이 추상 클래스 StudentBase로 인스턴스를 만들면 에러가 발생한다.&gt;&gt;&gt; james = StudentBase()Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    james = StudentBase()TypeError: Can't instantiate abstract class StudentBase with abstract methods go_to_school, study그래서 지금까지 추상 메서드를 만들 때 pass만 넣어서 빈 메서드로 만든 것이다. 왜냐하면 추상 클래스는 인스턴스를 만들 수 없으니 추상 메서드도 호출할 일이 없기 때이다.    @abstractmethod    def study(self):        pass    # 추상 메서드는 호출할 일이 없으므로 빈 메서드로 만듦     @abstractmethod    def go_to_school(self):        pass    # 추상 메서드는 호출할 일이 없으므로 빈 메서드로 만듦정리하자면 추상 클래스는 인스턴스로 만들 때는 사용하지 않으며 오로지 상속에만 사용한다. 그리고 파생 클래스에서 반드시 구현해야 할 메서드를 정해 줄 때 사용한다.예제1다음 소스 코드에서 리스트(list)에 replace 메서드를 추가한 AdvancedList 클래스를 작성하세요. AdvancedList는 list를 상속받아서 만들고, replace 메서드는 리스트에서 특정 값으로 된 요소를 찾아서 다른 값으로 바꾸도록 만드세요. ______________                                           ... ______________                                           x = AdvancedList([1, 2, 3, 1, 2, 3, 1, 2, 3])x.replace(1, 100)print(x)# 실행 결과[100, 2, 3, 100, 2, 3, 100, 2, 3]답class AdvancedList(list):     def replace(self, old, new):         while old in self: # self = x리스트 , 리스트에 old에 지정한 숫자가 있는동안 반복            self[self.index(old)] = new #리스트 a라고 가정하면 a[a.index(1)] []대괄호 안에 1의 인덱스위치를 넣어주고 리스트a의 #요소를 new로 바꾸어 준다.예제2다음 소스 코드에서 동물 클래스 Animal과 날개 클래스 Wing을 상속받아 새 클래스 Bird를 작성하여 ‘먹다’, ‘파닥거리다’, ‘날다’, True, True가 각 줄에 출력되게 만드세요.class Animal:    def eat(self):        print('먹다') class Wing:    def flap(self):        print('파닥거리다')________________________________________________________________b = Bird()b.eat()b.flap()b.fly()print(issubclass(Bird, Animal))print(issubclass(Bird, Wing))#결과먹다파닥거리다날다TrueTrue내가 쓴 답class Bird(Animal, Wing):    def fly(self):        print('날다')",
        "url": "/python-basic34"
    }
    ,
    
    "python-basic33": {
        "title": "Python - Python 클래스 속성과 정적, 클래스 메서드 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기클래스 속성과 정적, 클래스 메서드 사용하기클래스에 속해 있는 클래스 속성에 대해 알아보자. 그리고 인스턴스를 만들지 않고 클래스로 호출하는 정적 메서드와 클래스 메서드도 사용해보자.1. 클래스 속성과 인스턴스 속성 알아보기속성에는 클래스 속성과 인스턴스 속성 두 가지 종류가 있다. __init__메서드에서 만들었던 속성은 인스턴스 속성이다.클래스 속성 사용하기클래스 속성을 사용해보자. 클래스 속성은 다음과 같이 클래스에 바로 속성을 만든다.class 클래스이름:    속성 = 값         이제 간단하게 사람 클래스에 클래스 속성으로 가방 속성을 넣고 사용해보자. 다음과 같이 person클래스에 바로 bag을 넣고, put_bag메서드를 만든다. 그리고 인스턴스 두 개를 만든 뒤 각각 put_bag 메서드를 사용한다.결과를 보면 james와 maria 인스턴스를 만들고 각자 put_bag 메서드로 물건을 넣었는데, james.bag과 maria.bag을 출력해보면 넣었던 물건이 합쳐져서 나온다. 즉, 클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다.class Person:    bag = []     def put_bag(self, stuff):        self.bag.append(stuff) james = Person()james.put_bag('책') maria = Person()maria.put_bag('열쇠') print(james.bag)print(maria.bag)#실행 결과['책', '열쇠']['책', '열쇠']put_bag 메서드에서 클래스 속성 bag에 접근할 때 self를 사용했다. 사실 self는 현재 인스턴스를 뜻하므로 클래스 속성을 지칭하기에는 조금 모호하다.class Person:    bag = []     def put_bag(self, stuff):        self.bag.append(stuff)그래서 클래스 속성에 접근할 때는 다음과 같이 클래스 이름으로 접근하면 좀 더 코드가 명확해진다.  클래스.속성class Person:    bag = []     def put_bag(self, stuff):        Person.bag.append(stuff)    # 클래스 이름으로 클래스 속성에 접근Person.bag이라고 하니 클래스 Person에 속한 bag 속성이라는 것을 바로 알 수 있다. 마찬가지로 클래스 바깥에서도 다음과 같이 클래스 이름으로 클래스 속성에 접근하면 된다.print(Person.bag)속성, 메서드 이름을 찾는 순서파이썬에서는 속성, 메서드 이름을 찾을 때 인스턴스, 클래스 순으로 찾는다. 그래서 인스턴스 속성이 없으면 클래스 속성을 찾게 되므로 james.bag, maria.bag도 문제 없이 동작한다. 겉보기에는 인스턴스 속성을 사용하는 것 같지만 실제로는 클래스 속성이다.인스턴스와 클래스에서 __dict__ 속성을 출력해보면 현재 인스턴스와 클래스의 속성을 딕셔너리로 확인할 수 있다.      인스턴스.__dict__        클래스.__dict__  james.__dict__{}Person.__dict__mappingproxy({'__module__': '__main__', 'bag': ['책', '열쇠'], 'put_bag': &lt;function Person.put_bag at 0x028A32B8&gt;, '__dict__': &lt;attribute '__dict__' of 'Person' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Person' objects&gt;, '__doc__': None})인스턴스 속성 사용하기그럼 bag을 여러 인스턴스가 공유하지 않으려면 어떻게 해야할까? 그냥 bag을 인스턴스 속성으로 만들면 된다.class Person:    def __init__(self):        self.bag = []     def put_bag(self, stuff):        self.bag.append(stuff) james = Person()james.put_bag('책') maria = Person()maria.put_bag('열쇠') print(james.bag)print(maria.bag)#실행 결과['책']['열쇠']james.bag과 maria.bag을 출력해보면 각자 넣은 물건만 출력된다. 즉, 인스턴스 속성은 인스턴스별로 독립되어 있으며 서로 영향을 주지 않는다.  클래스 속성: 모든 인스턴스가 공유. 인스턴스 전체가 사용해야 하는 값을 저장할 때 사용  인스턴스 속성: 인스턴스별로 독립되어 있음. 각 인스턴스가 값을 따로 저장해야 할 때 사용비공개 클래스 속성 사용하기클래스 속성도 비공개 속성을 만들 수 있습니다. 클래스 속성을 만들 때 _속성** 과 같이 **_(밑줄 두 개)로 시작하면 비공개 속성이 됩니다. 따라서 클래스 안에서만 접근할 수 있고, 클래스 바깥에서는 접근할 수 없다.class 클래스이름:    __속성 = 값    # 비공개 클래스 속성즉, 클래스에서 공개하고 싶지 않은 속성이 있다면 비공개 클래스를 사용해야 한다. 예를 들어 기사 게임 캐릭터는 아이템을 최대 10개까지만 보유할 수 있다고 하자. 실행을 해보면 클래스 Knight의 비공개 클래스 속성 __item_limit는 클래스 안의 print_item_limit 메서드에서만 접근할 수 있고, 클래스 바깥에서 접근하면 에러가 발생한다. 아이템의 보유 제한이 10개인데, 이 클래스를 사용하는 사람이 마음대로 __item_limit = 1000으로 수정하는 경우를 방지한다.class Knight:    __item_limit = 10    # 비공개 클래스 속성     def print_item_limit(self):        print(Knight.__item_limit)    # 클래스 안에서만 접근할 수 있음  x = Knight()x.print_item_limit()    # 10 print(Knight.__item_limit)    # 클래스 바깥에서는 접근할 수 없음 에러발생#실행 결과10Traceback (most recent call last):  File \"C:\\project\\class_private_class_attribute_error.py \", line 11, in &lt;module&gt;    print(Knight.__item_limit)    # 클래스 바깥에서는 접근할 수 없음AttributeError: type object 'Knight' has no attribute '__item_limit' 클래스와 메서드의 독스트링 사용하기함수와 마찬가지로 클래스와 메서드도 독스트링을 사용할 수 있다. 다음과 같이 클래스와 메서드를 만들 때 :(콜론) 바로 다음 줄에 “”” “”“(큰따옴표 세 개) 또는 ‘’’ ‘’‘(작은따옴표 세 개)로 문자열을 입력하면 된다. 그리고 클래스의 독스트링은 클래스.doc 형식으로 사용하고, 메서드의 독스트링은 클래스.메서드.doc 또는 인스턴스.메서드.doc 형식으로 사용한다.class Person:    '''사람 클래스입니다.'''        def greeting(self):        '''인사 메서드입니다.'''        print('Hello') print(Person.__doc__)             # 사람 클래스입니다.print(Person.greeting.__doc__)    # 인사 메서드입니다. maria = Person()print(maria.greeting.__doc__)     # 인사 메서드입니다.#실행결과print(Person.__doc__)사람 클래스입니다.print(Person.greeting.__doc__)인사 메서드입니다.maria = Person()print(maria.greeting.__doc__)인사 메서드입니다.2. 정적 메서드 사용하기이번엔 인스턴스를 통하지 않고 클래스에서 바로 호출할 수 있는 정적 메서드와 클래스 메서드에 대해 알아보자.먼저 정적 메서드이다. 정적 메서드는 다음과 같이 메서드 위에 @staticmethod를 붙인다. 이때 정적 메서드는 매개변수에 self를 지정하지 않는다.class 클래스이름:    @staticmethod    def 메서드(매개변수1, 매개변수2):        코드@staticmethod처럼 앞에 @이 붙은 것을 데코레이터라고 하며 메서드(함수)에 추가 기능을 구현할 때 사용한다.그럼 간단하게 덧셈과 곱셈을 하는 클래스를 만들어보자.class Calc:    @staticmethod    def add(a, b):        print(a + b)     @staticmethod    def mul(a, b):        print(a * b) Calc.add(10, 20)    # 클래스에서 바로 메서드 호출Calc.mul(10, 20)    # 클래스에서 바로 메서드 호출#실행 결과30200Calc 클래스에서 @staticmethod를 붙여서 add 메서드와 mul 메서드를 만들었다. 정적 메서드를 호출할 때는 다음과 같이 클래스에서 바로 메서드를 호출하면 된다. 정적 메서드는 self를 받지 않으므로 인스턴스 속성에는 접근할 수 없다. 그래서 보통 정적 메서드는 인스턴스 속성, 인스턴스 메서드가 필요 없을 때 사용한다.  클래스.메서드()Calc.add(10, 20)    # 클래스에서 바로 메서드 호출Calc.mul(10, 20)    # 클래스에서 바로 메서드 호여기서 만든 Calc 클래스에 들어있는 add, mul 메서드는 숫자 두개를 받아서 더하거나 곱할 뿐 인스턴스의 속성은 필요하지 않다. 정적 메서드는 메서드의 실행이 외부 상태에 영향을 끼치지 않는 순수 함수(pure function)를 만들 때 사용한다. 순수 함수는 부수 효과(side effect)가 없고 입력 값이 같으면 언제나 같은 출력 값을 반환한다. 즉, 정적 메서드는 인스턴스의 상태를 변화시키지 않는 메서드를 만들 때 사용한다.파이썬 자료형의 인스턴스 메서드와 정적 메서드파이썬의 자료형도 인스턴스 메서드와 정적, 클래스 메서드로 나뉘어져 있다. 예를 들어 세트에 요소를 더할 때는 인스턴스 메서드를 사용하고, 합집합을 구할 때는 정적 메서드를 사용하도록 만들어져 있다.a = {1, 2, 3, 4}a.update({5})    # 인스턴스 메서드a{1, 2, 3, 4, 5}set.union({1, 2, 3, 4}, {5})    # 정적(클래스) 메서드 합집합{1, 2, 3, 4, 5}이처럼 인스턴스의 내용을 변경해야 할 때는 update와 같이 인스턴스 메서드로 작성하면 되고, 인스턴스 내용과는 상관없이 결과만 구하면 될 때는 set.union과 같이 정적 메서드로 작성하면 된다.3. 클래스 메서드 사용하기이번에는 정적 메서드와 비슷하지만 약간의 차이점이 있는 클래스 메서드를 사용해보자.클래스 매서드는 다음과 같이 메서드 위에 @classmethod를 붙인다. 이때 클래스 메서드는 첫 번쨰 매개변수에 cls를 지정해야 한다.(cls는 class에서 따왔다).class 클래스이름:    @classmethod    def 메서드(cls, 매개변수1, 매개변수2):        코드그럼 사람 클래스 Person을 만들고 인스턴스가 몇 개 만들어졌는지 출력하는 메서드를 만들어보자.class Person:    count = 0    # 클래스 속성     def __init__(self):        Person.count += 1    # 인스턴스가 만들어질 때                             # 클래스 속성 count에 1을 더함     @classmethod    def print_count(cls):        print('{0}명 생성되었습니다.'.format(cls.count))    # cls로 클래스 속성에 접근 james = Person()maria = Person() Person.print_count()    # 2명 생성되었습니다.#실행 결과2명 생성되었습니다.먼저 인스턴스가 만들어질 때마다 숫자를 세야 하므로 __init__ 메서드에서 클래스 속성 count에 1을 더해줍니다. __init__은 인스턴스가 만들어질 떄 마다 자동으로 호출된다. 물론 클래스 속성에 접근한다는 것을 명확하게 하기 위해 Person.count와 같이 만들어줍니다.class Person:    count = 0    # 클래스 속성     def __init__(self):        Person.count += 1    # 인스턴스가 만들어질 때                             # 클래스 속성 count에 1을 더함이제 @classmethod를 붙여서 클래스 메서드를 만든다. 클래스 메서드는 첫 번째 매개변수가 cls인데 여기에는 현재 클래스가 들어오게된다. 따라서 cls.count처럼 cls로 클래스 속성 count에 접근할 수 있다.    @classmethod    def print_count(cls):        print('{0}명 생성되었습니다.'.format(cls.count))    # cls로 클래스 속성에 접근Person으로 인스턴스를 두 개 만들었으므로 print_count를 호출해보면 ‘2명 생성되었습니다.’가 출력된다. 물론 print_count는 클래스 메서드이므로 Person.print_count()처럼 클래스로 호출해준다.james = Person()maria = Person() Person.print_count()    # 2명 생성되었습니다.클래스 메서드는 정적 메서드처럼 인스턴스 없이 호출할 수 있다는 점은 같다. 하지만 클래스 메서드는 메서드 안에서 클래스 속성, 클래스 메서드에 접근해야 할 때 사용한다.특히 cls를 사용하면 메서드 안에서 현재 클래스의 인스턴스를 만들 수도 있다. 즉, cls는 클래스이므로 cls()는 Person()과 같다.    @classmethod    def create(cls):        p = cls()    # cls()로 인스턴스 생성 cls() = person()        return p예제1다음 소스 코드에서 Date 클래스를 완성하세요. is_date_valid는 문자열이 올바른 날짜인지 검사하는 메서드입니다. 날짜에서 월은 12월까지 일은 31일까지 있어야 합니다.class Date: ______________                                           ... ______________                                           if Date.is_date_valid('2000-10-31'):    print('올바른 날짜 형식입니다.')else:    print('잘못된 날짜 형식입니다.')답class Date:    @staticmethod    def is_date_valid(date_string):        year, month, day = map(int, date_string.split('-'))        return month &lt;= 12 and day &lt;= 31is_date_valid 메서드는 Date.is_date_valid처럼 호출하고 있지만, 문자열이 올바른 날짜인지 검사만 하면 되고, 클래스에 접근할 필요는 없다. 그러므로 정적 메서드로 만든다. 먼저 메서드 위에 @staticmethod를 붙여준 뒤 첫 번째 매개변수로 날짜 문자열 date_string을 지정한다. 메서드 안에서는 year, month, day = map(int, date_string.split(‘-‘))와 같이 ‘-‘로 문자열을 분리한 뒤 int로 변환해서 각 변수에 넣어준다. 그다음에는 return month &lt;= 12 and day &lt;= 31과 같이 월이 12 이하이면서 일이 31일 이하인지 검사하고 결과를 반환하도록 만든다. 즉, 월, 일 모두 만족하면 True가 반환되고 하나라도 만족하지 않으면 False가 반환하게 된다.예제2표준 입력으로 시:분:초 형식의 시간이 입력됩니다. 다음 소스 코드에서 Time 클래스를 완성하여 시, 분, 초가 출력되게 만드세요. from_string은 문자열로 인스턴스를 만드는 메서드이며 is_time_valid는 문자열이 올바른 시간인지 검사하는 메서드입니다. 시간은 24시까지, 분은 59분까지, 초는 60초까지 있어야 합니다. 정답에 코드를 작성할 때는 class Time:에 맞춰서 들여쓰기를 해주세요.class Time:    def __init__(self, hour, minute, second):        self.hour = hour        self.minute = minute        self.second = second________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________time_string = input() if Time.is_time_valid(time_string):    t = Time.from_string(time_string)    print(t.hour, t.minute, t.second)else:    print('잘못된 시간 형식입니다.')#입력23:35:59#결과23 35 59#입력12:62:43#결과잘못된 시간 형식입니다.답class Time:    def __init__(self, hour, minute, second):        self.hour = hour        self.minute = minute        self.second = second    @classmethod    def from_string(cls, time_string):        hour, minute, second = map(int, time_string.split(':'))        time = cls(hour, minute, second)        return time    @staticmethod    def is_time_valid(time_string):        hour, minute, second = map(int, time_string.split(':'))        return hour &lt;=24 and minute &lt;= 59 and second &lt;=60time_string = input() if Time.is_time_valid(time_string):    t = Time.from_string(time_string)    print(t.hour, t.minute, t.second)else:    print('잘못된 시간 형식입니다.')",
        "url": "/python-basic33"
    }
    ,
    
    "python-basic32": {
        "title": "Python - Python 클래스 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기클래스 사용하기클래스는 객체를 표현하기 위한 문법이다. 예를들어 게임을 만든다고 한다면 기사, 마법사, 궁수, 사제등 직업별로 클래스를 만들어 표현할 수 있다. 이처럼 특정한 개념이나 모양으로 존재하는 것을 객체(object)라고 부른다. 그리고 프로그래밍으로 객체를 만들때 사용하는 것이 클래스이다. 게임의 기사 캐릭터를 클래스로 표현해보자. 일단 게임 캐릭터는 체력, 마나, 물리 공격력, 주문력 등이 필요합니다. 그리고 기사 캐릭터는 칼로 베기, 찌르기 등의 스킬이 있어야 한다. 여기서 체력, 마나, 물리 공격력, 주문력 등의 데이터를 클래스의 속성(attribute)이라 부르고, 베기, 찌르기 등의 기능을 메서드(method)라고 부른다.이런 식의 프로그래밍을 객체지향(object oriented) 프로그래밍이라고 한다. 객체지향 프로그래밍은 복잡한 문제를 잘게 나누어 객체로 만들고, 객체를 조합해서 문제를 해결한다. 따라서 현실 세계의 복잡한 문제를 처리하는데 유용하며 기능을 개선하고 발전시킬 때도 해당 클래스만 수정하면 되므로 유지 보수에도 효율적이다.1. 클래스와 메서드 만들기클래스는 class에 클래스 이름을 지정하고:(콜론)을 붙인 뒤 다음 줄부터 def로 메서드를 작성한다. 여기서 메서드는 클래스 안에 들어있는 함수를 뜻한다.클래스 이름을 짓는 방법은 변수와 같다. 보통 파이썬에서 클래스의 이름은 대문자로 시작한다. 그리고 메서드 작성 방법은 함수와 같으며 코드는 반드시 들여쓰기를 해야한다. 특히 메서드의 첫 번째 매개변수는 반드시 self를 지정해야 한다.class 클래스이름:    def 메서드(self):        코드# 메서드의 첫 번째 매개변수를 self로 지정하지 않았을때.TypeError: ... takes 0 positional arguments but 1 was given: self간단한 사람 클래스를 작성했다.~~~pythonclass Person:     def greeting(self):         print('Hello')         이렇게 만든 클래스를 사용하려면 클래스에 ()를 붙인 뒤 변수에 할당한다. Person으로 변수 james를 만들었는데 이 james가 Person의 인스턴스(instance)다. 클래스는 특정 개념을 표현만 할뿐 사용을 하려면 인스턴스를 생성해야 한다.james = Person()메서드 호출하기메서드는 클래스가 아니라 인스턴트를 통해 호출한다. 다음과 같이 이스턴스 뒤에 .을 붙이고 메서드를 호출하면 된다. james.greeting()을 호출하니 ‘Hello’가 출력되었다. 이렇게 인스턴트를 통해 호출하는 메서드를 인스턴트 메서드라고 부른다.james.greeting()Hello파이썬에서 흔히 볼 수 있는 클래스지금까지 사용한 int, list, dict 등도 사실 클래스다. 우리는 이 클래스로 인스턴스를 만들고 메서드를 사용했다. int 클래스에 10을 넣어서 인스턴스 a를 만들었다. 마찬가지로 list 클래스에 range(10)을 넣어서 인스턴스 b를 만들고, dict 클래스에 x=10, y=20을 넣어서 인스턴스 c를 만들었다. 잘 보면 Person으로 인스턴스를 만드는 방법과 똑같다. 물론 정수는 매우 자주 사용하므로 int를 생략하고 10을 바로 넣는다. 그리고 리스트와 딕셔너리도 자주 사용하므로 축약된 문법인 [ ]과 { }를 제공하지만 클래스인 것은 같다.a = int(10)a10b = list(range(10))b[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]c = dict(x=10, y=20)c{'x': 10, 'y': 20}인스턴스 b에서 메서드 append를 호출해서 값을 추가한다. 이 부분도 지금까지 메서드를 만들고 사용한 것과 같은 방식이다.b = list(range(10))b.append(20)b[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20]즉, 파이썬에서는 자료형도 클래스이다. 다음과 같이 type을 사용하면 객체(인스턴스)가 어떤 클래스인지 확인할 수 있다.  type(객체)a = 10type(a)&lt;class 'int'&gt;b = [0, 1, 2]type(b)&lt;class 'list'&gt;c = {'x':10, 'y':20}type(c)&lt;class 'dict'&gt;maria = Person()type(maria)&lt;class '__main__.Person'&gt;인스턴스와 객체의 차이점?클래스는 객체를 표현하는 문법이라고 했는데, 클래스로 인스턴스를 만든다고 하니 좀 헷갈린다. 사실 인스턴스와 객체는 같은 것을 뜻한다. 보통 객체만 지칭할 때는 그냥 객체(object)라고 부른다. 하지만 클래스와 연관지어서 말할 때는 인스턴스(instance)라고 부른다. 그래서 다음과 같이 리스트 변수 a, b가 있으면 a, b는 객체이다. 그리고 a와 b는 list클래스의 인스턴스이다.a = list(range(10))b = list(range(20))빈 클래스 만들기내용이 없는 빈 클래스를 만들 때는 코드 부분에 pass를 넣어준다.class Person:    pass메서드 안에서 메서드 호출하기메서드 안에서 메서드를 호출할 때는 다음과 같이 self.메서드() 형식으로 호출해야 한다. self 없이 메서드 이름만 사용하면 클래스 바깥쪽에 있는 함수를 호출한다는 뜻이 되므로 주의해야 한다.class Person:    def greeting(self):        print('Hello')     def hello(self):        self.greeting()    # self.메서드() 형식으로 클래스 안의 메서드를 호출 james = Person()james.hello()    # Hello특정 클래스의 인스턴스인지 확인하기현재 인스턴스가 특정 클래스의 인스턴스인지 확인할 때는 isinstance 함수를 사용한다. 특정 클래스의 인스턴스가 맞으면 True, 아니면 False를 반환한다.  isinstance(인스턴스, 클래스)class Person:     passjames = Person()isinstance(james, Person)Trueisinstance는 주로 객체의 자료형을 판단할 때 사용한다. 예를 들어 팩토리얼 함수는 1부터 n까지 양의 정수를 차례대로 곱해야 하는데, 실수와 음의 정수는 계산할 수 없다. 이런 경우에 isinstance를 사용하여 숫자(객체)가 정수일 때만 계산하도록 만들 수 있다.def factorial(n):    if not isinstance(n, int) or n &lt; 0:    # n이 정수가 아니거나 음수이면 함수를 끝냄        return None    if n == 1:        return 1    return n * factorial(n - 1)2. 속성 사용하기지금까지 클래스에서 메서드를 만들고 호출해봤다. 이번엔 클래스에서 속성을 만들고 사용해보자. 속성(attribute)을 만들 때는 __init__ 메서드 안에서 self.속성에 값을 할당한다.class 클래스이름:    def __init__(self):        self.속성 = 값다음 코드를 실행해 보자.class Person:    def __init__(self):        self.hello = '안녕하세요.'     def greeting(self):        print(self.hello) james = Person()james.greeting()#실행결과안녕하세요.Person 클래스의 __init__ 메서드에서 self.hello에 ‘안녕하세요.’ 인사말을 넣었다. __init__ 메서드는 james = Person()처럼 클래스에 ( )(괄호)를 붙여서 인스턴스를 만들 때 호출되는 특별한 메서드다. 즉, __init__(initialize)이라는 이름 그대로 인스턴스(객체)를 초기화한다. 특히 이렇게 앞 뒤로 __(밑줄 두 개)가 붙은 메서드는 파이썬이 자동으로 호출해주는 메서드인데 스페셜 메서드(special method) 또는 매직 메서드(magic method)라고 부른다. 앞으로 파이썬의 여러 가지 기능을 사용할 때 이 스페셜 메서드를 채우는 식으로 사용하게 된다.class Person:    def __init__(self):        self.hello = '안녕하세요.'이제 greeting 메서드를 살펴보자. greeting 메서드에서는 print로 self.hello를 출력하게 만들었다. 그다음에 Person 클래스로 인스턴스를 만들고, greeting 메서드를 호출해보면 self.hello에 저장된 ‘안녕하세요.’가 출력된다.    def greeting(self):        print(self.hello)james = Person()james.greeting()    # 안녕하세요.self의 의미self는 인스턴스 자기 자신을 의미한다. 우리는 인스턴스가 생성될 때 self.hello = ‘안녕하세요.’처럼 자기 자신에 속성을 추가했다. 여기서 __init의 매개변수 self에 들어가는 값은 person()이라 할 수 있다. 그리고 self가 완성된 뒤 james에 할당된다. 이후 메서드를 호출하면 현재 인스턴스가 자동으로 매개변수 self에 들어오게 된다. 그래서 greeting메서드에서 print(self.hello)처럼 속성을 출력할 수 있었던 것이다.인스턴스를 만들 때 값 받기이번에는 클래스로 인스턴스를 만들 때 값을 받는 방법을 알아보겠습니다. 다음과 같이 init 메서드에서 self 다음에 값을 받을 매개변수를 지정합니다. 그리고 매개변수를 self.속성에 넣어줍니다.class 클래스이름:    def __init__(self, 매개변수1, 매개변수2):        self.속성1 = 매개변수1        self.속성2 = 매개변수2그럼 Person 클래스로 인스턴스를 만들 때 이름, 나이, 주소를 받아보자.class Person:    def __init__(self, name, age, address):        self.hello = '안녕하세요.'        self.name = name        self.age = age        self.address = address     def greeting(self):        print('{0} 저는 {1}입니다.'.format(self.hello, self.name)) maria = Person('마리아', 20, '서울시 서초구 반포동')maria.greeting()    # 안녕하세요. 저는 마리아입니다. print('이름:', maria.name)       # 마리아print('나이:', maria.age)        # 20print('주소:', maria.address)    # 서울시 서초구 반포동#실행 결과안녕하세요. 저는 마리아입니다.이름: 마리아나이: 20주소: 서울시 서초구 반포동__init__ 메서드를 보면 self 다음에 name, age, address를 지정했습니다. 그리고 메서드 안에서는 self.name = name처럼 매개변수를 그대로 self에 넣어서 속성으로 만들었다.    def __init__(self, name, age, address):        self.hello = '안녕하세요.'        self.name = name        self.age = age        self.address = addressgreeting 메서드는 인사를 하고 이름을 출력하도록 수정했다. 물론 name 속성에 접근할 때는 self.name처럼 사용해야한다.    def greeting(self):        print('{0} 저는 {1}입니다.'.format(self.hello, self.name))이제 Person의 ( )(괄호) 안에 이름, 나이, 주소를 콤마로 구분해서 넣은 뒤에 변수에 할당한다. 이렇게 하면 이름은 ‘마리아’, 나이는 20, 주소는 ‘서울시 서초구 반포동’인 maria 인스턴스가 만들어진다.maria = Person('마리아', 20, '서울시 서초구 반포동')maria 인스턴스의 greeting 메서드를 호출해보면 ‘안녕하세요. 저는 마리아입니다.’처럼 인삿말과 함께 이름도 출력된다.maria.greeting()    # 안녕하세요. 저는 마리아입니다.클래스 안에서 속성에 접근할 때는 self.속성 형식이 있었다. 클래스 바깥에서 속성에 접근할 때는 인스턴스.속성 형식으로 접근한다. 다음과 같이 maria.name, maria.age, maria.address의 값을 출력해보면 Person으로 인스턴스를 만들 때 넣었던 값이 출력된다.print('이름:', maria.name)       # 마리아print('나이:', maria.age)        # 20print('주소:', maria.address)    # 서울시 서초구 반포동클래스의 위치 인수, 키워드 인수클래스로 인스턴스를 만들 때 위치 인수와 키워드 인수를 사용할 수 있다. 규칙은 함수와 같다. 위치 인수와 리스트 언패킹을 사용하려면 다음과 같이 *args를 사용하면 됩니다. 이때 매개변수에서 값을 가져오려면 args[0]처럼 사용해야 한다.class Person:    def __init__(self, *args):        self.name = args[0]        self.age = args[1]        self.address = args[2] maria = Person(*['마리아', 20, '서울시 서초구 반포동'])키워드 인수와 딕셔너리 언패킹을 사용하려면 다음과 같이 **kwargs를 사용하면 됩니다. 이때 매개변수에서 값을 가져오려면 kwargs[‘name’]처럼 사용해야 한다.class Person:    def __init__(self, **kwargs):    # 키워드 인수        self.name = kwargs['name']        self.age = kwargs['age']        self.address = kwargs['address'] maria1 = Person(name='마리아', age=20, address='서울시 서초구 반포동')maria2 = Person(**{'name': '마리아', 'age': 20, 'address': '서울시 서초구 반포동'})인스턴스를 생성한 뒤에 속성 추가하기, 특정 속성만 허용하기지금까지 클래스의 인스턴스 속성은 init 메서드에서 추가한 뒤 사용했다. 하지만 클래스로 인스턴스를 만든 뒤에도 인스턴스.속성 = 값 형식으로 속성을 계속 추가할 수 있다. 다음 Person 클래스는 빈 클래스이지만 인스턴스를 만든 뒤 name 속성을 추가한다.class Person:     passmaria = Person()         # 인스턴스 생성maria.name = '마리아'    # 인스턴스를 만든 뒤 속성 추가maria.name'마리아'이렇게 추가한 속성은 해당 인스턴스에만 생성된다. 따라서 클래스로 다른 인스턴스를 만들었을 때는 추가한 속성이 생성되지 않는다.james = Person()    # james 인스턴스 생성james.name    # maria 인스턴스에만 name 속성을 추가했으므로 james 인스턴스에는 name 속성이 없음Traceback (most recent call last):  File \"&lt;pyshell#11&gt;\", line 1, in &lt;module&gt;    james.nameAttributeError: 'Person' object has no attribute 'name'인스턴스는 생성한 뒤에 속성을 추가할 수 있으므로 init 메서드가 아닌 다른 메서드에서도 속성을 추가할 수 있다. 단, 이때는 메서드를 호출해야 속성이 생성된다.class Person:     def greeting(self):         self.hello = '안녕하세요'    # greeting 메서드에서 hello 속성 추가maria = Person()maria.hello    # 아직 hello 속성이 없음Traceback (most recent call last):  File \"&lt;pyshell#22&gt;\", line 1, in &lt;module&gt;    maria.helloAttributeError: 'Person' object has no attribute 'hello'maria.greeting()    # greeting 메서드를 호출해야maria.hello         # hello 속성이 생성됨'안녕하세요'인스턴스는 자유롭게 속성을 추가할 수 있지만 특정 속성만 허용하고 다른 속성은 제한하고 싶을 수도 있다. 이때는 클래스에서 __slots__에 허용할 속성 이름을 리스트로 넣어주면 된다. 특히 속성 이름은 반드시 문자열로 지정해준다.  __slots__ = [‘속성이름1, ‘속성이름2’]class Person:     __slots__ = ['name', 'age']    # name, age만 허용(다른 속성은 생성 제한)maria = Person()maria.name = '마리아'                     # 허용된 속성maria.age = 20                            # 허용된 속성maria.address = '서울시 서초구 반포동'    # 허용되지 않은 속성은 추가할 때 에러가 발생함Traceback (most recent call last):  File \"&lt;pyshell#32&gt;\", line 1, in &lt;module&gt;    maria.address = '서울시 서초구 반포동'AttributeError: 'Person' object has no attribute 'address'3. 비공개 속성 사용하기위에서 만든 person클래스에는 hello, name, age, address 속성이 있었다.class Person:    def __init__(self, name, age, address):        self.hello = '안녕하세요.'        self.name = name        self.age = age        self.address = address이 속성들은 메서드에서 self로 접근할 수 있고, 인스턴스.속성 형식으로 클래스 바깥에서도 접근할 수 있다.maria = Person('마리아', 20, '서울시 서초구 반포동')maria.name'마리아'이번에는 클래스 바깥에서는 접근할 수 없고 클래스 안에서만 사용할 수 있는 비공개 속성(private attribute)을 사용해보자.비공개 속성은 __속성과 같이 이름이 (밑줄 두 개)로 시작해야 한다. 단, **__속성**처럼 밑줄 두 개가 양 옆에 왔을 때는 비공개 속성이 아니므로 주의해야 한다.class 클래스이름:    def __init__(self, 매개변수)        self.__속성 = 값Person 클래스에 지갑 속성 __wallet을 넣어 봤다. 다음 내용을 IDLE의 소스 코드 편집 창에 입력한 뒤 실행해보자. 실행을 해보면 에러가 발생한다. self.__wallet처럼 앞에 밑줄 두 개를 붙여서 비공개 속성으로 만들었으므로 클래스 바깥에서 maria.__wallet으로는 접근할 수 없다.class Person:    def __init__(self, name, age, address, wallet):        self.name = name        self.age = age        self.address = address        self.__wallet = wallet    # 변수 앞에 __를 붙여서 비공개 속성으로 만듦 maria = Person('마리아', 20, '서울시 서초구 반포동', 10000)maria.__wallet -= 10000    # 클래스 바깥에서 비공개 속성에 접근하면 에러가 발생함#실행결과Traceback (most recent call last):  File \"C:\\project\\class_private_attribute_error.py\", line 9, in &lt;module&gt;    maria.__wallet -= 10000    # 클래스 바깥에서 비공개 속성에 접근하면 에러가 발생함AttributeError: 'Person' object has no attribute '__wallet' 비공개 속성은 클래스 안의 메서드에서만 접근할 수 있다. 다음과 같이 돈을 내는 pay 메서드를 만들어보자. pay는 돈을 내면 해당 금액을 지갑에서 빼도록 만들었다.class Person:    def __init__(self, name, age, address, wallet):        self.name = name        self.age = age        self.address = address        self.__wallet = wallet    # 변수 앞에 __를 붙여서 비공개 속성으로 만듦     def pay(self, amount):        self.__wallet -= amount   # 비공개 속성은 클래스 안의 메서드에서만 접근할 수 있음        print('이제 {0}원 남았네요.'.format(self.__wallet)) maria = Person('마리아', 20, '서울시 서초구 반포동', 10000)maria.pay(3000)# 실행결과이제 7000원 남았네요.물론 지갑에 든 돈은 굳이 밝힐 필요가 없으므로 print로 출력하지 않아도 된다. 보통은 다음과 같이 지갑에 든 돈이 얼마인지 확인하고 돈이 모자라면 쓰지 못하는 식으로 만든다.    def pay(self, amount):        if amount &gt; self.__wallet:    # 사용하려고 하는 금액보다 지갑에 든 돈이 적을 때            print('돈이 모자라네...')            return        self.__wallet -= amount이처럼 비공개 속성은 클래스 바깥으로 드러내고 싶지 않은 값에 사용한다. 즉, 중요한 값인데 바깥에서 함부로 바꾸면 안될 때 비공개 속성을 주로 사용한다. 비공개 속성을 바꾸는 경우는 클래스의 메서드로 한정한다.공개 속성과 비공개 속성클래스 바깥에서 접근할 수 있는 속성을 공개 속성(public attribute)이라 부르고, 클래스 안에서만 접근할 수 있는 속성을 비공개 속성(private attribute)이라 부른다.비공개 메서드 사용하기속성뿐만 아니라 메서드도 이름이 __(밑줄 두 개)로 시작하면 클래스 안에서만 호출할 수 있는 비공개 메서드가 된다. 비공개 메서드도 메서드를 클래스 바깥으로 드러내고 싶지 않을 때 사용한다. 보통 내부에서만 호출되어야 하는 메서드를 비공개 메서드로 만든다. 예를 들어 게임 캐릭터가 마나를 소비해서 스킬을 쓴다고 치면 마나 소비량을 계산해서 차감하는 메서드는 비공개 메서드로 만들고, 스킬을 쓰는 메서드는 공개 메서드로 만든다. 만약 마나를 차감하는 메서드가 공개되어 있다면 마음대로 마나를 차감시킬 수 있으므로 잘못된 클래스 설계가 된다.class Person:    def __greeting(self):        print('Hello')     def hello(self):        self.__greeting()    # 클래스 안에서는 비공개 메서드를 호출할 수 있음 james = Person()james.__greeting()    # 에러: 클래스 바깥에서는 비공개 메서드를 호출할 수 없음예제1다음 소스 코드에서 클래스를 작성하여 게임 캐릭터의 능력치와 ‘베기’가 출력되게 만드세요. ______________                                           ... ______________                                           x = Knight(health=542.4, mana=210.3, armor=38)print(x.health, x.mana, x.armor)x.slash()#결과542.4 210.3 38베기답class Knight:    def __init__(self, health, mana, armor):        self.health = health        self.mana = mana        self.armor = armor     def slash(self):        print('베기')x = Knight(health=542.4, mana=210.3, armor=38)와 같이 클래스에 값을 넣어서 인스턴스를 생성하고, print(x.health, x.mana, x.armor)와 같이 인스턴스 속성을 출력하고 있다. 따라서 class로 Knight 클래스를 만들고 __init__ 메서드에 매개변수로 self, health, mana, armor를 지정한다. 이때 반드시 첫 번째 매개변수는 self어야 한다. 함수 안에서는 self.health = health처럼 모든 매개변수를 그대로 속성으로 만들어준다.그다음에 x.slash()와 같이 인스턴스로 메서드를 호출하고 있으므로 Knight 클래스 안에 slash 메서드를 만들고 print로 ‘베기’를 출력하도록 만들면 되겠다.예제2표준 입력으로 게임 캐릭터 능력치(체력, 마나, AP)가 입력됩니다. 다음 소스 코드에서 애니(Annie) 클래스를 작성하여 티버(tibbers) 스킬의 피해량이 출력되게 만드세요. 티버의 피해량은 AP * 0.65 + 400이며 AP(Ability Power, 주문력)는 마법 능력치를 뜻합니다.________________________________________________________________________________________________health, mana, ability_power = map(float, input().split()) x = Annie(health=health, mana=mana, ability_power=ability_power)x.tibbers()#입력511.68 334.0 298#결과티버: 피해량 593.7#입력1803.68 1184.0 645#결과티버: 피해량 819.25내가 쓴 답class Annie:    def __init__(self,**kwargs):        self.health = kwargs['health']        self.mana = kwargs['mana']        self.ability_power = kwargs['ability_power']    def tibbers(self):        print(\"티버: 피해량\", (self.ability_power * 0.65 + 400))코딩도장 풀이class Annie:    def __init__(self, health, mana, ability_power):        self.health = health        self.mana = mana        self.ability_power = ability_power    def tibbers(self):        print(\"티버: 피해량 {0} \".format(self.ability_power * 0.65 + 400))",
        "url": "/python-basic32"
    }
    ,
    
    "python-basic31": {
        "title": "Python - Python 클로저 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기클로저 사용하기변수의 사용범위와 함수를 클로저 형태로 만드는 방법을 알아보자.1. 변수의 사용 범위 알아보기파이썬 스크립트에서 변수를 만들면 다음과 같이 함수 안에서도 사용할 수 있다.foo함수에서 함수 바깥에 있는 변수 x의 값을 출력할 수 있다. 이처럼 함수를 포함하여 스크립트 전체에서 접근할 수 있는 변수를 전역 변수(global variable)라고 한다. 특히 전역 변수에 접근할 수 있는 범위를 전역 범위(globla scope)라고 한다.x = 10          # 전역 변수def foo():    print(x)    # 전역 변수 출력 foo()print(x)        # 전역 변수 출력#결과1010변수 x를 함수 foo안에서 만들고 실행을 해보면 x가 정의되지 않았다는 에러가 발생한다. 왜냐하면 변수 x는 함수 foo안에서 만들었기 때문에 foo의 지역 변수(local variable)이다. 따라서 지역 변수는 변수를 만든 함수 안에서만 접근할 수 있고, 함수 바깥에서는 접근할 수 없다. 특히 지역 변수를 접근할 수 있는 범위를 지역 범위(local scope)라고 한다.def foo():    x = 10      # foo의 지역 변수    print(x)    # foo의 지역 변수 출력 foo()print(x)        # 에러. foo의 지역 변수는 출력할 수 없음#결과10Traceback (most recent call last):  File \"C:\\project\\local_variable.py\", line 6, in &lt;module&gt;    print(x)        # 에러. foo의 지역 변수는 출력할 수 없음NameError: name 'x' is not defined함수 안에서 전역 변수 변경하기함수 안에서 전역 변수의 값을 넣어보자. 분명 함수 foo 안에서 x = 20처럼 x의 값을 20으로 변경했다. 하지만 함수 바깥에서 print로 x의 값을 출력해보면 10이다. 겉으로 보기에는 foo 안의 x는 전역 변수인 것 같지만 실제로는 foo의 지역 변수다. 즉, 전역 변수 x가 있고, foo에서 지역 변수 x를 새로 만들게 된다. 이 둘은 이름만 같을 뿐 서로 다른 변수이다.x = 10          # 전역 변수def foo():    x = 20      # x는 foo의 지역 변수    print(x)    # foo의 지역 변수 출력 foo()print(x)        # 전역 변수 출력#결과2010함수 안에서 전역 변수의 값을 변경하려면 global 키워드를 사용해야 한다. 다음과 같이 함수 안에서 global에 전역 변수의 이름을 지정해준다. 그리고 함수안에서 x를 20으로 변경하면 함수 바깥에서 x를 출력했어도 20이 나온다. 이렇게 함수안에서 변수를 global로 지정하면 전역 변수를 생성하게 된다.  global 전역변수x = 10          # 전역 변수def foo():    global x    # 전역 변수 x를 사용하겠다고 설정    x = 20      # x는 전역 변수    print(x)    # 전역 변수 출력 foo()print(x)        # 전역 변수 출력만약 전역 변수가 없을 때 함수 안에서 global을 사용하면 해당 변수는 전역 변수가 된다.# 전역 변수 x가 없는 상태def foo():    global x    # x를 전역 변수로 만듦    x = 20      # x는 전역 변수    print(x)    # 전역 변수 출력 foo()print(x)        # 전역 변수 출력네임스페이스파이썬에서 변수는 네임스페이스(namespace, 이름공간)에 저장된다. 다음과 같이 locals 함수를 사용하면 현재 네임스페이스를 딕셔너리 형태로 출력할 수 있다.출력된 네임스페이스를 보면 ‘x’: 10처럼 변수 x와 값 10이 저장되어 있습니다. 여기서는 전역 범위에서 네임스페이스를 출력했으므로 전역 네임스페이스를 가져옵니다.x = 10locals(){'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'x': 10}마찬가지로 함수 안에서 locals를 사용할 수 있다. 네임스페이스를 보면 ‘x’: 10만 저장되어 있다. 이때는 지역 범위에서 네임스페이스를 출력했으므로 지역 네임스페이스를 가져온다.def foo():     x = 10     print(locals())foo(){'x': 10}2. 함수 안에서 함수 만들기이번에는 함수 안에서 함수를 만드는 방법을 알아보자. 다음과 같이 def로 함수를 만들고 그 안에서 다시 def로 함수를 만들면 된다.def 함수이름1():    코드    def 함수이름2():        코드함수 안에서 문자열을 출력하는 함수를 만들고 호출해보자.함수 print_hello 안에서 다시 def로 함수 print_message를 만들었다. 그리고 print_hello안에서 print_message()처럼 함수를 호출했다. 하미잔 아직 함수를 정의만 한 상태이므로 아무것도 출력되지 않는다. 두 함수가 실제로 동작하려면 바깥쪽에 있는 print_hello를 호출해주어야 한다. 즉, print_hello &gt; print_message 순으로 실행된다.def print_hello():    hello = 'Hello, world!'    def print_message():        print(hello)    print_message() print_hello()# 실행결과Hello, world!지역 변수의 범위print_hello 함수와 print_message 함수에서 지역 변수의 범위를 살펴보자. 안쪽 함수 print_message에서는 바깥쪽 함수 print_hello의 지역 변수 hello를 사용할 수 있습니다.즉, 바깥쪽 함수의 지역 변수는 그 안에 속한 모든 함수에서 접근할 수 있다.def print_hello():    hello = 'Hello, world!'    def print_message():        print(hello)    # 바깥쪽 함수의 지역 변수를 사용지역 변수 변경하기바깥쪽 함수의 지역 변수를 안쪽 함수에서 변경해보자. 다음과 같이 안쪽 함수 B에서 바깥쪽 함수 A의 지역 변수 x를 변경한다. 실행을 해보면 20이 나와야 할 것 같은데 10이 나온다. 왜냐하면 겉으로 보기에는 바깥쪽 함수 A의 지역 변수 x를 변경하는 것 같지만, 실제로는 안쪽 함수 B에서 이름이 같은 지역 변수 x를 새로 만들게 된다. 즉, 파이썬에서는 함수에서 변수를 만들면 항상 현재 함수의 지역 변수가 된다.def A():    x = 10        # A의 지역 변수 x    def B():        x = 20    # x에 20 할당     B()    print(x)      # A의 지역 변수 x 출력 A()#결과10#def A():    x = 10        # A의 지역 변수 x    def B():        x = 20    # B의 지역 변수 x를 새로 만듦현재 함수의 바깥쪽에 있는 지역 변수의 값을 변경하려면 nonlocal 키워드를 사용해야 한다. 다음과 같이 함수 안에서 nonlocal에 지역 변수의 이름을 지정해준다.  nonlocal 지역변수def A():    x = 10        # A의 지역 변수 x    def B():        nonlocal x    # 현재 함수의 바깥쪽에 있는 지역 변수 사용        x = 20        # A의 지역 변수 x에 20 할당     B()    print(x)      # A의 지역 변수 x 출력 A()#결과20지역 변수 변경하기nonlocal은 현재 함수의 바깥쪽에 있는 지역 변수를 찾을 때 가장 가까운 함수부터 먼저 찾는다. 이번에는 함수의 단계를 A, B, C로 만들었다. 함수 C에서 nonlocal x를 사용하면 가장 가까운 바깥쪽에 있는 함수 B의 지역 변수 x = 20을 사용하게 된다. 따라서 x = x + 30은 50이 나온다. 그리고 함수 C에서 nonlocal y를 사용하면 바깥쪽에 있는 함수의 지역 변수 y를 사용해야 하는데 함수 B에는 y가 없다. 이때는 한 단계 더 바깥으로 나가서 함수 A의 지역 변수 y를 사용하게 된다. 즉, 가까운 함수부터 지역 변수를 찾고, 지역 변수가 없으면 계속 바깥쪽으로 나가서 찾는다.def A():    x = 10    y = 100    def B():        x = 20        def C():            nonlocal x            nonlocal y            x = x + 30            y = y + 300            print(x)            print(y)        C()    B() A()global로 전역 변수 사용하기함수가 몇 단계든 상관없이 global 키워드를 사용하면 무조건 전역 변수를 사용하게 된다. 함수 C에서 global x를 사용하면 전역 변수 x = 1을 사용하게 된다. 따라서 x = x + 30은 31이 나온다.x = 1def A():    x = 10    def B():        x = 20        def C():            global x            x = x + 30            print(x)        C()    B() A()# 실행결과313. 클로저 사용하기함수를 클로저 형태로 만드는 방법을 알아보자. 다음은 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 a * x + b를 계산하는 함수 mul_add를 만든 뒤에 함수 mul_add자체를 반환한다. 먼저 calc에 지역 변수 a와 b를 만들고 3과 5를 저장했다. 그다음에 함수 mul_add에서 a와 b를 사용하여 a * x + b를 계산한 뒤 반환한다.def calc():    a = 3    b = 5    def mul_add(x):        return a * x + b    # 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 계산    return mul_add          # mul_add 함수를 반환 c = calc()print(c(1), c(2), c(3), c(4), c(5))#실행 결과8 11 14 17 20함수 mul_add를 만들고 calc함수를 바로 호출하지 않고 mul_add함수 자체를 return한다(함수를 반환할 때는 함수 이름만 반환해야 하며 ( )(괄호)를 붙이면 안 된다).return mul_add 이제 클로저를 사용한다. 다음과 같이 함수 calc를 호출한 뒤 반환값을 c에 저장한다. calc에서 mul_add를 반환했음으로 c에는 함수 mul_add가 들어간다. 그리고 c에 숫자를 넣어서 호출해보면 a * x + b 계산식에 따라 값이 출력 된다.c = calc()print(c(1), c(2), c(3), c(4), c(5))코드를 보면 함수 calc가 끝났는데도 c는 calc의 지역 변수 a, b를 사용해서 계산을 하고 있다. 이렇게 함수를 둘러싼 환경(지역 변수, 코드 등)을 계속 유지하다가, 함수를 호출할 때 다시 꺼내서 사용하는 함수를 클로저(closure)라고 한다. 여기서는 c에 저장된 함수가 클로저다.lambda로 클로저 만들기클로저는 다음과 같이 lambda로도 만들 수 있다. return lambda x: a * x + b처럼 람다 표현식을 만든 뒤 람다 표현식 자체를 반환했다. 이렇게 람다를 사용하면 클로저를 좀 더 간단하게 만들 수 있다.보통 클로저는 람다 표현식과 함께 사용하는 경우가 많아 둘을 혼동하기 쉽다. 람다는 이름이 없는 익명 함수를 뜻하고, 클로저는 함수를 둘러싼 환경을 유지했다가 나중에 다시 사용하는 함수를 뜻한다.def calc():    a = 3    b = 5    return lambda x: a * x + b    # 람다 표현식을 반환 c = calc()print(c(1), c(2), c(3), c(4), c(5))#실행 결과8 11 14 17 20클로저의 지역 변수 변경하기지금까지 클로저의 지역 변수를 가져오기만 했는데, 클로저의 지역 변수를 변경하고 싶다면 nonlocal을 사용하면 된다. 다음은 a * x + b의 결과를 함수 calc의 지역 변수 total에 누한다.def calc():    a = 3    b = 5    total = 0    def mul_add(x):        nonlocal total        total = total + a * x + b        print(total)    return mul_add c = calc()c(1)c(2)c(3)# 실행 결과81933예제1다음 소스 코드를 완성하여 함수 c를 호출할 때마다 호출 횟수가 출력되게 만드세요. 여기서는 함수를 클로저로 만들어야 합니다.def counter():    i = 0    def count():                               ...                        c = counter()for i in range(10):    print(c(), end=' ')# 결과1 2 3 4 5 6 7 8 9 10 답        nonlocal i        i += 1        return i    return count함수 counter를 호출해서 반환값을 c에 저장한 뒤에 c를 호출하고 있다. 그리고 c를 호출할 때마다 값이 계속 유지되게 하려면 함수를 클로저로 만들어야 한다.함수 counter에서는 지역 변수 i에 0이 할당되어 있고, 함수 count가 만들어져 있다. 따라서 count에서 i에 1을 더한 값을 저장한 뒤 i를 반환한다. 이때 nonlocal을 사용하여 함수 바깥쪽의 지역 변수 i를 변경할 수 있도록 만들어야 한다.마지막으로 함수 counter에서 함수 count를 반환하면 된다(함수를 반환할 때는 함수 이름만 반환해야 하며 ( )(괄호)를 붙이면 안 된다).예제2표준 입력으로 정수가 입력됩니다. 다음 소스 코드를 완성하여 함수 c를 호출할 때마다 숫자가 1씩 줄어들게 만드세요. 여기서는 함수를 클로저로 만들어야 합니다. 정답에 코드를 작성할 때는 def countdown(n):에 맞춰서 들여쓰기를 해주세요.def countdown(n):________________________________________________________________________________________________n = int(input()) c = countdown(n)for i in range(n):    print(c(), end=' ')#입력10#결과10 9 8 7 6 5 4 3 2 1 #입력20#결과20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 답    i = n +1    def count():        nonlocal i        i -= 1        return i    return count반환 값을 c에 저장하고 c를 호출한다.  먼저 함수 countdown에 지역변수를 만들고 매개변수 n에 1을 더해서 할당한다. 여기선느 입력값이 10이면 10부터 숫자가 1씩 줄어들고 있으므로 처음 시작할 값은 11로 만든다(n = 10일때 for i in ragne(11)이어야 10부터 출력). 그리고 count 함수로 지역 변수 i를 변경하기 위해 nonlacal을 사용하고 i를 호출될때마다 1씩 감소하게 한다. i를 반환하게 만든 후 count함수를 다시 리턴하게 만든다.",
        "url": "/python-basic31"
    }
    ,
    
    "python-basic30": {
        "title": "Python - Python 람다 표현식 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기람다 표현식 사용하기람다 표현식은 식 형태로 되어 있다고 해서 람다 표현식(lambda expression) 이라고 부든다. 특히 람다 표현식은 함수를 간편하게 작성할 수 있어서 다른 함수의 인수러 넣을 떄 주로 사용한다.1. 람다 표현식으로 함수 만들기람다 표현식을 사용하기 전에 먼저 숫자를 받은 뒤 10을 더해서 반환하는 함수 plus_ten을 만들어 보자. return x + 10으로 매개변수 x에 10을 더한 값을 반환하는 간단한 함수다.def plus_ten(x):    return x + 10plus_ten(1)11plus_ten함수를 람다 표현식으로 작성해보자. 람다 표현식은 아래와 같이 lambda에 매개변수를 지정하고 :(클론)뒤에 반환값으로 사용할 식을 지정한다.  lambda 매개변수들: 식실행하면 함수 객체가 나온다. 이상태로는 함수를 호출할 수 없다. 람다 표현식은 이름이 없는 함수를 만들기 때문이다. 그래서 람다표현식을 익명함수(anonymous function)라고도 한다.lambda x: x + 10&lt;function &lt;lambda&gt; at 0x02C27270&gt;lambda로 만든 익명 함수를 호출하려면 다음과 같이 람다 표현식을 변수에 할당해줘야한다. lambda x: x + 10은 매개변수 x 하나를 받고, x에 10을 더해서 반환한다는 뜻이다. 즉, 매개변수, 연산자, 값 등을 조합한 식으로 반환값을 만드는 방식이다.plus_ten = lambda x: x + 10plus_ten(1)11람다 표현식 자체를 호출하기람다 표현식은 변수에 할당하지 않고 람다 표현식 자체를 바로 호출할 수 있다. 다음과 같이 람다 표현식을 ()로 묶은 뒤에 다시 ()를 붙이고 인수를 넣어서 호출하면 된다.  (lambda 매개변수들: 식)(인수들)(lambda x: x + 10)(1)11람다 표현식 안에서는 변수를 만들 수 없다람다 표현식에서 주의할 점은 람다 표현식 안에서는 새 변수를 만들 수 없다는 점이다. 따라서 반환값 부분은 변수 없이 식 한 줄로 표현할 수 있어야 한다. 변수가 필요한 코드일 경우에는 def로 함수를 작성하는 것이 좋다.(lambda x: y = 10; x + y)(1)SyntaxError: invalid syntax단, 람다 표현식 바깥에 있는 변수는 사용할 수 있다. 다음은 매개변수 x와 람다 표현식 밖의 y변수를 더해서 반환한다.&gt;&gt;&gt; y = 10&gt;&gt;&gt; (lambda x: x + y)(1)11람다 표현식을 인수로 사용하기람다 표현식을 사용하는 이유는 함수의 인수 부분에서 간단하게 함수를 만들기 위해서 이다. 이런 방식으로 사용하는 대표적인 예가 map이다.람다 표현식을 사용하기 전에 먼저 def로 함수를 만들어서 map을 사용하게 만들어보자. 다음과 같이 숫자를 받은 뒤 10을 더해서 반환하는 함수 plus_ten을 작성한다. 그리도 map에 plus_ten함수와 리스트 [1, 2, 3]을 넣는다. 물론 map의 결과는 map 객체이므로 눈으로 확인할 수 있도록 list를 사용해서 리스트로 변환해준다.def plus_ten(x):     return x + 10list(map(plus_ten, [1, 2, 3]))[11, 12, 13]plus_ten 함수는 매개변수 x에 10을 더해서 반환하므로 리스트 [1, 2, 3]이 [11, 12, 13]으로 바뀌었다. 지금까지 map을 사용할 때 map(str, [1, 2, 3])과 같이 자료형 int, float, str등을 넣었다. plus_ten함수를 직접 만들어 넣어도 된다.plus_ten함수 대신 람다 표현식 lambda x: x + 10을 넣었다. 적체적으로 보면 코드가 세줄에서 한 줄로 줄었다. 이처럼 란다 표현식은 함수를 다른 함수의 인수로 넣을 때 매우 편리하다.list(map(lambda x: x + 10, [1, 2, 3]))[11, 12, 13]람다 표현식으로 매개변수가 없는 함수 만들기람다 표현식으로 매개변수가 없는 함수를 만들 때는 lambda 뒤에 아무것도 지정하지 않고 :(콜론)을 붙인다. 단, 콜론 뒤에는 반드시 반환할 값이 있어야 한다. 왜냐하면 표현식(expression)은 반드시 값으로 평가되어야 하기 때문이다.(lambda : 1)()1x = 10&gt;&gt;&gt; (lambda : x)()102. 람다 표현식과 map, filter, reduce 함수 활용하기람다 표현식과 map, filter, reduce 함수를 함께 사용해보자.람다 표현식에 조건부 표현식 사용하기람다 표현식에서 조건부 표현식을 사용하는 방법을 알아보자.  lambda 매개변수들: 식1 if 조건식 else 식2다음은 map을 사용하여 리스트 a에서 3의 배수를 문자열로 변환한다. map은 리스트의 요소를 각각 처리하므로 lambda의 반환값도 요소여야 한다. 여기서는 요소가 3의 배수일 때는 str(x)로 요소를 문자열로 만들어서 반환했고, 3의 배수가 아닐 때는 x로 요소를 그대로 반환했다.a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]list(map(lambda x: str(x) if x % 3 == 0 else x, a)) # 람다 표현식 안에서의 if와 else를 사용할떄는 :을 붙이지 않는다[1, 2, '3', 4, 5, '6', 7, 8, '9', 10]람다 표현식 안에서 조건=부 표현식 if, else를 사용할 때는 :(콜론)을 붙이지 않는다. 일반적인 if, else와 문법이 다르므로 주의해야 한다. 조건부 표현식은 식1 if 조건식 else 식2 형식으로 사용하며 식1은 조건이 참일때, 식2는 조건식이 거짓일 때 사용할 식이다.특히 람다 표현식에서 if를 사용했다면 반드시 else를 사용해야 한다. 다음과 같이 if만 사용하면 문법 에러가 발생하므로 주의해야 한다.list(map(lambda x: str(x) if x % 3 == 0, a))SyntaxError: invalid syntax그리도 람다 표현식 안에서는 elif를 사용할 수 없다. 따라서 조건부 표현식은 식1 if 조건식1 else 식2 if 조건식2 else 식3 형식처럼 if를 연속으로 사용해야 한다. 예를 들어 리스트에서 1은 무자열로 반환하고, 2는 실수로 변환, 3이상은 10을 더하는 식은 다음과 같이 만든다.  lambda 매개변수들: 식1 if 조건식1 else 식2 if 조건식2 else 식3a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]list(map(lambda x: str(x) if x == 1 else float(x) if x == 2 else x + 10, a))['1', 2.0, 13, 14, 15, 16, 17, 18, 19, 20]def로 함수를 만들고 if, elif, else를 사용해 나타내면 아래와 같다.def f(x):     if x == 1:         return str(x)     elif x == 2:         return float(x)     else:         return x + 10a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; list(map(f, a))['1', 2.0, 13, 14, 15, 16, 17, 18, 19, 20]map에 객체를 여러 개 넣기map은 리스트 등의 반복 가능한 객체를 여러 개 넣을 수도 있다. 다음은 두 리스트의 요소를 곱해서 새 리스트를 만든다.a = [1, 2, 3, 4, 5]b = [2, 4, 6, 8, 10]list(map(lambda x, y: x * y, a, b))[2, 8, 18, 32, 50]이렇게 리스트 두 개를 처리할 때는 람다 표현식에서 lambda x, y: x*y처럼 매개변수를 두개로 지정하면 된다. 그리고 map에 람다 표현식을 넣고 그 다음에 리스트 두 개를 콤마로 구분해서 넣어준다. 즉, 람다 표현식의 매개변수 개수에 맞게 반복 가능한 객체도 콤마로 구분해서 넣어준다.filter 사용하기이번에는 filter를 사용해보자. filter는 반복 가능한 객체에서 특정 조건에 맞는 요소만 가져오는데, filter에 지정한 함수의 반환값이 True일 때만 해당 요소를 가져온다.  filter(함수, 반복가능한객체)먼저 def로 함수를 만들어서 filter를 사용해보자. 다음은 리스트에서 5보다 크면서 10보다 작은 숫자를 가져온다. 리스트 a에서 8, 7, 9를 가져왔다. 즉, filter는 x &gt; 5 and x &lt; 10의 결과가 참인 요소만 가져오고 거짓인 요소는 버린다.def f(x):     return x &gt; 5 and x &lt; 10a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]list(filter(f, a))[8, 7, 9]# 리스트 a는 여전히 [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]그럼 함수 f를 람다 표현식으로 만들어 보자.a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]list(filter(lambda x: x &gt; 5 and x &lt; 10, a))reduce 사용하기reduce를 사용해 보자. reduce는 반복 가능한 객체의 각 요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환하는 함수이다.  from functools import reduce  reduce(함수, 반복가능한객체)다음은 리스트에 저장된 요소를 순서대로 더한 뒤 누적된 결과를 반환한다. reduce의 반환값이 15가 나왔다. 함수 f에서 x + y를 반환하도록 만들었으므로 reduce는 그림과 같이 요소 두 개를 계속 더하면서 결과를 누적한다.def f(x, y):     return x + ya = [1, 2, 3, 4, 5]from functools import reducereduce(f, a) #1과2를 더하고 더한값인 3과 3을 더하고 6과4를 더하고 10과 5를 더한다.15이제는 함수 f를 람다 표현식으로 만들어서 reduce에 넣어보자.a = [1, 2, 3, 4, 5]from functools import reducereduce(lambda x, y: x + y, a)15map, filter, reduce와 리스트 표현식리스트(딕셔너리, 세트)표현식으로 처리할 수 있는 경우에는 map, filter와 람다 표현식 대신 리스트 표현식을 사용하는 것이 좋다. list(filter(lambda x: x &gt; 5 and x &lt; 10 ,a&gt;))는 다음과 같이 리스트 표현식으로도 만들 수 있다.a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11][i for i in a if i &gt; 5 and i &lt; 10][8, 7, 9]또한, for, while 반복문으로 처리할 수 있는 경우에도 reduce 대신 for, while을 사용하는 것이 좋다. 왜냐하면 reduce는 코드가 조금만 복잡해져도 의미하는 바를 한 눈에 알아보기가 힘들기 때문이다. 이러한 이유로 파이썬 3부터는 reduce가 내장 함수에서 제외되었다.reduce(lambda x, y: x + y, a)는 다음과 같이 for 반복문으로 표현할 수 있습니다.a = [1, 2, 3, 4, 5]x = a[0]for i in range(len(a) - 1):     x = x + a[i + 1]x15예제1다음 소스 코드를 완성하여 확장자가 .jpg, .png인 이미지 파일만 출력되게 만드세요. 여기서는 람다 표현식을 사용해야 하며 출력 결과는 리스트 형태라야 합니다. 람다 표현식에서 확장자를 검사할 때는 문자열 메서드를 활용하세요..files = ['font', '1.png', '10.jpg', '11.gif', '2.jpg', '3.png', 'table.xslx', 'spec.docx'] print(                                                                           )#실행결과['1.png', '10.jpg', '2.jpg', '3.png']답list(filter(lambda x: x.find('.jpg') != -1 or x.find('.png') != -1, files)) # find(x)는 찾을 문자열 x가 있으면 인덱스 값을 반환하고 없으면 -1을 반환한다.예제2표준 입력으로 숫자.확장자 형식으로 된 파일 이름 여러 개가 입력됩니다. 다음 소스 코드를 완성하여 파일 이름이 숫자 3개이면서 앞에 0이 들어가는 형식으로 출력되게 만드세요. 예를 들어 1.png는 001.png, 99.docx는 099.docx, 100.xlsx는 100.xlsx처럼 출력되어야 합니다. 그리고 람다 표현식을 사용해야 하며 출력 결과는 리스트 형태라야 합니다. 람다 표현식에서 파일명을 처리할 때는 문자열 포매팅과 문자열 메서드를 활용하세요.files = input().split() print(________________)#예1.jpg 10.png 11.png 2.jpg 3.png#결과['001.jpg', '010.png', '011.png', '002.jpg', '003.png']#예97.xlsx 98.docx 99.docx 100.xlsx 101.docx 102.docx#결과['097.xlsx', '098.docx', '099.docx', '100.xlsx', '101.docx', '102.docx']답list(map(lambda x: '{0:03d}'.format(int(x.split('.')[0])) + '.' + x.split('.')[1],files))주어진 값을 살펴보면 ‘1.jpg’로 .기준으로 숫자와 문자로 나눌 수 있다. 따라서 split을 이용해 files의 각 요소를 .을 기준으로 나누어 [‘1’, ‘jgp’]식으로 리스트로 만든다. 그 다음 첫번쨰 요소를 숫자로 포매팅 해야하기 때문에 int로 정수형으로 바꿔준다. 그후 숫자형 포매팅 방법중 ‘{인덱스:0개수d’}’.format(숫자) 으로 0을 붙여준다. 이후 .를 더해주고 거기에 다시 아까 나누어 놓았던 문자열 x.split(‘.’)[1]을 더해준다.",
        "url": "/python-basic30"
    }
    ,
    
    "python-basic29": {
        "title": "Python - Python 함수에서 재귀호출 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기함수에서 재귀호출 사용하기함수 안에서 함수 자기자신을 호출하는 방식을 재귀호출(recursive call)이라고 한다. 재귀 호출은 일반적인 상황에서는 잘 사용하지 않지만 알고리즘을 구현할 때 매우 유용하다. 보통 알고리즘에 따라서 반복문으로 구현한 코드보다 재귀호출로 구현한 코드가 좀 더 직관적이고 이해하기 쉬운 경우가 많다.1. 재귀호출 사용하기먼저 간단한 재귀호출 함수를 만들어보자. 다음 내용을 IDLE의 소스 코드 편집 창에 입력한 뒤 실행해보자.def hello():    print('Hello, world!')    hello() hello()hello 함수 안에서 다시 hello 함수를 호출하고 있다. 소스 코드를 실행해보면 ‘Hello, world!’ 문자열이 계속 출력되다가 에러가 발생한다. 왜냐하면 파이썬에서는 최대 재귀 깊이(maximum recursion depth)가 1,000으로 정해져 있어서 그렇다. 즉, hello 함수가 자기자신을 계속 호출하다가 최대 재귀 깊이를 초과하면 RecursionError가 발생한다.Hello, world!Hello, world!Hello, world!...(생략)Traceback (most recent call last):  File \"C:\\project\\recursive_function_error.py\", line 5, in &lt;module&gt;    hello()  File \"C:\\project\\recursive_function_error.py\", line 3, in hello    hello()  File \"C:\\project\\recursive_function_error.py\", line 3, in hello    hello()  File \"C:\\project\\recursive_function_error.py\", line 3, in hello    hello()  [Previous line repeated 974 more times]  File \"C:\\project\\recursive_function_error.py\", line 2, in hello    print('Hello, world!')RecursionError: maximum recursion depth exceeded while pickling an object 재귀호출에 종료 조건 만들기재귀호출을 사용하려면 반드시 다음과 같이 종료 조건을 만들어주어야 한다. 먼저 hello 함수의 반복 횟수를 계산하기 위해 매개변수 count를 지정다. 그리고 count가 0이면 hello 함수를 호출하지 않고 끝낸다. 만약 0이 아니면 ‘Hello, world!’를 출력하고, count의 값을 1씩 감소시킨 뒤 hello 함수를 호출할 때 넣어준다.def hello(count):    if count == 0:    # 종료 조건을 만듦. count가 0이면 다시 hello 함수를 호출하지 않고 끝냄        return        print('Hello, world!', count)        count -= 1      # count를 1 감소시킨 뒤    hello(count)    # 다시 hello에 넣음 처음 5를 넣었다고 하면 hello(4)가 되고 점차 줄어든다. hello(5)    # hello 함수 호출#결과Hello, world! 5Hello, world! 4Hello, world! 3Hello, world! 2Hello, world! 12. 재귀호출로 팩토리얼 구하기팩토리얼은 1부터 n까지 양의 정수를 차례대로 곱한 값이다. !(느낌표) 기호로 표기한다. 예를 들어 5!은 5 * 4 * 3 * 2 * 1이며 결과는 120이다. 재귀함수를 사용해 팩토리얼을 구현해 보자.def factorial(n):    if n == 1:      # n이 1일 때        return 1    # 1을 반환하고 재귀호출을 끝냄    return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함 print(factorial(5))# 실행 결과120먼저 factorial 함수를 만들 때 매개변수 n을 지정해준다. 팩토리얼은 1부터 n까지의 곱을 구하는 문제인데 여기서는 n부터 역순으로 1씩 감소하면서 재귀호출을 하고 n이 1이 되었을때 재귀호출을 중단한다.def factorial(n):    if n == 1:      # n이 1일 때        return 1    # 1을 반환하고 재귀호출을 끝냄factorial 함수의 핵심은 반환값 부분이다. 계산 결과가 즉시 구해지는 것이 아니라 재귀호출로 n - 1을 계속 전달하다가 n이 1일 때 비로소 1을 반환하면서 n과 곱하고 다시 결괏값을 반환한다. 그 뒤 n과 반환된 결괏값을 곱하여 다시 반환하는 과정을 반복한다.return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함factorial(5)를 호출해서 n이 1이 될 때까지 재귀호출하면 다음과 같은 모양이 된다. 왼쪽에서 오른쪽 순서이다.            5 * factorial      5 * factorial      5 * factorial      5 * factorial      5 * factorial                         4 * factorial      4 * factorial      4 * factorial      4 * factorial                            3 * factorial      3 * factorial      3 * factorial                                   2 * factorial      2 * factorial                                          factorial(1) return 1      이제 if n == 1:을 만나서 factorial 함수가 1을 반환한다. 그 뒤 1과 2를 곱해서 2를 반환하고, 3과 2를 곱해서 6을 반환하고, 4와 6을 곱해서 24를 반환하고, 5와 24를 곱해서 120을 반환하게 된다.            5 * factorial      5 * factorial      5 * factorial      5 * factorial      5 * factorial                  4 * factorial      4 * factorial      4 * factorial      4 * factorial                     3 * factorial      3 * factorial      3 * factorial                            2 * factorial      2 * factorial                                   factorial(1) return 1                                  예제1다음 소스 코드를 완성하여 문자열이 회문인지 판별하고 결과를 True, False로 출력되게 만드세요. 여기서는 재귀호출을 사용해야 합니다.def is_palindrome(word):    _________________________                                    ...    _________________________                                 print(is_palindrome('hello'))print(is_palindrome('level'))# 실행결과FalseTrue답    if len(word) &lt; 2:      # 문자열의 길이가 2미만이면 True를 반환하고 재귀함수를 종료시킨다.         return True    if word[0] != word[-1]: # 첫 문자와 마지막 문자가 다르면 False를 출력하고 아니면 다음 줄로 이동        return False    return is_palindrome(word[1:-1]) #문자열의 1번인덱스 부터 -2인덱스 까지 넣어서 다시 함수에 넣는다. (문자열 슬라이싱에서  1:-1이면 마지막 인덱스의 전까지 가져온다.)예제2표준 입력으로 정수 한 개가 입력됩니다(입력 값의 범위는 10~30). 다음 소스 코드를 완성하여 입력된 정수에 해당하는 피보나치 수가 출력되게 만드세요.피보나치 수는 0과 1로 시작하며, 다음 번 피보나치 수는 바로 앞의 두 피보나치 수의 합입니다.# n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21...# 결과0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946...________________________________________________________________________________n = int(input())print(fib(n))#예10#결과55#예20#결과6765답def fib(n):    if n &lt;= 1:        return n    return fib(n-1)+fib(n-2)#또는 def fib(n):    if n &lt; 3: # 피보나치 수열의 2번쨰 까지 값이 1로 첫번째 값은 0이지만 영향을 주지 않아 값은 그대로 나옴        return 1    return fib(n-1)+fib(n-2)#재귀함수를 사용하지 않은 코드# 0 1 1 2 3 5 8 13 21 34 55 89# fib(1) = [1], fib(2) = [1, 1] fib(3) = [1, 1, 2]def fib(num):    result = []        first = 1    second = 1    if(num &gt; 1):        result.append(first)            result.append(second)        for i in range(2, num):        third = first + second        result.append(third)        first = second        second = third       return result.pop()    print(fib(num))피보나치 수열을 재귀함수로 해결하려면 결과와 정의를 잘 봐야한다. 재귀함수를 풀때는 역순으로 생각하는게 편하며 지문에서 말했듯이 ‘바로앞의 두 피보나치 수의 합이 다음 번 피보나치 수가 된다.’를 코드로 작성하면 fib(n) = fib(n-1)+fib(n-2) 이라는 것이다. 이 예제는 트리 형태를 띄고 있으며 10을 호출했을 경우를 풀어서 작성해보자. 각 함수 fib(n) 안에 다시 fib함수가 들어있는 형태이다.  fib(10) = fib(9) + fib(8)  (34+21 = 55)  fib(9) = fib(8) + fib(7)   (21+13 = 34)  fib(8) = fib(7) + fib(6)   (13+8 = 21)  fib(7) = fib(6) + fib(5)   (8+5 = 13)  fib(6) = fib(5) + fib(4)   (5+3 = 8)  fib(5) = fib(4) + fib(3)   (3+2 = 5)  fib(4) = fib(3) + fib(2)   (2+1 = 3)  fib(3) = fib(2) + fib(1)   (1+1 = 2)  fib(2) = fib(1) + fib(0)   (1+0 = 1)  fib(1) = 1",
        "url": "/python-basic29"
    }
    ,
    
    "python-basic28": {
        "title": "Python - Python 함수에서 위치 인수와 키워드 인수 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기함수에서 위치 인수와 키워드 인수 사용하기파이썬에서는 함수를 좀 더 편리하게 사용할 수 있도록 다양한 기능을 제공한다. 이번에는 함수에서 위치 인수, 키워드 인수를 사용하는 방법과 리스트, 딕셔너리 언패킹(unpacking)을 활용하는 방법을 알아보자.1. 위치 인수와 리스트 언패킹 사용하기다음과 같이 함수에 인수를 순서대로 넣는 방식을 위치 인수(positional argument)라고 한다. 즉, 인수의 위치가 정해져 있다. print에 10, 20, 30 순으로 넣었으므로 출력될 때도 10 20 30으로 출력된다.print(10, 20, 30)10 20 30위치 인수를 사용하는 함수를 만들고 호출하기숫자 세 개를 각 줄에 출력하는 함수를 만들어보자. print_numbers에 숫자 세개를 넣으면 각 줄에 숫자가 출력된다.def print_numbers(a, b, c):     print(a)     print(b)     print(c)print_numbers(10, 20, 30)#출력102030언패킹 사용하기이렇게 인수를 순서대로 넣을 때는 리스트나 튜플을 사용할 수도 있다. 다음과 같이 리스트 또는 튜플 앞에 *를 붙여서 함수에 넣어주면 된다. print_numbers에 10, 20, 30이 들어있는 리스트 x를 넣고 *만 붙였는데도 숫자가 각 줄에 출력되었다. 즉, 리스트(튜플) 앞에 *를 붙이면 언패킹(unpacking)이 되어서 print_numbers(10, 20, 30)과 똑같은 동작이다. 말 그대로 리스트의 포장을 푼다는 뜻이다.  함수(*리스트)  함수(*튜플)x = [10, 20, 30]print_numbers(*x)102030리스트 변수 대신 리스트 앞에 바로 *를 붙여도 동작은 같다. 단, 이때 함수의 매개변수 개수와 리스트의 요소 개수는 같아야 한다. 만약 개수가 다르면 함수를 호출할 수 없다. 단 이때 함수의 매개변수 개수와 리스트의 요소 개수는 같아야 한다. 여기서는 함수를 def print_numbers(a, b, c):로 만들었으므로 리스트에는 요소를 3개 넣어야 한다.print_numbers(*[10, 20, 30])# 출력102030# 매개변수를 2개 넣었을때print_numbers(*[10, 20])Traceback (most recent call last):  File \"&lt;pyshell#16&gt;\", line 1, in &lt;module&gt;    print_numbers(*[10, 20])TypeError: print_numbers() missing 1 required positional argument: 'c'가변 인수 함수 만들기가변인수와 리스트 언패킹은 인수의 개수가 정해지지 않은 가변 인수(variable argument)에 사용한다. 즉, 같은 함수에 인수 한개를 넣을 수도 있고, 열 개를 넣을 수도 있다. 또는 인수를 넣지 않을 수도 있다. 다음과 같이 가변 인수 함수는 매개변수 앞에 *를 붙여서 만든다.def 함수이름(*매개변수):    코드이제 숫자 여러 개를 받고, 숫자를 각 줄에 출력하는 함수를 만들어보자. 다음과 같이 함수를 만들 때 괄호 안에 *args와 같이 매개변수 앞에 *를 붙인다. 그리고 함수 안에서는 for로 args를 반복하면서 print로 값을 출력한다. 매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 arguments를 줄여서 args로 사용힌다. 특히 이 args는 튜플이라서 for로 반복할 수 있다.def print_numbers(*args):     for arg in args:         print(arg)그럼 print_numbers 함수에 숫자를 넣어서 호출해보자. 숫자를 한 개 넣으면 한 개 출력되고, 네 개 넣으면 네 개가 출력된다. 즉, 넣은 숫자 개수만큼 출력한다.print_numbers(10)10print_numbers(10, 20, 30, 40)10203040리스트(튜플)언패킹을 사용해도 된다. 다음과 같이 숫자가 들어있는 리스트를 만들고 앞에 *를 붙여서 넣어보면 리스트에 들어있는 값이 그대로 출력된다. 즉, 리스트 x는 [10]이므로 print_numbers(*x)로 호출하면 print_numbers(10)과 같고 리스트 y는 [10, 20, 30, 40]이므로 print_numbers(10, 20, 30, 40)과 같다.x = [10]print_numbers(*x)10y = [10, 20, 30, 40]print_numbers(*y)10203040고정 인수와 가변 인수를 함께 사용하기고정 인수와 가변 인수를 함께 사용할 때는 다음과 같이 고정 매개변수를 먼저 지정하고, 그 다음 매개변수에 를 붙여주면 된다. 단, 이때 def print_numbers(args, a):처럼 *args가 고정 매개변수보다 앞쪽에 오면 안된다. 매개변수 순서에서 *args는 반드시 가장 뒤쪽에 와야 한다.def print_numbers(a, *args):     print(a)     print(args)print_numbers(1)1()print_numbers(1, 10, 20)1(10, 20)print_numbers(*[10, 20, 30])10(20, 30)2. 키워드 인수 사용하기지금까지 함수에 인수를 넣을 때 값이나 변수를 그대로 넣었다. 그러다 보니 각각의 인수가 무슨 용도인지 알기 어려웠다. 보통은 함수의 사용 방법을 익힐 때 인수의 순서와 용도를 함께 외운다. 예를 들어 개인정보를 출력하는 함수를 만들어 보자. 이 함수를 사용할 때는 첫 번째 인수에 이름(name), 두 번째 인수에 나이( age), 세 번째 인수에 주소(address)를 넣어야 한다. 만약 인수의 순서가 달라지면 잘못된 결과가 출력될것이다.def personal_info(name, age, address):     print('이름: ', name)     print('나이: ', age)     print('주소: ', address)personal_info('홍길동', 30, '서울시 용산구 이촌동')이름:  홍길동나이:  30주소:  서울시 용산구 이촌동이처럼 인수의 순서와 용도를 모두 기억해야 해서 불편하다. 그래서 파이썬에서는 인수의 순서와 용도를 매번 기억하지 않도록 키워드 인수(keyword argument)라는 기능을 제공한다. 키워드 인수는 말 그대로 인수에 이름(키워드)을 붙이는 기능인데 키워드 = 값 형식으로 사용한다.  함수(키워드=값)그럼 personal_info 함수를 키워드 인수 방식으로 호출해보자.personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')이름:  홍길동나이:  30주소:  서울시 용산구 이촌동위에처럼 키워드 인수를 사용하니 함수를 호출할 때 인수의 용도가 명확하게 보인다. 특히 키워드 인수를 사용하면 인수의 순서를 맞추지 않아도 키워드에 해당하는 값이 들어간다. personal_info 함수는 이름, 나이, 주소 순으로 인수를 넣어야 하지만, 키워드 인수를 사용해서 순서를 지키지 않고 값을 넣었다. 참고로 print 함수에서 사용했던 sep, end도 키워드 인수이다.personal_info(age=30, address='서울시 용산구 이촌동', name='홍길동')이름:  홍길동나이:  30주소:  서울시 용산구 이촌동print(10, 20, 30, sep=':', end='')3. 키워드 인수와 딕셔너리 언패킹 사용하기딕셔너리를 사용해서 키워드 인수로 값을 넣는 딕셔너리 언패킹을 사용해보자. 다음과 같이 딕셔너리 앞에 **를 붙여서 함수에 넣어준다.  함수(**딕셔너리)먼저 personal_info 함수를 만든다.def personal_info(name, age, address):     print('이름: ', name)     print('나이: ', age)     print('주소: ', address)딕셔너리에 ‘키워드 : 값’ 형식으로 인수를 저장하고, 앞에 **를 붙여서 함수에 넣어준다. 이때 딕셔너리의 키워드(키)는 반드시 문자열 형태여야 한다.x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}personal_info(**x)이름:  홍길동나이:  30주소:  서울시 용산구 이촌동**x처럼 딕셔너리를 언패킹하면 딕셔너리의 값들이 함수의 인수로 들어간다. 즉, personal_info(name=’홍길동’, age=30, address=’서울시 용산구 이촌동’) 또는 personal_info(‘홍길동’, 30, ‘서울시 용산구 이촌동’)과 똑같은 동작이 된다.딕셔너리 변수 대신 딕셔너리 바로 앞에 **를 붙여도 동작은 같다. 딕셔너리 언패킹을 사용할 때는 함수의 매개변수 이름과 딕셔너리의 키 이름이 같아야 한다. 또한, 매개변수 개수와 딕셔너리 키의 개수도 같아야 한다.personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'})이름:  홍길동나이:  30주소:  서울시 용산구 이촌동만약 이름과 개수가 다르면 함수를 호출할 수 없다.  함수를 def personal_info(name, age, address):로 만들었으므로 딕셔너리도 똑같이 맞춰주어야한다. 다음과 같이 매개변수 이름, 개수가 다른 딕셔너리를 넣으면 에러가 발생한다.personal_info(**{'name': '홍길동', 'old': 30, 'address':'서울시 용산구 이촌동'})Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: personal_info() got an unexpected keyword argument 'old'personal_info(**{'name': '홍길동', 'age': 30})Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: personal_info() missing 1 required positional argument: 'address'**를 두 번 사용하는 이유딕셔너리는 키-값 쌍형태로 값이 저장되어 있기때문에 **를 두번 사용한다. *를 한번만 사용해서 함수를 호출하면 아래와 같은 결과가 나온다.def personal_info(name, age, address):     print('이름: ', name)     print('나이: ', age)     print('주소: ', address)x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}personal_info(*x)이름:  name나이:  age주소:  addresspersonal_info에 *x를 넣으면 x의 키가 출력됩니다. 즉, 딕셔너리를 한 번 언패킹하면 키를 사용한다는 뜻이 된다. 따라서 **처럼 딕셔너리를 두 번 언패킹하여 값을 사용하도록 만들어야 한다.x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}personal_info(**x)이름:  홍길동나이:  30주소:  서울시 용산구 이촌동키워드 인수를 사용하는 가변 인수 함수 만들기이번에는 키워드 인수를 사용하는 가변 인수 함수를 만들어보자. 다음과 같이 키워드 인수를 사용하는 가변 인수 함수는 매개변수 앞에 **를 붙여서 만든다.def 함수이름(**매개변수):    코드이제 값 여러 개를 받아서 매개 변수 이름과 값을 각 줄에 출력하는 함수를 만들어보자.함수를 만들 때 괄호 안에 **kwargs와 같이 매개변수 앞에 **를 붙인다. 함수 안에서는 for로 kwargs.items()를 반복하면서 print로 값을 출력한다. 매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 keyword arguments를 줄여서 kwargs로 사용한다. 특히 이 kwargs는 딕셔너리라서 for로 반복할 수 있다.def personal_info(**kwargs):     for kw, arg in kwargs.items():         print(kw, ': ', arg, sep='')personal_info 함수에 키워드와 값을 넣어서 실행해보자. 값을 한 개 넣어도 되고, 세 개 넣어도 된다.personal_info(name='홍길동')name: 홍길동personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')name: 홍길동age: 30address: 서울시 용산구 이촌동)위에처럼 인수를 직접 넣어도 되고, 딕셔너리 언패킹을 사용해도 된다. 다음과 같이 딕셔너리를 만들고 앞에 **를 붙여서 넣어보면 딕셔너리에 있는 값들이 그대로 출력된다. 즉, 딕셔너리 x는 {‘name’: ‘홍길동’}이므로 personal_info(**x)로 호출하면 personal_info(name=’홍길동’)과 같고, 딕셔너리 y는 {‘name’: ‘홍길동’, ‘age’: 30, ‘address’: ‘서울시 용산구 이촌동’}이므로 personal_info(name=’홍길동’, age=30, address=’서울시 용산구 이촌동’)과 같다.x = {'name': '홍길동'}personal_info(**x)name: 홍길동y = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}personal_info(**y)name: 홍길동age: 30address: 서울시 용산구 이촌동이처럼 함수를 만들 때 def personal_info(**kwargs):와 같이 매개변수에 **를 붙여주면 키워드 인수를 사용하는 가변 인수 함수를 만들 수 있다. 그리고 이런 함수를 호출할 때는 키워드와 인수를 각각 넣거나 딕셔너리 언패킹을 사용하면 된다. 보통 **kwargs를 사용한 가변 인수 함수는 다음과 같이 함수 안에서 특정 키가 있는지 확인한 뒤 해당 기능을 만든다.def personal_info(**kwargs):    if 'name' in kwargs:    # in으로 딕셔너리 안에 특정 키가 있는지 확인        print('이름: ', kwargs['name'])    if 'age' in kwargs:        print('나이: ', kwargs['age'])    if 'address' in kwargs:        print('주소: ', kwargs['address'])고정 인수와 가변 인수(키워드 인수)를 함께 사용하기고정인수와 가변인수를 함께 사용 하려면 다음과 같이 고정 매개변수를 먼저 지정하고, 그 다음 매개변수에 를 붙여주면 된다. 단, 이때 def personal_info(kwargs, name):처럼 **kwargs가 고정 매개변수보다 앞쪽에 오면 안된다. 매개변수 순서에서 **kwargs는 반드시 가장 뒤쪽에 와야 한다.def personal_info(name, **kwargs):     print(name)     print(kwargs)personal_info('홍길동')홍길동{}personal_info('홍길동', age=30, address='서울시 용산구 이촌동')홍길동{'age': 30, 'address': '서울시 용산구 이촌동'}personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'})홍길동{'age': 30, 'address': '서울시 용산구 이촌동'}위치 인수와 키워드 인수를 함께 사용하기함수에서 위치인수를 받는 *args와 키워드 인수를 받는 kwargs를 함께 사용하려면 다음과 같이 함수의 매개변수를 *args, **kwargs로 지정하여 위치 인수와 키워드 인수를 함께 사용할수 있다.대표적인 함수가 print인데 print는 출력할 값을 위치 인수로 넣고 sep, end 등을 키워드 인수로 넣는다. 고정인수와 마찬가지로  def custom_print(kwargs, *args):처럼 **kwargs가 *args보다 앞쪽에 오면 안된다. 매개변수 순서에서 **kwargs는 반드시 가장 뒤쪽에 와야 한다. 특히 고정 매개변수와 *args, **kwargs를 함께 사용한다면 def custom_print(a, b, *args, **kwargs):처럼 매개변수는 고정 매개변수, *args, **kwargs 순으로 지정해야 한다.&gt;&gt;&gt; def custom_print(*args, **kwargs):     print(*args, **kwargs)&gt;&gt;&gt; custom_print(1, 2, 3, sep=':', end='')1:2:34. 매개변수에 초깃값 지정하기지금까지 함수를 호출할때 인수를 넣어 값을 전달했다. 그러면 인수를 생략할 수는 없을까? 이때는 함수의 매개변수에 초깃값을 지정하면 된다. 초깃값은 다음과 같이 함수를 만들때 매개변수=값 형식으로 지정한다.def 함수이름(매개변수=값):    코드매개변수의 초깃값은 주로 사용하는 값이 있으면서 가끔 다른 값을 사용해야 할 떄 활용한다. 대표적 예가 print 함수인데, print함수의 sep는 초깃값이 ‘ ‘(공백)으로 지정되어 있어서 대부분 그대로 사용하고 가끔 sep에 다른 값을 넣어서 사용한다.이제 personal_info 함수에서 매개변수 address의 초깃값을 ‘비공개’로 지정해보자.def personal_info(**kwargs):    if 'name' in kwargs:    # in으로 딕셔너리 안에 특정 키가 있는지 확인        print('이름: ', kwargs['name'])    if 'age' in kwargs:        print('나이: ', kwargs['age'])    if 'address' in kwargs:        print('주소: ', kwargs['address'])def personal_info(name, age, address='비공개'):     print('이름: ', name)     print('나이: ', age)     print('주소: ', address)   address는 초깃값이 있으므로 personal_info는 다음과 같이 address부분을 비워 두고 호출할 수 있다.personal_info('홍길동', 30)이름:  홍길동나이:  30주소:  비공개매개변수에 초깃값이 있더라도 값을 넣으면 해당 값이 전달된다.personal_info('홍길동', 30, '서울시 용산구 이촌동')이름:  홍길동나이:  30주소:  서울시 용산구 이촌동초깃값이 지정된 매개변수의 위치매개변수의 초깃값을 지정할때는 초깃값이 지정된 매개변수 다음에는 초깃값이 없는 매개변수가 올 수 없다. ersonal_info 함수에서 address가 가장 마지막 매개변수였는데 이번에는 address를 두 번째 매개변수로 만들고, 그 다음에 초깃값을 지정하지 않은 age가 오도록 만들면 에러가 발생한다. 그이유는 personal_info(‘홍길동’, 30)으로 함수를 호출했을 때 30이 어디로 들어가야 할지 알 수가 없기 떄문이다. address에 들어가려니 age부분이 비어 버린다. 잘못된 문법이므로 이렇게 만들면 안된다.def personal_info(name, address='비공개', age):     print('이름: ', name)     print('나이: ', age)     print('주소: ', address)  File \"&lt;stdin&gt;\", line 1SyntaxError: non-default argument follows default argument즉, 다음과 같이 초깃값이 지정된 매개변수는 뒤쪽에 몰아주면 된다.def personal_info(name, age, address='비공개'):def personal_info(name, age=0, address='비공개'):def personal_info(name='비공개', age=0, address='비공개'):따라서 return 1, 2는 return (1, 2)와 의미가 같다. def personal_info(name=’비공개’, age=0, address=’비공개’):와 같이 모든 매개변수에 초깃값을 지정하면 personal_info()처럼 인수를 넣지 않고 호출할 수 있습니다.def one_two():    return 1, 2    # return (1, 2)와 같음예제표준 입력으로 국어, 영어, 수학, 과학 점수가 입력됩니다. 다음 소스 코드를 완성하여 가장 높은 점수, 가장 낮은 점수, 평균 점수가 출력되게 만드세요. 평균 점수는 실수로 출력되어야 합니다.korean, english, mathematics, science = map(int, input().split())________________________________________________________________min_score, max_score = get_min_max_score(korean, english, mathematics, science)average_score = get_average(korean=korean, english=english,                            mathematics=mathematics, science=science)print('낮은 점수: {0:.2f}, 높은 점수: {1:.2f}, 평균 점수: {2:.2f}'      .format(min_score, max_score, average_score)) min_score, max_score = get_min_max_score(english, science)average_score = get_average(english=english, science=science)print('낮은 점수: {0:.2f}, 높은 점수: {1:.2f}, 평균 점수: {2:.2f}'      .format(min_score, max_score, average_score))#입력76 82 89 84#결과낮은 점수: 76.00, 높은 점수: 89.00, 평균 점수: 82.75낮은 점수: 82.00, 높은 점수: 84.00, 평균 점수: 83.0#입력89 92 73 83#결과낮은 점수: 73.00, 높은 점수: 92.00, 평균 점수: 84.25낮은 점수: 83.00, 높은 점수: 92.00, 평균 점수: 87.50답def get_min_max_score(*args):    return min(args), max(args)     def get_average(**kwargs):    average = sum(kwargs.values())/len(kwargs) #dict.values() 딕셔너리의 모든 값을 가져온다.    return average",
        "url": "/python-basic28"
    }
    ,
    
    "python-basic27": {
        "title": "Python - Python 함수 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기함수 사용하기파이썬은 함수라는 기능을 제공해 특정 용도의 코드를 한 곳에 모아 사용할 수 있다. 필요한 함수를 작성해 놓고 필요할 때 불러서 사용하게 되어있다. 지금까지 사용한 print, input등도 모두 파이썬에서 미리 만들어둔 함수이다.  코드의 용도를 구분할 수 있다.  코드를 재사용할 수 있다.  실수를 줄일 수 있다.1. Hello, world! 출력 함수 만들기함수는 def에 함수를 지정하고 ()와 :을 붙인 뒤 다음 줄에 사용하고자 하는 코드를 작성한다.함수의 이름 짓는 방법은 변수와 같고 이때 코드를 반드시 들여쓰기를 해야한다.(def = define)def 함수이름():     코드함수 만들기‘Hello, world!’를 출력하는 함수를 만들어보자.def hello():     print('Hello, world!')함수 호출하기위에서 만든 함수를 이름과  ()를 적어 호출할 수 있다. 이렇게 함수를 사용하는 방법을 “함수를 호출(call)한다”라고 부른다.hello()Hello, world!소스 파일에서 함수를 만들고 호출하기이번에는 소스 파일에서 함수를 만들고 호출해보자. 다음 내용을 IDLE의 소스 코드 편집창에서 입력한 뒤 실행해 보자. F5를 눌러 실행하면 hello함수가 호출되어 ‘Hello, world!’가 출력된다.def hello():    print('Hello, world!') hello()'Hello, world!'함수의 실행 순서hello 함수는 다음과 같은 순서로 실행된다.  파이썬 스크립트 최초 실행  hello 함수 호출  hello 함수 실행  print 함수 실행 및 ‘Hello, world!’ 출력  hello 함수 종료  파이썬 스크립트 종료함수 작성과 함수 호출 순서함수를 만들고 호출할 때 주의할 점이 있는데, 바로 함수를 만들기 전에 함수를 먼저 호출하면 안된다는 것이다. 즉, 다음과 같이 함수를 먼저 호출한 뒤 함수를 만들순 없다. 함수를 먼저 호출하게 되면 정의가 되지 않았다는 에러가 발생한다.hello()         # hello 함수를 만들기 전에 함수를 먼저 호출 def hello():    # hello 함수를 만듦    print('Hello, world!')#결과Traceback (most recent call last):  File \"C:\\project\\function.py\", line 1, in &lt;module&gt;    hello()    # hello 함수를 만들기 전에 함수를 먼저 호출NameError: name 'hello' is not defined 빈 함수 만들기내용이 없는 빈 함수를 만들 때는 코드 부분에 pass를 넣어준다. 나중에 다른 사람이 만든 파이썬 소스 코드를 보다 보면 pass를 자주 접할 수 있다. pass는 아무 일을 하지 않아도 함수의 틀을 유지할 필요가 있을 때 사용한다.def somedef():    pass2. 덧셈 함수 만들기hello 함수는 동작이 고정되어 있었다. 이번에는 함수에 값을 넣어서 실행환경에 따라 동작을 바꾸어 보자. 함수에서 값을 받으려면 ()안에 변수 이름을 지정해주면 된다. 특히 이 변수를 매개변수(parameter)라고 부른다.def 함수이름(매개변수1, 매개변수2):    코드이제 두 수를 더하는 함수를 만들어 보자. 매개변수 a와 b를 지정하고, 그다음 줄에서 print로 a와b의 합을 출력한다.def add(a, b):    print(a + b)함수 add에 10 과 20을 넣어 출력해 보자. 여기서 함수를 호출할 때 넣는 값을 인수(argument)라고 부른다. 즉, add(10, 20)에서 10과 20이 인수이다.add(10, 20):# 출력30함수 독스트링 사용하기파이썬에서 함수의 :(콜론)바로 다음 줄에 “”” “”“(큰따옴표 세개)로 문자열을 입력하면 함수에 대한 설명을 넣을 수 있다. 이런 방식의 문자열을 독스트링 (문서화 문자열, documentation strings, docstrings)이라고 한다. 단 독스트링 윗줄에 다른 코드가 오면 안된다.def 함수이름(매개변수):    \"\"\"독스트링\"\"\"    코드 def 함수이름(매개변수):    \"\"\"    여러 줄로 된     독스트링    \"\"\"    코드독스트링은 ‘ ‘(작은따옴표), “ “(큰따옴표), ‘’’ ‘’‘(작은따옴표 세 개)로 만들어도 되지만, 파이썬 코딩 스타일 가이드(PEP 8)에서는 “”” “”“(큰따옴표 세 개)를 권장한다.def add(a, b):    \"\"\"이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다.\"\"\"    return a + b x = add(10, 20)       # 함수를 호출해도 독스트링은 출력되지 않음print(x) print(add.__doc__)    # 함수의 __doc__로 독스트링 출력# 실행 결과30이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다.독스트링은 함수의 사용 방법만 기록할 뿐 add(10, 20)으로 함수를 호출해도 출력되지 않는다. 독스트링을 출력하려면 print(add.doc)와 같이 함수의 __doc__을 출력하면 된다.다음과 같이 help에 함수를 넣으면 함수의 이름, 매개변수, 독스트링을 도움말 형태로 출력해준다.help(add) # 입력(출력)Help on function add in module __main__: add(a, b)    이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다.3. 함수의 결과를 반환하기앞에서 만든 add함수는 두 수를 더해서 바로 출력했다. return을 사용하면 값을 함수 바깥으로 반환한다.def 함수이름(매개변수):    return 반환값그럼 두 수를 더해서 반환하는 add 함수를 만들어보자. 함수 add에 매개변수 a와 b를 지정하고 그다음 줄에서 return으로 a와 b를 더한 값을 반환하도록 만든다.def add(a, b):    return a + b이제 add함수에 10과 20을 넣고 결과를 x에 저장한다. 그리고 x의 값을 출력한다. x의 값을 출력해보면 10과 20을 더한 값인 30이 나온다. 이처럼 return을 사용하면 값을 함수 바깥으로 반환한할 수 있고, 함수에서 나온 값을 변수에 저장할 수 있다.x = add(10, 20)x30반환값은 변수에 저장하지 않고 바로 다른 함수에 넣을 수도 있다. 다음은 print에서 바로 add를 호출하여 결과를 확인한다.print(add(10, 20))30매개변수는 없고 반환값만 있는 함수함수를 만들 때 매개변수는 없지만 값만 반환하는 함수를 만들 수도 있다. 다음은 매개변수 없이 1만 반환한다.def one():     return 1x = one()x1return으로 함수 중간에서 빠져나오기return은 값을 반환하는 기능뿐만 아니라 함수 중간에서 바로 빠져나오는 기능도 있다. 다음은 매개변수 a가 10이면 함수를 그냥 빠져나온다. not_ten 함수에 5를 넣으면 print로 ‘5입니다.’를 출력하지만, 10을 넣으면 return으로 함수 중간에서 바로 빠져나오므로 그 아래에 있는 print는 실행하지 않는다. 따라서 아무것도 출력되지 않는다.def not_ten(a):    if a == 10:        return    print(a, '입니다', sep='')not_ten(5)#5입니다not_ten(10)#return은 함수 중간에서 빠져나올 때 자주 사용한다. 보통은 if와 조합해서 특정 조건일 때 함수 중간에서 빠져나온다.4. 함수에서 값을 여러 개 반환하기지금까지 함수의 결과를 변수에 저장할 때 값을 한 개만 저장했다. 이번에는 함수에서 값을 여러 개 반환하는 방법을 알아보자. 값을 여러 개 반환할 때는 다음과 같이 return에 값이나 변수를 ,(콤마)로 구분해서 지정하면 된다.def 함수이름(매개변수):    return 반환값1, 반환값2두 수를 더한 값과 뺀 값을 반환하는 함수를 만들어 보자. 다음과 같이 return으로 a와 b를 더한 값과 a에서 b를 뺀 값을 반환하도록 만들었다.def add_sub(a, b):    return a + b, a - b이제 add_sub 함수에 10과 20을 넣고 결과를 x와 y에 저장한다. 그리고 x와 y의 값을 출력해보자. x의 값을 출력해보면 10과 20을 더한 값인 30이 나오고, y의 값을 출력해보면 10에서 20을 뺀 값인 -10이 나온다. 이처럼 return은 값을 여러 개 반환할 수 있다.x, y = add_sub(10, 20)x30y-10이렇게 return으로 값을 여러 개 반환하면 실제로는 튜플이 반환된다. 다음과 같이 add_sub의 결과를 변수 한 개에 저장해서 출력해보면 튜플이 반환되는 것을 볼 수 있다.x = add_sub(10, 20)x(30, -10)즉, 튜플이 변수 어러 개에 할당되는 특성을 이용한 것이다.(언패킹)x, y = (30, -10)x30y-10값 여러 개를 직접 반환하기함수에서 값 여러 개를 직접 반환할 때는 다음과 같이 return에 튜플을 지정해주면 된다.def one_two():    return (1, 2)사실 파이썬에서는 괄호 없이 콤마로 구분하면 튜플이 된다. 즉, 튜플 1, 2는 튜플 (1, 2)와 같다.1, 2(1, 2)따라서 return 1, 2는 return (1, 2)와 의미가 같다.def one_two():    return 1, 2    # return (1, 2)와 같음물론 return에서 리스트를 직접 반환해도 된다. 이때도 반환값을 변수 여러 개에 저장할 수 있다.def one_two():     return [1, 2]x, y = one_two()print(x, y)1 25. 함수의 호출 과정 알아보기함수 여러 개를 만든 뒤에 각 함수의 호출 과정을 스택 다이어그램(stack diagram)으로 알아보자. 스택은 접시 쌓기와 같은데 접시를 차곡차곡 꺼낼 때는 위쪽부터 차례대로 꺼내는 방식이다. 파이썬에서는 접시 쌓기와 방향이 반대인데, 함수가 아래쪽 방향으로 추가되고 함수가 끝나면 위쪽 방향으로 사라집니다. 다음은 덧셈 함수 add와 곱셈 함수 mul이 있고, add 함수 안에서 mul 함수를 호출하는 방식으로 만들어져 있다.def mul(a, b): #1    c = a * b #2    return c #3 def add(a, b): #5    c = a + b #6    print(c) #7    d = mul(a, b) #8    print(d) #9 x = 10 #11y = 20 #12add(x, y) #13#실행 결과30200파이썬 스크립트를 실행하면 줄 1부터 12까지 실행 하면서 전역프레임 에는 함수 mul,add 변수 x, y가 들어간다(함수 mul, add는 생성만 되었을 뿐 호출이 되지 않은 상태이다).            global frame      parameter                  mul      mul(a, b)              add      add(a, b)              x      10              y      20      프레임이란 메모리에서 함수와 함수에 속한 변수가 저장되는 독립적인 공간이다. 특히 전역 프레임은 파이썬 스크립트 전체에서 접근할 수 있어서 전역 프레임이라 부른다.이제 함수 add를 호출한 뒤 안으로 들어가서 줄 7 print(c)까지 실행하면 다음과 같은 모양이 된다. 즉, 함수 add의 스택 프레임이 만들어지고 매개변수 a와 b 그리고 c가 들어간다.            global frame      parameter                  mul      mul(a, b)              add      add(a, b)              x      10              y      20                  add                         a      10              b      20              c      30      여기서 함수 mul을 호출한 뒤 안으로 들어가서 줄 3return c 까지 실행하면 함수 mul의 스택 프레임이 만들어지고 매개변수 a와 b그리고 변수 c가 들어간다.            global frame      parameter                  mul      mul(a, b)              add      add(a, b)              x      10              y      20                  add                         a      10              b      20              c      30                  mul                         a      10              b      20              c      200      이제 줄 9 print(d)까지 실행해서 함수 mul을 끝내고 함수 add로 되돌아 간다. 이렇게 하면 mul에서 반환한 반환값 200이 변수 d에 저장되며 add의 스택 프레임에 들어간다. 물론 mul은 끝났으므로 스택 프레임도 사라진다.            global frame      parameter                  mul      mul(a, b)              add      add(a, b)              x      10              y      20                  add                         a      10              b      20              c      30              d      200      그다음 줄 13 add(x, y)까지 실행해서 함수 add를 끝낸다. 이렇게 하면 add의 스택 프레임도 사라진다.            global frame      parameter                  mul      mul(a, b)              add      add(a, b)              x      10              y      20      위 과정처럼 함수는 스택(stack)방식으로 호출된다. 즉, 함수를 호출하면 스택의 아래쪽 방향으로 함수가 추가되고 함수가 끝나면 위쪽 방향으로 사라진다. 특히 프레임은 스택 안에 이썽서 각 프레임을 스택 프레임이라고 부른다. 참고로 전역 프레임은 스크립트 파일의 실행이 끝나면 사라진다.예제표준 입력으로 숫자 두 개가 입력됩니다. 다음 소스 코드를 완성하여 두 숫자의 덧셈, 뺄셈, 곱셈, 나눗셈의 결과가 출력되게 만드세요. 이때 나눗셈의 결과는 실수라야 합니다.x, y = map(int, input().split())________________________________a, s, m, d = calc(x, y)print('덧셈: {0}, 뺄셈: {1}, 곱셈: {2}, 나눗셈: {3}'.format(a, s, m, d))#입력10 20#표준출력덧셈: 30, 뺄셈: -10, 곱셈: 200, 나눗셈: 0.5#입력40 8#표준출력덧셈: 48, 뺄셈: 32, 곱셈: 320, 나눗셈: 5.0답def calc(x,y):    return x+y, x-y, x*y, float(x/y)",
        "url": "/python-basic27"
    }
    ,
    
    "python-basic26": {
        "title": "Python - Python 회문 판별과 N-gram 만들기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기회문 판별과 N-gram 만들기문자열을 응용해 회문을 판별하는 방법과 N-gram을 만드는 방법을 알아보자.회문은 유전자 염기서열 분석에서 많이 쓰고, N-gram은 빅 데이터 분석, 검색 엔진에서 많이 쓰인다. 특히 구글은 책들을 스캔해서 N-gram viewer를 만들었는데 사람들의 언어 패턴을 시대별로 분석하기도 했다.1. 파일에 문자열 쓰기, 읽기회문 판별하기회문(palindrome)은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다. 예를 들면 “level”, “SOS”, “rotator”, “nurses run”과 같은 단어와 문장이 있다.반복문으로 문자 검사하기이제 반복문으로 문자열의 각 문자를 검사해보자. 여기서 가장 중요한 부분은 문자열(단어)의 길이이다. 회문 판별은 문자열의 길이를 기준으로 하기 때문에 문자열을 절반으로 나누어서 왼쪽 문자와 오른쪽 문자가 같은지 판별해야한다. 그리고 if 판별문에서 첫번쨰 글자와 마지막 글자를 비교해준다. 마지막 글자는 -1을 넣어 인덱스 0일때 마지막의 첫번째 글자인 인덱스 -1의 글자를 비교하게 만들었다. word[-(1 + i)]와 같이 숫자를 i만큼 증가시킨 뒤 음수로 바꾸는 방식으로도 표현할 수 있다.word = input('단어를 입력하세요: ') is_palindrome = True                 # 회문 판별값을 저장할 변수, 초깃값은 Truefor i in range(len(word) // 2):      # 0부터 문자열 길이의 절반만큼 반복    if word[i] != word[-1 - i]:      # 왼쪽 문자와 오른쪽 문자를 비교하여 문자가 다르면        is_palindrome = False        # 회문이 아님        break print(is_palindrome)                 # 회문 판별값 출력# 실행결과단어를 입력하세요: level (입력)True# 실행결과단어를 입력하세요: hello (입력)False시퀀스 뒤집기로 문자 검사하기문자열을 반대로 뒤집어 판별할 수 있다. 객체 슬라이스를 활용해 간단하게 판별해 보자. word[::-1]은 문자열 전체에서 인덱스를 1씩 감소시키면서 요소를 가져오므로 문자열을 반대로 뒤집는다. 회문은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 문자열이므로 원래 문자열 word와 뒤집은 문자열 word[::-1]이 같으면 회문이다.word = input('단어를 입력하세요: ') print(word == word[::-1])    # 원래 문자열과 반대로 뒤집은 문자열을 비교#실행결과단어를 입력하세요: level (입력)True단어를 입력하세요: hello (입력)False리스트와 reversed 사용하기다음과 같이 반복 가능한 객체의 요소 순서를 반대로 뒤집는 reversed를 사용해도 된다. list에 문자열을 넣으면 문자 하나 하나가 리스트의 요소로 들어간다. 여기서 reversed로 문자열을 반대로 뒤집어서 list에 넣어 두 리스트를 ==로 비교하면 회문판별이 가능하다.word = 'level'list(word) == list(reversed(word)) #reversed는 새로운 객체를 만들어 반환한다.Truelist(word)['l', 'e', 'v', 'e', 'l']list(reversed(word))['l', 'e', 'v', 'e', 'l']문자열의 join 메서드와 reversed 사용하기문자열의 join메서드를 사용해서 회문을 판별할 수 있다. join은 구분자 문자열과 문자열 리스트의 요소를 연결한다. 여기서는 빈 문자열’‘에 reversed(word)의 요소를 연결했으므로 문자 순서가 반대로 된 문자열을 얻을 수 있다. 즉,  join은 요소 사이에 구분자를 넣지만 빈문자열 ‘‘을 활용하여 각문자를 그대로 연결하는 방식이다.&gt;&gt;&gt; word = 'level'&gt;&gt;&gt; word == ''.join(reversed(word))True&gt;&gt;&gt; word'level'&gt;&gt;&gt; ''.join(reversed(word))'level'2. N-gram 만들기N-gram은 문자열에서 N개의 연속된 요소를 추출하는 방법이다. 만약 ‘Hello’라는 문자열을 문자(글자) 단위 2-gram으로 추출하면 다음과 같이 된다. 즉, 문자열의 처음부터 문자열 끝까지 한 글자씩 이동하면서 2글자를 추출한다. 3-gram은 3글자, 4-gram은 4글자를 추출하게 된다.Heellllo반복문으로 N-gram 출력하기이제 반복문으로 문자 단위 2-gram을 출력해보자. 만약 3-gram이라면 반복 횟수는 range(len(text) - 2))와 같이 되고, 문자열 끝에서 두 글자 앞까지 반복하면 된다. 문자열을 출력할 때는 print(text[i], text[i + 1], text[i + 2], sep=’‘)가 된다. 여기서 문자열의 끝까지 반복하면 text[i + 1], text[i + 2]는 문자열의 범위를 벗어난 접근을 하게 되므로 주의해야 한다.text = 'Hello' for i in range(len(text) - 1):             # 2-gram이므로 문자열의 끝에서 한 글자 앞까지만 반복함 range(4)    print(text[i], text[i + 1], sep='')    # 현재 문자와 그다음 문자 출력     #인덱스 01,12,23,34를 반복글자 단위 N-gram이 있다면 단어 단위 N-gram도 있다. 다음은 문자열을 공백으로 구분하여 단어 단위 2-gram을 출력한다. 예를 들어 ‘this is python script’는 ‘this is’, ‘is python’, ‘python script’가 된다. 단어 단위 2-gram도 간단하다. split을 사용하여 공백을 기준으로 문자열을 분리하여 리스트로 만든다. 그리고 2-gram이므로 words 리스트의 마지막에서 요소 한 개 앞까지만 반복하면서 현재 문자열과 그다음 문자열을 출력하면 된다.text = 'this is python script'words = text.split()                 # 공백을 기준으로 문자열을 분리하여 리스트로 만듦 for i in range(len(words) - 1):      # 2-gram이므로 리스트의 마지막에서 요소 한 개 앞까지만 반복함    print(words[i], words[i + 1])    # 현재 문자열과 그다음 문자열 출력#실행 결과this isis pythonpython scriptzip으로 2-gram 만들기zip함수로 2-gram을 만들수 있다. 지금까지 zip함수는 리스트 두 개를 딕셔너리로 만들 때 사용했는데, zip함수는 반복 가능한 객체의 각 요소를 튜플로 묶어준다.text = 'hello' two_gram = zip(text, text[1:])for i in two_gram:    print(i[0], i[1], sep='')# 실행결과Heellllozip(text, text[1:])은 문자열 text와 text[1:]의 각 요소를 묶어서 튜플로 만든다. text[1:]은 인덱스 1(두 번째 문자)부터 마지막 문자까지 가져온다. 따라서  text와 text[1:]을 zip으로 묶으면 문자 하나가 밀린 상태로 각 문자를 묶게 된다. zip()함수는 반복 가능한 객체의 길이가 다를경우 뒤에 부분은 생략되어 출력된다.text = 'hello'list(zip(text, text[1:]))[('h', 'e'), ('e', 'l'), ('l', 'l'), ('l', 'o')]# 이 리스트를 출력할 때는 for i in two_gram:와 같이 for로 반복하면서 print(i[0], i[1], sep='')로 튜플의 요소를 출력해주면 된다.단어 단위 2-gram도 같은 방법으로 만들면 된다. 문자열을 공백으로 분리하여 리스트로 만드는 것 말고는 앞과 같다.text = 'this is python script'words = text.split()list(zip(words, words[1:]))[('this', 'is'), ('is', 'python'), ('python', 'script')]zip과 리스트 표현식으로 N-gram 만들기N-gram을 만들때 일일이 슬라이스를 넣지않고 리스트 표현식을 사용해 만들어 보자. [text[i:] for i in range(3)]처럼 for로 3번 반복하면서 text[i:]로 리스트를 생성했다. 여기서 for i in range(3)은 0, 1, 2까지 반복하므로 text[i:]는 text[0:], text[1:], text[2:]가 된다. 3-gram에 필요한 슬라이스다. text[0:]은 text와 같으므로 지금까지 zip에 넣었던 모양이다.text = 'hello'[text[i:] for i in range(3)]['hello', 'ello', 'llo']리스트[‘hello’, ‘ello’, ‘llo’]를 zip에 넣어보자. 결과를 보면 원하는 3-gram이 아니다. zip은 반복 가능한 객체 여러 개를 콤마고 구분해서 넣어줘야 한다. 하지만 [‘hello’, ‘ello’, ‘llo’]는 요소가 3개 들어있는 리스트 1개이기 때문이다.list(zip(['hello', 'ello', 'llo']))[('hello',), ('ello',), ('llo',)]zip에 리스트의 각 요소를 콤마로 구분해서 넣어주려면 리스트 앞에 *를 붙여야 한다. 이제 3-gram 리스트가 만들어졌다.list(zip(*['hello', 'ello', 'llo']))[('h', 'e', 'l'), ('e', 'l', 'l'), ('l', 'l', 'o')]물론 리스트 표현식을 바로 zip에 넣어주려면 리스트 표현식 앞에 *를 붙이면 된다.list(zip(*[text[i:] for i in range(3)]))[('h', 'e', 'l'), ('e', 'l', 'l'), ('l', 'l', 'o')]예제단어가 줄 단위로 저장된 words.txt 파일이 주어집니다. words.txt 파일에서 회문인 단어를 각 줄에 출력하는 프로그램을 만드세요. 단어를 출력할 때는 등장한 순서대로 출력해야 합니다. 그리고 파일에서 읽은 단어는 \\n이 붙어있으므로 \\n을 제외한 뒤 회문인지 판단해야 하며 단어를 출력할 때도 \\n이 출력되면 안 됩니다(단어 사이에 줄바꿈이 두 번 일어나면 안 됨).________________________________________________________________________________________________#words.txtapachedecaldidneepnoonreferriver#표준출력didnoonrefer내가 쓴 답with open('words.txt', 'r')as file:    words = file.readlines()    for word in words:        if list(word.strip('\\n')) == list(reversed(word.strip('\\n'))) :            print(word.strip('\\n'))더 좋은 답with open('words.txt', 'r')as file:    words = file.readlines()    for word in words:        word = word.strip('\\n')        if word == word[::-1] :            print(word)",
        "url": "/python-basic26"
    }
    ,
    
    "python-basic25": {
        "title": "Python - Python 파일 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기파일 사용하기파이썬 에서 파일을 사용해 문자열을 읽고 쓰는 방법과 파이썬 객체를 파일에 읽고 쓰는 방법을 알아보자.1. 파일에 문자열 쓰기, 읽기파일에 문자열 쓰기파일에 문자열을 쓸 때는 open함수로 파일을 열어서 파일 객체(file object)를 얻은 뒤에 write메서드를 사용한다.  파일객체 = open(파일이름, 파일모드)  파일객체.write(‘문자열’)  파일객체.close()파일을 사용하기 위해서는 먼저 open함수로 파일을 쓰기모드’w’( write)로 열고 파일에 문자열을 저장한후 파일을 닫고 실행해보면 우리가 지정한 위치에 hello.txt 파일이 저장되어 있을것이다.file = open('hello.txt', 'w')    # hello.txt 파일을 쓰기 모드(w)로 열기. 파일 객체 반환file.write('Hello, world!')      # 파일에 문자열 저장file.close()                     # 파일 객체 닫기파일에 문자열 읽기hello.txt파일의 문자열을 읽어보자. 파일을 읽을때도 open함수로 파일을 열어서 파일 객체를 얻은 뒤 read 메서드로 파일의 내용을 읽는다. 이때는 파일 모드를 읽기모드 ‘r’로 지정한다.  변수 = 파일객체.read()open을 사용해 hello.txt파일을 읽기 모드 ‘r’로 연다. 여기서 ‘r’은 읽다(read)의 r이다. read의 반환값을 변수 s에 지정해주고 파일의 내용을 읽는다.file = open('hello.txt', 'r')    # hello.txt 파일을 읽기 모드(r)로 열기. 파일 객체 반환s = file.read()                  # 파일에서 문자열 읽기print(s)                         # Hello, world!file.close()                     # 파일 객체 닫기그리고 print로 변수의 값을 출력하면 ‘Hello, world!’가 출력된다.# idle 소스코드창 출력Hello, World!s'Hello, World!'자동으로 파일 객체 닫기파이썬 에서는 with as 를 사용하면 파일을 사용한 뒤 자동으로 파일 객체를 닫아준다. 다음과 같이 whith다음에 open으로 파일을 열고 as뒤에 파일 객체를 지정한다.with open(파일이름, 파일모드) as 파일객체:    코드hello.txt파일을 읽어보자.with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기    s = file.read()                     # 파일에서 문자열 읽기    print(s)                            # Hello, world!# idle 소스코드창 출력Hello, world!2. 문자열 여러 줄을 파일에 쓰기, 읽기문자열 여러 줄을 파일에 쓰고 읽는 방법을 알아보자.반복문으로 문자열 여러 줄을 파일에 쓰기반복문을 사용해 문자열 어려 줄을 써보자. 파일에 문자열 어려줄을 저장할 떄는 개행문자를 사용해야한다. ‘Hello, world! {0}\\n’와 같이 문자열 끝에 개행 문자 \\n를 지정해주어야 줄바꿈이 된다. \\n을 붙이지 않으면 문자열이 모두 한 줄로 붙어서 저장됨으로 주의한다.with open('hello.txt', 'w') as file:    # hello.txt 파일을 쓰기 모드(w)로 열기    for i in range(3):        file.write('Hello, world! {0}\\n'.format(i))#hello.txt 의 내용Hello, world! 0Hello, world! 1Hello, world! 2리스트에 들어있는 문자열을 파일에 쓰기리스트에 들어있는 문자열을 파일에 써보자.  파일객체.writelines(문자열리스트)writelines는 리스트에 들어있는 문자열을 파일에 쓴다. 특히 writelines를 사용할 때는 반드시 리스트의 각 문자열 끝에 개행 문자 \\n을 붙여주어야 한다. 그렇지 않으면 문자열이 모두 한 줄로 붙어서 저장되므로 주의해야 한다.lines = ['안녕하세요.\\n', '파이썬\\n', '코딩 도장입니다.\\n'] with open('hello.txt', 'w') as file:    # hello.txt 파일을 쓰기 모드(w)로 열기    file.writelines(lines)#hello.txt 의 내용안녕하세요.파이썬코딩 도장입니다.파일의 내용을 한 줄씩 리스트로 가져오기앞에서 만든 hello.txt파일의 내용을 한 줄씩 읽어보자. read는 파일의 내용을 읽어서 문자열로 가져오지만 readlines는 파일의 내용을 한 줄씩 리스트 형태로 가져온다.  변수 = 파일객체.readlines()with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기    lines = file.readlines()    print(lines)# idle 소스코드창 출력['안녕하세요.\\n', '파이썬\\n', '코딩 도장입니다.\\n']파일의 내용을 한 줄씩 읽기만약 파일의 내용을 한 줄씩 순차적으로 읽으려면 readline을 사용한다.  변수 = 파일객체.readline()readline으로 파일을 읽을 때는 while 반복문을 활용한다. 왜냐면 파일에 문자열이 몇 줄이나 있는지 모르기 때문이다. while은 특정 조건이 만족할 때 계속 반복하므로 파일의 크기에 상관없이 문자열을 읽어올 수 있다. readline은 더 이상 읽을 줄이 없을 때는 빈 문자열을 반환하는데, while에는 이런 특성을 이용하여 조건식을 만들어준다. 즉, line != ‘‘와 같이 빈 문자열이 아닐 때 계속 반복하도록 만든다. 그리고 반복문 안에서는 line = file.readline()과 같이 문자열 한 줄을 읽어서 변수 line에 저장해 준다.with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기    line = None    # 변수 line을 None으로 초기화    while line != '':        line = file.readline()        print(line.strip('\\n'))    # 파일에서 읽어온 문자열에서 \\n 삭제하여 출력# idle 소스코드창 출력안녕하세요.파이썬코딩 도장입니다.특히 변수 line은 while로 반복하기전 None으로 초기화 해준다. 만약 변수 line을 만들지 않고 while을 실행하면 없는 변수와 빈 문자열 ‘‘을 비교하게 되므로 에러가 발생한다. 또는, line을 None이 아닌 ‘‘로 초기화하면 처음부터 line !=’‘는 거짓이 되므로 반복을 하지 않고 코드가 그냥 끝나버린다.파일에서 읽어온 문자열에는 ‘안녕하세요.\\n’와 같이 \\n이 이미 들어있기 때문에 print(line.strip(‘\\n’)와 같이 strip 메서드로 \\n을 삭제해줘야한다. strip(‘\\n’)을 생략하면 문자열 한 줄을 출력할 때마다 빈 줄이 계속 출력된다. 즉, 문자열 안에 든 \\n과 print가 출력하는 \\n 때문에 줄바꿈이 두 번 일어난다.for 반복문으로 파일의 내용을 줄 단위로 읽기파이썬에서는 for 반복문으로 좀 더 간단하게 파일의 내용을 읽을 수 있다. 다음은 for반복문에 파일 객체를 지정하여 줄 단위로 파일의 내용을 읽는다. for line in file:로 간단하게 파일의 내용을 한줄 씩 읽었다. for 반복문에 파일 객체를 지정하면 반복을 할때마다 파일의 내용을 한 줄 씩 읽어 변수에 저장해준다.with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기    for line in file:    # for에 파일 객체를 지정하면 파일의 내용을 한 줄씩 읽어서 변수에 저장함        print(line.strip('\\n'))    # 파일에서 읽어온 문자열에서 \\n 삭제하여 출력# idle 소스코드창 출력안녕하세요.파이썬코딩 도장입니다.파일 객체는 이터레이터파일 객체는 이터레이터입니다. 따라서 변수 여러 개에 저장하는 언패킹(unpacking)도 가능하다.물론 a, b, c = file과 같이 사용하려면 hello.txt에는 문자열 3줄이 들어있어야 한다. 즉, 할당할 변수의 개수와 파일에 저장된 문자열의 줄 수가 일치해야 한다.&gt;&gt;&gt; file = open('hello.txt', 'r')&gt;&gt;&gt; a, b, c = file&gt;&gt;&gt; a, b, c('안녕하세요.\\n', '파이썬\\n', '코딩 도장입니다.\\n')3.파이썬 객체를 파일에 저장하기, 가져오기파일에서 문자열만 읽고 쓴다면 조금 불편할 것이다. 파이썬은 객체를 파일에 저장하는 pickle모듈을 제공한다. 다음과 같이 파이썬 객체를 파일에 저장하는 과정을 피클링(pickling)이라고 하고, 파일에서 객체를 읽어오는 과정을 언피클링(unpickling)이라고 한다.파이썬 객체를 파일에 저장하기파이썬 객체를 파일에 저장하는 피클링을 해보자. 피클링은 pickle 모듈의 dump 메서드를 사용한다.소스 코드를 실행하면 .py파일이 있는 폴더에 jame.p파일이 생성된다. 여기서는 확장자를 pickle의 p를 사용했지만 다른 확장자를 사용해도 상관없다. 특히 pickle.dump로 객체(값)를 저장할 때는 open(‘james.p’, ‘wb’)와 같이 파일 모드를 ‘wb’로 지정해야 한다. b는 바이너리(binary)를 뜻하는데, 바이너리 파일은 컴퓨터가 처리하는 파일 형식이다. 따라서 메모장 같은 텍스트 편집기로 열어도 사람이 알아보기 어렵다.import pickle name = 'james'age = 17address = '서울시 서초구 반포동'scores = {'korean': 90, 'english': 95, 'mathematics': 85, 'science': 82} with open('james.p', 'wb') as file:    # james.p 파일을 바이너리 쓰기 모드(wb)로 열기    pickle.dump(name, file)    pickle.dump(age, file)    pickle.dump(address, file)    pickle.dump(scores, file)파일에서 파이썬 객체 읽기이제 파일에서 파이썬 객체를 읽어오는 언피클링을 해보자. 언피클링은 pickle 모듈의 load를 사용한다. 그리고 언피클링을 할 때는 반드시 파일 모드를 바이너리 읽기 모드 ‘rb’로 지정해야한다. 앞에서 james.p 파일을 저장할 때 pickle.dump를 네 번 사용했다. 마찬가지로 파일에서 객체(값)를 가져올 때도 pickle.load를 네 번 사용해야 한다. 즉, name, age, address, scores 순으로 저장했으므로 가져올 때도 같은 순서로 가져오면 된다.import pickle with open('james.p', 'rb') as file:    # james.p 파일을 바이너리 읽기 모드(rb)로 열기    name = pickle.load(file) #각각의 변수에     age = pickle.load(file)    address = pickle.load(file)    scores = pickle.load(file)    print(name)    print(age)    print(address)    print(scores)# 실행결과james17서울시 서초구 반포동{'korean': 90, 'english': 95, 'mathematics': 85, 'science': 82}다른 파일 모드사실 파일 모드는 조합에 따라 여러 종류가 있다. 읽기 ‘r’, 쓰기 ‘w’ 이외에 추가 ‘a’, 배타적 생성 ‘x’도 있다. 추가 모드는 이미 있는 파일에서 끝에 새로운 내용을 추가할 때 사용하고, 배타적 생성 모드는 파일이 이미 있으면 에러(FileExistsError)를 발생시키고 없으면 파일을 만든다. ‘x’는 베타적 생성(exclusive creation)의 x이다또한, 파일의 형식도 함께 지정할 수 있는데, 텍스트 모드 ‘t’와 바이너리 모드 ‘b’가 있다. 이 파일 형식과 읽기, 쓰기 모드를 조합한 텍스트 모드 ‘rt’, ‘wt’는 파일을 텍스트 모드로 연다. 특히 텍스트 모드는 생략할 수 있어서 그냥 ‘r’, ‘w’도 텍스트 모드이다. 그리고 바이너리 모드 ‘rb’, ‘wb’ 등은 피클링을 사용하거나 바이너리 데이터를 직접 저장할 때 사용한다.그다음에 ‘+’가 있는데 파일을 읽기/쓰기 모드로 연다. 이 모드는 ‘r+t’, ‘w+t’, ‘r+’, ‘w+’, ‘r+b’, ‘w+b’ 등으로 조합할 수 있으며 읽기/쓰기 모드인 것은 같지만 파일 처리 방법이 조금씩 다르다.예제문자열이 저장된 words.txt 파일이 주어집니다(문자열은 한 줄로 저장되어 있습니다). words.txt 파일에서 문자 c가 포함된 단어를 각 줄에 출력하는 프로그램을 만드세요. 단어를 출력할 때는 등장한 순서대로 출력해야 하며 ,(콤마)와 .(점)은 출력하지 않아야 합니다.________________________________________________________________________________#입력Fortunately, however, for the reputation of Asteroid B-612, a Turkish dictator made a law that his subjects, under pain of death, should change to European costume. So in 1920 the astronomer gave his demonstration all over again, dressed with impressive style and elegance. And this time everybody accepted his report.#출력dictatorsubjectschangecostumeeleganceaccepted내가 쓴답(왜 마지막 출력이 두번되는지 모르겠음)with open('words.txt', 'r')as file:    x = file.readline()    y = x.split()    for word in y:        for i in word:            if i == 'c':                print(word.strip(',.'))# 출력dictatorsubjectschangecostumeeleganceacceptedaccepted정답with open('words.txt', 'r')as file:    y = file.readline().split()    for word in y:        if 'c' in word:            print(word.strip(',.'))#출력dictatorsubjectschangecostumeeleganceaccepted",
        "url": "/python-basic25"
    }
    ,
    
    "python-basic24": {
        "title": "Python - Python 세트 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기세트 사용하기파이썬은 집합을 표현하는 세트(set)라는 자료형을 제공한다. 집합을 영어로 하면 세트인데 수학에서 배우는 집합과 같다. 따라서 세트는 합집합, 교집합, 차집합 등의 연산이 가능하다.1. 세트 만들기세트는 {} 안에 값을 저장하며 각 값은 ,(콤마)로 구분한다. 세트는 요소의 순서가 정해져 있지 않다. 따라서 세트를 출력해보면 매번 요소의 순서가 다르게 나온다.  세트 = {값1, 값2, 값3}~~~pythonfruits = {‘strawberry’, ‘grape’, ‘orange’, ‘pineapple’, ‘cherry’}fruits{‘pineapple’, ‘orange’, ‘grape’, ‘strawberry’, ‘cherry’}또한, 세트에 들어가는 요소는 중복될 수 없다. 다음과 같이 세트에 'orange'를 두개 넣어도 하나의 값만 들어간다.~~~pythonfruits = {'orange', 'orange', 'cherry'}fruits{'cherry', 'orange'}세트는 리스트, 튜플, 딕셔너리와 달리 로 특정 요소만 출력할 수 없다.fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}print(fruits[0])Traceback (most recent call last):  File \"&lt;pyshell#42&gt;\", line 1, in &lt;module&gt;    print(fruits[0])TypeError: 'set' object does not support indexingfruits['strawberry']Traceback (most recent call last):  File \"&lt;pyshell#43&gt;\", line 1, in &lt;module&gt;    fruits['strawberry']TypeError: 'set' object is not subscriptable세트에 특정 값이 있는지 확인하기세트에 특정 값이 있는지 확인하려면 in연산자를 사용해야 한다.  값 in 세트세트에 특정값이 있으면 True 없으면 Flase가 나온다. 세트 fruits에 orange가 있으므로 True peach가 없으므로 False가 나왔다.fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}'orange' in fruitsTrue'peach' in fruitsFalse반대로 in앞에 not을 붙이면 특정 값이 없는지 확인한다.'peach' not in fruitsTrue'orange' not in fruitsFalseset를 사용하여 세트 만들기이번에는 set를 사용하여 세트를 만들어 보자.set(반복가능한객체)와 같이 반복가능한 객체를 넣어 세트를 만든다. set(‘apple’)과 같이 영문 문자열을 세트로 만들면 ‘apple’에서 유일한 문자인 a p l e만 세트로 만든다. 중복된 문자는 포함하지 않는다.a = set('apple')    # 유일한 문자만 세트로 만듦a{'e', 'l', 'a', 'p'}set(range(5))와 같이 숫자를 만들어내는 range를 사용하면 0부터 4까지 숫자를 가진 세트를 만들 수 있다.b = set(range(5))b{0, 1, 2, 3, 4}비어있는 세트는 c = set()과 같이 set에 아무것도 지정하지 않으면 된다.c = set()cset()단 세트가 {}를 사용한다고 해서 c = {}와 같이 만들면 빈 딕셔너리가 만들어 짐으로 주의해야한다. 다음과 같이 type을 사용하면 자료형의 구조를 알 수 있다.  type(객체)c = {}type(c)&lt;class 'dict'&gt;c = set()type(c)&lt;class 'set'&gt;한글 문자열을 세트로 만들기set을 사용하여 한글 문자열을 세트로 만들면 다음과 같이 음절 단위로 세트가 만들어진다.set('안녕하세요'){'녕', '요', '안', '세', '하'}세트 안에 세트 넣기세트는 리스트, 튜플, 딕셔너리와 달리 세트안에 세트를 넣을 수 없다.a = {{1, 2}, {3, 4}} Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    a = {{1, 2}, {3, 4}} TypeError: unhashable type: 'set'세트 안에 세트 넣기파이썬은 내용을 변경할 수 없는 세트도 제공한다.프로즌세트 = frozenset(반복가능한객체)frozenset(반복가능한객체)로 말그대로 얼어있는 세트를 만들 수 있다.a = frozenset(range(10))afrozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})frozenset는 뒤에서 설명할 집합 연산과 메서드에서 요소를 추가하거나 삭제하는 연산, 메서드는 사용할 수 없다. 다음과 같이 frozenset의 요소를 변경하려고 하면 에러가 발생한다.a = frozenset(range(10))a |= 10Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    a |= 10TypeError: unsupported operand type(s) for |=: 'frozenset' and 'int'a.update({10})Traceback (most recent call last):  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;    a.update({10})AttributeError: 'frozenset' object has no attribute 'update'frozenset는 세트 안에 세트를 넣고 싶을 때만 사용한다. 다음과 같이 frozenset는 중첩해서 넣을 수 있다. 단 frozenset만 넣을 수 있고, 일반 set는 넣을 수 없다.frozenset({frozenset({1, 2}), frozenset({3, 4})})frozenset({frozenset({1, 2}), frozenset({3, 4})})2. 집합 연산 사용하기세트에서 집합 연산과 이에 대응하는 메서드를 사용해보자. 집합 연산은 파이썬의 산술 연산자와 논리 연산자를 활용한다.            **      **연산자는 합집합(union)을 구하며 OR연산자      를 사용한다. set.union메서드와 작동이 같다. 다음은 세트 {1, 2, 3, 4}와 {3, 4, 5, 6}을 모두 포함하므로 {1, 2, 3, 4, 5, 6}이 나옵니다.                                    세트1          세트2                      set.union(세트1, 세트2)a = {1, 2, 3, 4}b = {3, 4, 5, 6}a | b{1, 2, 3, 4, 5, 6}set.union(a, b){1, 2, 3, 4, 5, 6}&amp;연산자는 교집합(intersection)을 구하며 AND연산자 &amp;를 사용한다. set.intersection메서드와 동작이 같다. 다음은 세트 {1, 2, 3, 4}와 {3, 4, 5, 6} 중에서 겹치는 부분을 구하므로 {3, 4}가 나온다.  세트1 &amp; 세트2  set.intersection(세트1, 세트2)a = {1, 2, 3, 4}b = {3, 4, 5, 6}a &amp; b{3, 4}set.intersection(a, b){3, 4}-연산자는 차집합(difference)을 구하며 뺼셈 연산자 -를 사용한다. set.difference메서드와 동작이 같다. 다음은 {1, 2, 3, 4}에서 {3, 4, 5, 6}과 겹치는 3과 4를 뺐으므로 {1, 2}가 나온다.a = {1, 2, 3, 4}b = {3, 4, 5, 6}a - b{1, 2}set.difference(a, b){1, 2}^연산자는 대칭차집합(symmetric difference)을 구하며 XOR 연산자 ^를 사용한다. set.symmetric_difference 메서드와 동작이 같다. 대칭 차집합은 XOR연산자의 특성을 그대로 따르는데 XOR은 서로 다르면 참이다. 따라서 집합에서 두 집합 중 겹치지 않는 요소만 포함한다. 다음은 세트  {1, 2, 3, 4}와 {3, 4, 5, 6} 중에서 같은 값 3과 4를 제외한 다른 모든 요소를 구하므로 {1, 2, 5, 6}이 나온다.  세트1 ^ 세트2  set.symmetric_difference(세트1, 세트2)a = {1, 2, 3, 4}b = {3, 4, 5, 6}a ^ b{1, 2, 5, 6}set.symmetric_difference(a, b){1, 2, 5, 6}집합 연산 후 할당 연산자 사용하기세트 자료형에 집합 연산 후 할당 연산자와 이에 대응하는 메서드를 사용해보자. 세트 자료형에 |, &amp;, -, ^ 연산자와 할당 연산자 =을 함꼐 사용하면 집합 연산의 결과를 변수에 다시 저장한다.            **      =**은 현재 세트에 다른 세트를 더하며 update 메서드와 같다. 다음은 세트 {1, 2, 3, 4}에 {5}를 더하므로 {1, 2, 3, 4, 5}가 나온다.                                    세트1          = 세트2                      세트1.update(세트2)a = {1, 2, 3, 4}a |= {5}a{1, 2, 3, 4, 5}a = {1, 2, 3, 4}a.update({5})a{1, 2, 3, 4, 5}&amp;=는 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장한다. intersection_update 메서드와 같다. 다음은 세트 {1, 2, 3, 4}와 {0, 1, 2, 3, 4} 중에서 겹치는 요소만 a에 저장하므로 {1, 2, 3, 4}가 나온다.  세트1 &amp;= 세트2  세트1.intersection_update(세트2)a = {1, 2, 3, 4}a &amp;= {0, 1, 2, 3, 4}a{1, 2, 3, 4}a = {1, 2, 3, 4}a.intersection_update({0, 1, 2, 3, 4})a{1, 2, 3, 4}-=는 현재 세트에서 다른 세트를 빼며 difference_update 메서드와 같다. 다음은 세트 {1, 2, 3, 4}에서 {3}을 빼므로 {1, 2, 4}가 나온다.  세트1 -= 세트2  세트1.difference_update(세트2)a = {1, 2, 3, 4}a -= {3}a{1, 2, 4}a = {1, 2, 3, 4}a.difference_update({3})a{1, 2, 4}^=는 현재 세트와 다른 세트중에서 겹치지 않는 요소만 현재 세트에 저장한다.symmetric_difference_update 메서드와 같다. 다음은 세트 {1, 2, 3, 4}와 {3, 4, 5, 6} 중에서 겹치지 않는 요소만 a에 저장하므로 {1, 3}이 나온다.  세트1 ^= 세트2  세트1.symmetric_difference_update(세트2)a = {1, 2, 3, 4}a ^= {3, 4, 5, 6}a{1, 2, 5, 6}a = {1, 2, 3, 4}a.symmetric_difference_update({3, 4, 5, 6})a{1, 2, 5, 6}부분 집합과 상위집합 확인하기세트는 부분집합, 진부분집합, 상위집합, 진상위집합과 같이 속하는 관계를 표현할 수도 있다. 현재 세트가 다른 세트의 (진)부분 집합 또는 (진)상위집합인지 확인할 때는 세트 자료형에 부등호와 등호를 사용한다.&lt;=는 현재 세트가 다른 세트의 부분집합(subset)인지 확인하며 issubset메서드와 같다. 다음은 세트 {1, 2, 3, 4}가 {1, 2, 3, 4}의 부분집합이므로 참이다.(등호가있어 두 세트가 같을 때도 참이다.)  현재세트 &lt;= 다른세트  현재세트.issubset(다른세트)a = {1, 2, 3, 4}a &lt;= {1, 2, 3, 4}Truea.issubset({1, 2, 3, 4, 5})True&gt;=는 현재 세트가 다른 세트의 상위집합(superset)인지 확인하며 issuperset 메서드와 같다. 다음은 세트 {1, 2, 3, 4}가 {1, 2, 3, 4}의 상위집합이므로 참이다(등호가 있으므로 두 세트가 같을 때도 참이다).  현재세트 &gt;= 다른세트  현재세트.issuperset(다른세트)a = {1, 2, 3, 4}a &gt;= {1, 2, 3, 4}Truea.issuperset({1, 2, 3, 4})True&lt;는 현재 세트가 다른 세트의 진부분집합(proper subset)인지 확인하며 메서드는 없다. 다음은 세트 {1, 2, 3, 4}가 {1, 2, 3, 4, 5}의 진부분집합이므로 참이다. 즉, 부분집합이지만 같지는 않을 때 참이다.  현재세트 &lt; 다른세트a = {1, 2, 3, 4}a &lt; {1, 2, 3, 4, 5}True&gt;는 현재 세트가 다른 세트의 진상위집합(proper superset)인지 확인하며 메서드는 없다. 다음은 세트 {1, 2, 3, 4}가 {1, 2, 3}의 진상위집합이므로 참이다. 즉, 상위집합이지만 같지는 않을 때 참이다.  현재세트 &gt; 다른세트a = {1, 2, 3, 4}a &gt; {1, 2, 3}True[집합]!(https://user-images.githubusercontent.com/77658029/124087151-b6ad0100-da8c-11eb-9e33-0ae7406ed92f.png)세트가 같은지 다른지 확인하기세트는 == 연산자를 사용하여 서로 같은지 확인할 수 있다. 세트는 요소의 순서가 정해져 있지 않으므로 ==로 비교했을 때 각 요소만 같으면 참이다.a = {1, 2, 3, 4}a == {1, 2, 3, 4}Truea == {4, 2, 1, 3}True!=연산자는 세트가 다른지 확인한다.a = {1, 2, 3, 4}a != {1, 2, 3}True세트가 같은지 다른지 확인하기disjoint는 현재 세트가 다른 세트와 겹치지 않는지 확인한다. 겹치는 요소가 없으면 True, 있으면 False이다.  현재세트.isdisjoint(다른세트)a = {1, 2, 3, 4}a.isdisjoint({5, 6, 7, 8})       # 겹치는 요소가 없음Truea.isdisjoint({3, 4, 5, 6})    # a와 3, 4가 겹침False3.세트 조작하기세트를 조작하는 메서드와 세트의 길이(요소 개수)를 구하는 방법을 알아보자.세트에 요소 추가하기add(요소)는 세트에 요소를 추가한다.a = {1, 2, 3, 4}a.add(5)a{1, 2, 3, 4, 5}세트에서 특정 요소를 삭제하기remove(요소)는 세트에서 특정 요소를 삭제하고 요소가 없으면 에러를 발생시킨다.a = {1, 2, 3, 4}a.remove(3)a{1, 2, 4, 5}discard(요소)는 세트에서 특정 요소를 삭제하고 요소가 없으면 그냥 넘어간다. 다음은 세트 a에 2가 있으므로 2를 삭제하고, 3은 없으므로 그냥 넘어간다.a = {1, 2, 4, 5}a.discard(2)a{1, 4, 5}a.discard(3)a{1, 4, 5}세트에서 임의의 요소 삭제하기pop()은 세트에서 임의의 요소를 삭제하고 해당 요소를 반환한다. 만약 요소가 없으면 에러를 발생시킨다.a = {1, 2, 3, 4}a.pop()1a{2, 3, 4}세트의 모든 요소를 삭제하기clear()는 세트에서 모든 요소를 삭제한다.a = {1, 2, 3, 4}a.clear()aset()세트의 모든 요소를 삭제하기len(세트)는 세트의 요소 개수 길이를 구한다.a = {1, 2, 3, 4}len(a)44.세트의 할당과 복사세트도 리스트, 튜플, 딕셔너리처럼 할당과 복사의 차이점이 있다. 먼저 세트를 만든 뒤 다른 변수에 할당한다. b = a와 같이 세트를 다른 변수에 할당하면 세트는 두 개가 될 것 같지만 실제로는 세트가 한 개이다.a = {1, 2, 3, 4}b = aa와 b를 is 연산자로 비교해보면 True가 나온다. 즉, 변수 이름만 다를 뿐 세트 a와 b는 같은 객체이다.a is bTruea와 b는 같으므로 b에 요소를 추가하면 세트 a와 b에 모두 반영된다.b.add(5)a{1, 2, 3, 4, 5}b{1, 2, 3, 4, 5}세트 a와 b를 완전히 두 개로 만들려면 copy메서드로 모든 요소를 복사해야 한다.a = {1, 2, 3, 4}b = a.copy()이제 a와 b를 is 연산자로 비교해보면 False가 나온다. 즉, 두 세트는 다른 객체다. 그러나 복사한 요소는 같으므로 ==로 비교하면 True가 나온다.a is bFalsea == bTrue세트 a와 b는 별개이므로 한쪽의 값을 변경해도 다른 세트에 영향을 미치지 않는다. 다음과 같이 세트 b에 요소를 추가하면 세트 a는 그대로이고 세트 b만 바뀐다.a = {1, 2, 3, 4}b = a.copy()b.add(5)a{1, 2, 3, 4}b{1, 2, 3, 4, 5}5.반복문으로 세트의 요소를 모두 출력하기이번에는 세트와 for반복문을 사용하여 요소를 출력해보자. 간단하게 for in 뒤에 세트만 지정하면 된다.for 변수 in 세트:     반복할 코드다음은 for로 세트 a의 요소를 출력한다. for i in a:는 세트 a에서 요소를 꺼내서 i에 저장하고, 꺼낼 때마다 코드를 반복한다. 따라서 print i를 출력하면 요소를 모두 출력할 수 있다. 단, 세트의 요소는 순서가 없으므로 출력할 때마다 순서가 달라진다(숫자로만 이루어진 세트는 순서대로 출력됨).a = {1, 2, 3, 4}for i in a:     print(i)1234# in 다음 세트를 직접 지정해도 상관 없다.for i in {1, 2, 3, 4}:    print(i)6.세트 표현식 사용하기세트는 for 반복문과 if조건문을 사용하여 세트를 생성할 수 있다. 다음과 같이 세트 안에 식과 for반복문을 지정하면 된다.  {식 for 변수 in 반복가능한객체}  set(식 for 변수 in 반복가능한객체){}또는 set()안에 식, for, 변수, in, 반복가능한 객체를 지정하여 세트를 생성한다. 여기서는 반복가능한 객체로 문자열 ‘apple’을 지정했다.a = {i for i in 'apple'}a{'l', 'p', 'e', 'a'}세트 표현식에 if 조건문 사용하기세트 표현식에서 if 조건문을 사용해 보자. 다음과 같이 if 조건문은 for반복문 뒤에 지정한다.  {식 for 변수 in 세트 if 조건식}  set(식 for 변수 in 세트 if 조건식){i for i in ‘pineapple’ if i not in ‘apl’}은 문자열 ‘pineapple’에서 ‘a’, ‘p’, ‘l’을 제외한 문자들로 세트를 생성한다. 즉, 다음과 같이 for 반복문 뒤에 if 조건문을 지정하면 if 조건문에서 특정 요소를 제외한 뒤 세트를 생성한다.a = {i for i in 'pineapple' if i not in 'apl'}a{'e', 'i', 'n'}if i not in ‘apl’은 {i for i in ‘pineapple’ if i != ‘a’ and i != ‘p’ and i != ‘l’}과 같이 문자를 하나씩 비교하고 and로 연결하는 if 조건문과 같다.예제표준 입력으로 양의 정수 두 개가 입력됩니다. 다음 소스 코드를 완성하여 두 숫자의 공약수를 세트 형태로 구하도록 만드세요. 단, 최종 결과는 공약수의 합으로 판단합니다.________________________________________________ divisor = a &amp; b result = 0if type(divisor) == set:    result = sum(divisor) print(result)#입력10 20#결과18#입력100 200#결과217",
        "url": "/python-basic24"
    }
    ,
    
    "python-basic23": {
        "title": "Python - Python 딕셔너리 응용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기딕셔너리 응용하기딕셔너리의 키-값 쌍을 조작하는 메서드 정보를 조회하는 메서드를 사용해보자. 그리고 for 반복문을 사용하여 키와 값에 접근하는 방법, 딕셔너리 표현식, 중첩 딕셔너리를 알아보자.1. 딕셔너리 조작하기딕셔너리를 조작하는 메서드와 정보를 얻는 메서드를 알아보자.딕셔너리에 키-값 쌍 추가하기딕셔너리의 중요한 기능중 하나는 키-값 쌍 추가이다. 두가지 메서드를 사용하는 방법으로 키-값 쌍을 추가할 수 있다.  setdefault: 키-값 쌍 추가  update: 키의 값 수정, 키가 없으면 키-값 쌍 추가딕셔너리에 키와 기본값 저장하기setdefault(키)는 딕셔너리에 키-값 쌍을 추가한다. setdefault에 키만 지정하면 값에 None을 저장한다. 키 ‘e’를 추가하고 값에 None을 저장하는 코드다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('e')x{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': None}키 ‘f’를 추가하고 값에 100을 저장한뒤 100을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('f',100)100x{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'f': 100}딕셔너리에서 키의 값 수정하기update(키=값)는 키-값 쌍을 수정하는 메서드이다. 예를 들어 x = {‘a’ : 10}이라면 x.update(a=90)과 같이 키에서 작은 따옴표 또는 큰따옴표를 빼고 키 이름과 값을 지정한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(a=90)x{'a': 90, 'b': 20, 'c': 30, 'd': 40}만약 딕셔너리에 키가 없으면 키-값 쌍을 추가한다. 딕셔너리 x에는 키 ‘e’가 없기떄문에 x.update(e=50)을 실행하면 ‘e’ : 50을 추가한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(e=50)x{'a': 90, 'b': 20, 'c': 30, 'd': 40, 'e': 50}키-값 쌍 여러 개를 콤마로 구분해서 넣어주면 값을 한꺼번에 수정할 수 있다. 이때도 키가 있으면 해당 키의 값을 수정하고 없으면 키-값 쌍을 추가한다. 다음은 키 ‘a’의 값을 900으로 수정하고 ‘f’:60을 추가한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.update(a=900, f=60)x{'a': 900, 'b': 20, 'c': 30, 'd': 40, 'e': 50, 'f': 60}update(키=값)은 키가 문자열일 때만 사용할 수 있다. 만약 키가 숫자일 경우에는 update(딕셔너리)처럼 딕셔너리를 넣어서 값을 수정할 수 있다.y = {1: 'one', 2: 'two'}y.update({1: 'ONE', 3: 'THREE'})y{1: 'ONE', 2: 'two', 3: 'THREE'}다른 방법으로는 리슽트와 튜플을 이용하는 방법도 있다. update(리스트), update(튜플)은 리스트와 튜플로 값을 수정한다. 여기서 리스트는 [[키1, 값1]], [[키2, 값2]] 형식으로 키와 값을 리스트로 만들고 이 리스트를 다시 리스트 안에 넣어서 키-값 쌍을 나열해준다.y = {1: 'ONE', 2: 'two', 3: 'THREE'}y.update([[2, 'TWO'], [4, 'FOUR']])y{1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}특히 update(반복가능한객체)는 키-값 쌍으로 된 반복 가능한 객체로 값을 수정한다. 즉, 다음과 같이 키 리스트와 값 리스트를 묶은 zip 객체로 값을 수정할 수 있다.y = {1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}y.update(zip([1, 2], ['one', 'two']))y{1: 'one', 2: 'two', 3: 'THREE', 4: 'FOUR'}setdefault와 update의 차이setdefault는 키-값 쌍 추가만 할 수 있고, 이미 들어있는 키의 값은 수정할 수 없다. 하지만 update는 키-값 쌍 추가와 값 수정이 모두 가능하다. 다음과 같이 setdefault로 이미 들어있는 키’a’를 90으로 저장해도 ‘a’의 값은 바뀌지 않는다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.setdefault('a', 90)10x{'a': 10, 'b': 20, 'c': 30, 'd': 40} # a의 값이 바뀌지 않음딕셔너리에서 키-값 쌍 삭제하기pop(키)는 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 삭제한 값을 반환한다. 다음은 딕셔러니 x에서 키’a’를 삭제한 뒤 10을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.pop('a')10x{'b': 20, 'c': 30, 'd': 40}pop(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키-값 쌍을 삭제한뒤 삭제한 값을 반환하지만 키가 없을 때는 기본값만 반환한다. 딕셔러니 x에는 키’z’가 없으므로 기본값으로 지정한 0을 반환한다.x.pop('z', 0)0pop 대신 del로 특정 키-값 쌍을 삭제할 수도 있다. 이때는 [ ]에 키를 지정하여 del을 사용한다. 다음은 딕셔너리 x의 키 ‘a’를 삭제한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}del x['a']x{'b': 20, 'c': 30, 'd': 40}딕셔너리에서 임의의 키-값 쌍 삭제하기popitem()은 딕셔너리에서 &lt;임의의 키-값 쌍을 삭제한 뒤 삭제한 키-값 쌍을 튜플로 반환한다. 이 메서드는 파이썬 버전에 따라 동작이 달라지는데, 파이썬 3.6 이상에서는 마지막 키-값 쌍을 삭제하며 3.5 이하에서는 임의의 키-값 쌍을 삭제한다. 아래 코드는 3.6이상 기준이다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.popitem()('d', 40)x{'a': 10, 'b': 20, 'c': 30}딕셔너리의 모든 키-값 쌍을 삭제하기clear()는 딕셔너리의 모든 키-값 쌍을 삭제한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.clear() #모두 삭제x{}딕셔너리에서 키의 값을 가져오기get(키)는 딕셔너리의 특정 키 값을 가져온다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.get('a') # 키 'a'의 값을 가져온다. 10get(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키의 값을 반환하지만 키가 없을때는 기본값을 반환한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.get('z', 0) # x딕셔너리에 없는 키'z'와 기본값 0을 지정0 # 기본값 반환.딕셔너리에서 키-값 쌍을 모두 가져오기딕셔너리는 기와 값을 가져오는 다양한 메서드를 제공한다.  items: 키-값 쌍을 모두 가져옴  keys: 키를 모두 가져옴  values: 값을 모두 가져옴items()는 딕셔너리의 키-값 쌍을 모두 가져온다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.items()dict_items([('a', 10), ('b', 20), ('c', 30), ('d', 40)])keys()는 키를 모두 가져옵니다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.keys()dict_keys(['a', 'b', 'c', 'd']) # 모든 키values()는 값을 모두 가져옵니다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x.values()dict_values([10, 20, 30, 40]) # 모든 값리스트와 튜플로 딕셔너리 만들기이번에는 리스트(튜플)로 딕셔너리를 만들어 보자.keys = [‘a’, ‘b’, ‘c’, ‘d’]처럼 키가 들어있는 리스트를 준비한다(튜플도 가능). 그리고 dict.fromkeys에 키가 들어있는 리스트를 넣으면 딕셔너리를 생성한다.dict.fromkeys(키리스트)는 키 리스트로 딕셔너리를 생성하며 값은 모두 None으로 저장한다.keys = ['a', 'b', 'c', 'd']x = dict.fromkeys(keys)x{'a': None, 'b': None, 'c': None, 'd': None} # 키 리스트로 딕셔너리 생성후 값을 모두 None으로 저장.dict.fromkeys(키리스트, 값)처럼 키 리스트와 값을 지정하면 해당 값이 키의 값으로 저장된다.keys = ['a', 'b', 'c', 'd']x = dict.fromkeys(keys)x{'a': None, 'b': None, 'c': None, 'd': None}y = dict.fromkeys(keys, 100) # 키리스트에 값 100을 지정y{'a': 100, 'b': 100, 'c': 100, 'd': 100}defaultdict 사용하기딕셔너리(dict)는 없는 키에 접근했을 경우 에러가 발생한다.x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}x['z']    # 키 'z'는 없음Traceback (most recent call last):  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;    x['z']KeyError: 'z'defaultdict(기본값생성함수)를 사용하면 없는 키에 접근하더라도 에러가 발생하지 않고 기본값을 반환한다. defaultdict는 collections 모듈에 들어있으며 기본값 생성 함수를 넣는다. 아래와 같이 기본 값에 int를 지정하게 되면 0이 나오는데 int()를 하고 호출하면 0이 나오기 때문이다.from collections import defaultdicty = {'a': 0, 'b': 0, 'c': 0, 'd': 0}y = defaultdict(int)int() #int()호출0y['z'] # 없는 키를 에 접근했지만 기본값을 int로 지정해놨다.00이 아닌 다른 값을 기본 값으로 설정할 수도 있다.from collections import defaultdictz = defaultdict(lambda: 'python')z['a']'python'z[0]'python'2. 반복문으로 딕셔너리의 키-값 쌍을 모두 출력하기딕셔너리와 for반복문을 사용해 간단하게 모든 키-값 쌍을 출력해 보자. for i in x 처럼 for 반복문에 딕셔너리를 지정한 뒤에 print로 변수 i를 출력해보면 값을 출력되지 않고 키만 출력된다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for i in x:     print(i, end=' ')a b c d키와 값을 모두 출력하려면 for in 뒤에 딕셔너리를 지정하고 items(키-값 쌍을 모두 가져옴)를 사용해야 한다.for 키, 값 in 딕셔너리.items():     반복할 코드다음은 for로 리스트 a의 모든 키와 값을 출력한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for key, value in x.items():    print(key, value)    a 10b 20c 30d 40딕셔너리의 키만 출력하기for 반복문에서 keys로 키를 가져오면서 반복해보자.  items: 키-값 쌍을 모두 가져옴  keys: 키를 모두 가져옴  values: 값을 모두 가져옴x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for key in x.keys(): #딕셔너리 x에 있는 key를 모두 가져와 key에 대입한다.    print(key, end = ' ')    a b c d 딕셔너리의 값만 출력하기for 반복문에서 values를 사용해 값만 가져오며 반복한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}for value in x.values():    print(value, end = ' ')    10 20 30 40 3.딕셔너리 표현식 사용하기리스트와 마찬가지로 딕셔너리도 for 반복문과 if 조건문을 사용해 딕셔너리를 생성할 수 있다. 다음과 같이 딕셔너리 안에 키와 값, for 반복문을 지정하면 된다.  {키: 값 for 키, 값 in 딕셔너리}  dict({키: 값 for 키, 값 in 딕셔너리})딕셔너리 표현식을 사용할 때는 for in 다음에 딕셔너리를 지정하고 items를 사용한다. 그리고 키, 값을 가져온뒤에는 키 : 값 형식으로 변수나 값을 배치하여 딕셔너리를 생성한다.keys = ['a', 'b', 'c', 'd']x = {key : value for key, value in dict.fromkeys(keys).items()} # 키리스트로 딕셔너리를 생성하고 값은 모두 None으로 저장한 키와 값모두를 가져와 변수 key, value에 지정하고 그걸 다시 key : value 에 대입해 딕셔너리로 만든다.x{'a': None, 'b': None, 'c': None, 'd': None}다음과 같이 keys로 킴만 가져온 뒤 특정 값을 넣거나, values로 값을 가져온뒤 값을 키로 사용할 수도 있다. 또는, 키와 값의 자리를 바꾸는 등 여러 가지로 응용할 수 있다.keys = ['a', 'b', 'c', 'd']y = {key: 0 for key in dict.fromkeys(['a', 'b', 'c', 'd']).keys()} # 키리스트로 딕셔너리를 생성하고 키만 가져온후 변수key에 대입후 key: 0 에 키를 대입해 딕셔너리로 만든다. 값을 0으로 지정했다.y{'a': 0, 'b': 0, 'c': 0, 'd': 0}keys = ['a', 'b', 'c', 'd']z = {value: 0 for value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.values()} # 딕셔너리의 값만 추출해 value에 대입후 value: 0를 값을 키로 만들고 값을 0으로 지정한다.z{10: 0, 20: 0, 30: 0, 40: 0}keys = ['a', 'b', 'c', 'd']t = {value: key for key, value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.items()} t{10: 'a', 20: 'b', 30: 'c', 40: 'd'}딕셔너리 표현식에서 if 조건문 사용하기표현식이 복잡하고 dict.fromkeys함수만 사용한 결과와 큰차이점이 없어 보이지만 딕셔너리에서 특정값을 찾아 삭제할때 유용하다. 딕셔너리는 특정키를 삭제하는 pop 메서드만 제공할 뿐 특정 값을 삭제하는 메서드는 제공하지 않는다. for 반복문으로 반복하면서 del로 삭제하는 방식은 딕셔너리의 크기가 바뀌어 에러가 발생한다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40} for key, value in x.items():    if value == 20:    # 값이 20이면        del x[key]     # 키-값 쌍 삭제 print(x)#결과Traceback (most recent call last):  File \"C:\\project\\dict_del_by_value_error.py\", line 3, in &lt;module&gt;    for key, value in x.items():RuntimeError: dictionary changed size during iteration 특정 값을 삭제하려면 딕셔너리 표현식에 if조건문을 사용해 삭제할 값을 제외해야한다. 표현식에 if value != 20과 같이 if 조건문을 지정하면 값이 20이 아닌 키-값 쌍으로 다시 딕셔너리를 만든다. 직접 키-값 쌍을 삭제하는 방식이 아니라 삭제할 키-값 쌍을 제외하고 남은 키-값 쌍으로 딕셔너리를 새로 만드는 것이다.x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}x = {key: value for key, value in x.items() if value != 20}x{'a': 10, 'c': 30, 'd': 40}4.딕셔너리 안에서 딕셔너리 사용하기이번에는 딕셔너리 안에서 딕셔너리를 사용하는 중첩 딕셔너리를 알아보자. 다음과 같이 딕셔너리는 값 부분에 다시 딕셔너리가 계속 들어갈 수 있다.  딕셔너리 = {키1: {키A: 값A}, 키2: {키B: 값B}}아래는 지구형 행성의 반지름, 질량, 공전주기를 딕셔너리로 표현한 것이다.terrestrial_planet = {    'Mercury': {        'mean_radius': 2439.7,        'mass': 3.3022E+23,        'orbital_period': 87.969    },    'Venus': {        'mean_radius': 6051.8,        'mass': 4.8676E+24,        'orbital_period': 224.70069,    },    'Earth': {        'mean_radius': 6371.0,        'mass': 5.97219E+24,        'orbital_period': 365.25641,    },    'Mars': {        'mean_radius': 3389.5,        'mass': 6.4185E+23,        'orbital_period': 686.9600,    }} print(terrestrial_planet['Venus']['mean_radius'])    # 6051.8딕셔너리 terrestrial_planet에 키 ‘Mercury’, ‘Venus’, ‘Earth’, ‘Mars’가 들어있고, 이 키들은 다시 값 부분에 딕셔너리를 가지고 있다. 즉, 중첩 딕셔너리는 계층형 데이터를 지정할 때 유용하다.딕셔너리 안에 들어있는 딕셔너리에 접근하려면 딕셔너리 뒤에 []를 단계만큼 붙이고 키를 지정해주면 된다.  딕셔너리[키][키]  딕셔너리[키][키] = 값딕셔너리 terrestrial_planet는 딕셔너리가 두 단계로 구성되어 있으므로 대괄호를 두 번 사용한다. 금성(Venus)의 반지름(mean radius)를 출력하려면 다음과 같이 먼저 ‘Venus’를 찾아가고 다시 ‘mean_radius’의 값을 가져오면 된다.print(terrestrial_planet['Venus']['mean_radius'])    # 6051.85.딕셔너리의 할당과 복사리스트와 마찬가지로 딕셔너리도 할당과 복사는 큰차이점이 있다. 먼저 딕셔너리를 만든 뒤 변수에 할당한다. y = x와 같이 딕셔너리를 다른 변수에 할당하면 딕셔너리는 두 개가 될 것 같지만 실제로는 딕셔너리가 한개이다. x와 y를 is연산자로 비교하면 True가 나온다. 즉, 변수 이름만 다를 뿐 딕셔너리 x와 y는 같은 객체이다.x is yTruex와 y는 같으므로 y[‘a’]=99와 같이 키’a’의 값을 변경하면 딕셔너리 x와 y모두 반영된다.y['a'] = 99x{'a': 99, 'b': 0, 'c': 0, 'd': 0}y{'a': 99, 'b': 0, 'c': 0, 'd': 0}딕셔너리 x와 y를 완전이 분리한 두개의 딕셔너리로 만드려면 copy메서드로 모든 키-값 쌍을 복사해야한다. 복사후 x와 y를 is 연산자로 비교해보면 False가 나온다. 즉, 두 딕셔너리는 이제 다른 객체이다. 그러나 복사한 키-값 쌍은 같음으로 ==로 비교하면 True가 나온다. 딕셔너리 x와 y는 별개 이므로 한쪽의 값을 변경해도 다른 딕셔너리에 영향을 미치지 않는다. 다음과 같이 딕셔너리 y에서 키 ‘a’의 값을 변경하면 딕셔너리 x는 그대로이고 딕셔너리 y만 바뀐다.x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}y = x.copy()x is yFalsex == yTruey['a'] = 99x{'a': 0, 'b': 0, 'c': 0, 'd': 0}y{'a': 99, 'b': 0, 'c': 0, 'd': 0}중첩 딕셔너리의 할당과 복사 알아보기딕셔너리 안에 딕셔너리가 들어있는 중첩 딕셔너리는 copy메서드를 사용할 경우 값을 복사하면 두 딕셔너리의 값이 모두 바뀌게된다.x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}y = x.copy() # 중첩 딕셔너리를 copy메서드로 복사y['a']['python'] = '2.7.15' # 딕셔너리 y의 a키의 값 python키 의 값 변경x{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}y{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}} # 두 딕셔너리 모두 값이 변경됨.중첩 딕셔너리를 완전히 복사하려면 copy메서드 대신 deepcopy 함수를 사용해야한다. 이제 딕셔너리y의 값을 변경해도 딕셔너리 x에 영향을 미치지 않는다. copy.deepcopy 함수는 중첩된 딕셔너리에 들어있는 모든 딕셔너리를 복사하는 깊은 복사(deep copy)를 해준다.x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}import copy             # copy 모듈을 가져옴y = copy.deepcopy(x)    # copy.deepcopy 함수를 사용하여 깊은 복사y['a']['python'] = '2.7.15'x{'a': {'python': '2.7'}, 'b': {'python': '3.6'}}y{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}   '예제표준 입력으로 문자열 여러 개와 숫자 여러 개가 두 줄로 입력되고, 첫 번째 줄은 키, 두 번째 줄은 값으로 하여 딕셔너리를 생성합니다. 다음 코드를 완성하여 딕셔너리에서 키가 ‘delta’인 키-값 쌍과 값이 30인 키-값 쌍을 삭제하도록 만드세요.keys = input().split()values = map(int, input().split()) x = dict(zip(keys, values))____________________________________________________print(x)#입력alpha bravo charlie delta10 20 30 40#결과{'alpha': 10, 'bravo': 20}#입력alpha bravo charlie delta echo foxtrot golf30 40 50 60 70 80 90#결과{'bravo': 40, 'charlie': 50, 'echo': 70, 'foxtrot': 80, 'golf': 90}답x = {key: value for key, value in x.items() if value != 30 and key != 'delta'}",
        "url": "/python-basic23"
    }
    ,
    
    "python-basic22": {
        "title": "Python - Python 문자열 응용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기문자열 응용하기—1. 문자열 조작하기문자열은 문자열을 조작하거나 정보를 얻는 다양한 메서드(method)를 제공한다. 파이썬에서 제공하는 문자열 메서드중 자주 쓰는 메서드를 알아보자.문자열 바꾸기문자열을 다른 문자열로 바꾸는 메서드를 알아보자. 다음 문자열 Hello, world!’에서 ‘world’를 ‘Python’으로 바꾸는 코드이다. 바뀐 결과를 유지하고 싶다면 문자열이 저장된 변수에 replace를 사용한 뒤 다시 변수에 할당한다.  replace(‘바꿀문자열’, ‘새문자열’)'Hello, world!'.replace('world', 'Python')#결과'Hello, Python!#결과를 유지하고 싶을때.s = 'Hello, world!'s = s.replace('world!', 'Python')s'Hello, Python'문자 바꾸기문자열 안의 문자를 다른 문자로 바꾸는 메서드를 알아보자. 먼저 str.maketrans(‘바꿀문자’, ‘새문자’)로 변환 테이블을 만든다. 그다음에 translate(테이블)을 사용하면 문자를 바꾼 뒤 결과를 반환한다.table = str.maketrans('aeiou', '12345')'apple'.translate(table)'1ppl2'splite(‘기준이되는문자열’)과 같이 기준이되는 문자열을 지정하면 기준 문자열로 문자열을 분리한다.문자열에서 각 단어가,(콤마)와 공백으로 구분되어 있을때’, ‘으로 문자열을 분리하면 단어만 따로 리스트로 처리된다.'apple, pear, grape, pineapple, orange'.split(', ') #기준이 되는 문자열에 split(', ')['apple', 'pear', 'grape', 'pineapple', 'orange']구분자 문자열과 문자열 리스트 연결하기join(리스트)를 사용하면 구분자 문자열과 문자열 리스트의 요소를 연결하여 문자열로 만든다. 다음은 공백 ‘ ‘에 join을 사용하여 각 문자열 사이에 공백이 들어가게 만든다. 공백이 아닌 다른 문자를 사용하면 사용된 문자가 문자열 사이에 들어가게 된다.['apple', 'pear', 'grape', 'pineapple', 'orange']' '.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])         'apple pear grape pineapple orange'# - 를 넣었을때.'-'.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])'apple-pear-grape-pineapple-orange'소문자를 대문자로 바꾸기바꾸고싶은 문자열.upper()은 바꾸고싶은 문자열을 모두 대문자로 바꿔준다. 문자열에 이미 대문자가 있는경우 그대로 유지된다.'python'.upper()'PYTHON'대문자를 소문자로 바꾸기바꾸고싶은 문자열.lower()은 바꾸고싶은 문자열을 모두 소문자로 바꿔준다. 문자열에 이미 소문자가 있는경우 그대로 유지된다.'PYTHON'.lower()'python'왼쪽 공백 삭제하기lstrip, rstrip, strip 메서드는 공백을 삭제해야 할 경우가 사용된다. lstrip()은 문자열에서 왼쪽에 있는 연속된 모든 공백을 삭제한니다(l은 왼쪽(left)을 의미).'   Python   '.strip() #양쪽에 있는 모든 연속된 공백 삭제         'Python''   Python   '.lstrip() #왼쪽 공백 삭제'Python   ''   Python   '.rstrip() #오른쪽 공백 삭제         '   Python'왼쪽의 특정 문자 삭제하기lstrip(‘삭제할문자들’), rstrip(‘삭제할문자들’), strip(‘삭제할문자들’)을 사용하면 해당 방향의 ‘삭제할 문자들에’ 들어있는 문자열을 삭제한다.', python.'.lstrip(',.') #왼쪽에 있는 ',.'문자열 삭제' python.'', python.'.rstrip(',.') #오른쪽에 있는 ',.'문자열 삭제', python' '', python.'.strip(',.') #양쪽의 ',.'문자열 삭제' python'구두점을 간단하게 삭제하기punctuation을 사용하면 문자열의 양쪽 모든 구두점을 삭제할 수 있다.import string', python.'.strip(string.punctuation)' python'string.punctuation'!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'공백까지 삭제하고자 한다면 string.punctuation에 공백 ‘ ‘을 연결해서 넣어주면 된다.', python.'.strip(string.punctuation + ' ')'python'문자열을 왼쪽 정렬하기ljust(길이)는 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하며 남는 공간을 공백으로 채운다.rjust(길이)는 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하며 남는 공간을 공백으로 채운다.center(길이)는 문자열을 지정된 길이로 만든 뒤 가운데로 정렬하며 남는 공간을 공백으로 채운다.만약 남는 공간이 홀수이면 왼쪽에 공백이 한칸 더 들어간다.'python'.ljust(10) #python을 왼쪽으로 정렬하고 남는 공간을 공백처리'python    ''python'.rjust(10) #python을 오른으로 정렬하고 남는 공간을 공백처리'    python''python'.center(10) ##python을 가운데 정렬하고 양쪽의 남는 공간을 공백처리'  python  '메서드 체이닝메서드 체이닝은 메서드를 줄줄이 연결 한다고 해서 메서드 체이닝(method chaining)이라 부른다. 메서드를 계속 연결해 호출하는 메서드 체이닝을 알아보자. input().split()도 input()이 반환한 문자열에 split을 호출하는 메서드 체이닝이다. 아래 코드는 문자열을 지정된 길이인 10개로 만들고 오른쪽정렬과 대문자 처리를 해줬다.'python'.rjust(10).upper()'    PYTHON'문자열 왼쪽에 0 채우기zfill(길이)를 사용하면 지정된 길이에 맞춰 문자열의 왼쪽에 0을 채운다( zero fill을 의미). 문자열의 길이가 지정된 길이보자 작다면 아무것도 채우지 않는다. 보통 zfill은 숫자를 일정 자릿수로 맞추고 앞자리는 0으로 채울 때 사용한다.'35'.zfill(4)        # 숫자 앞에 0을 채움'0035''3.5'.zfill(6)       # 숫자 앞에 0을 채움'0003.5''hello'.zfill(10)    # 문자열 앞에 0을 채울 수도 있음'00000hello'문자열 위치 찾기find(‘찾을문자열’)은 문자열에서 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다. find는 왼쪽부터 문자열을 찾고, 같은 문자열이 여러개일 경우 처음 찾은 문자열의 인덱스를 반환한다. 아래에서는 ‘pl’이 2개 있지만 왼쪽에서 처음 찾은 ‘pl’의 인덱스 2를 반환한다.rfind(‘찾을문자열’)은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다. 같은 문자열이 여러개일 경우 처음 찾은 문자열의 인덱스를 반환한다. 아래에서는 ‘pl’이 2개 있지만 오른쪽에서 처음 찾은 ‘pl’의 인덱스 12를 반환한다.'apple pineapple'.find('pl') #찾는 문자열이 인덱스 2번위치부터 위치한다.2'apple pineapple'.find('xy') #찾는 문자열이 없기때문에 -1을 반환-1'apple pineapple'.rfind('pl') #찾는 문자열이 인덱스 12번위치부터 위치한다.12'apple pineapple'.rfind('xy') #찾는 문자열이 없기때문에 -1을 반환-1문자열 위치 찾기find, rfind 이외에도 index, rindex로 문자열의 위치를 찾을 수 있다.index(‘찾을문자열’)은 왼쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다. 단, 문자열이 없으면 에러를 발생시킨다. index도 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다. rindex(‘찾을문자열’)은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다(r은 오른쪽(right)을 의미). 마찬가지로 문자열이 없으면 에러를 발생시키며 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다.'apple pineapple'.index('pl')2'apple pineapple'.rindex('pl')12문자열 개수 세기count(‘문자열’)은 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아낸다. 여기서는 ‘pl’이 2번 나오므로 2가 반환된다.'apple pineapple'.count('pl')22. 문자열 서식 지정자와 포매팅 사용하기서식 지정자(format specifier)로 문자열을 만드는 방법과 format 메서드로 문자열을 만드는 문자열 포매팅(string formatting)에 대해 알아보자.예를들어 학생의 이름과 평균 점수를 출력한다고하자. 두 문자열에서 ‘의 평균 점수는’, ‘점입니다.’는 같지만 이름과 점수가 다르다. 이렇게 문자열 안에서 특정 부분을 원하는 값으로 바꿀 때 서식 지정자 또는 문자열 포매팅을 사용한다.제임스의 평균 점수는 85.3점입니다.학생이 바뀌면 이름과 점수 부분도 바뀌게 된다.마리아의 평균 점수는 98.7점입니다.서식 지정자로 문자열 넣기서식 지정자(format specifier)로 문자열 중간에 다른 문자열을 넣어보자.  ‘%s’ % ‘문자열’서식 지정자는 %로 시작하고 자료형을 뜻하는 문자가 붙는다. %s는 문자열이라는 뜻이고 string의 s이다. 문자열 안에 %s를 넣고 그 뒤에 %를 붙인 뒤 ‘james’를 지정해주면 %s부분이 ‘james’로 바뀐다. 문자열이 아닌 변수를 지정할 수도 있다.'I am %s.' % 'james''I am james.'name = 'maria''I am %s.' % name'I am maria.'서식 지정자로 숫자 넣기서식 지정자로 숫자형을 넣는 방식이다.  ‘%d’ % 숫자숫자는 %d를 넣고 % 뒤에 숫자를 지정하면 된다. %d는 10진 정수 decimal integer의 d이다.'I am %d years old.' % 20'I am 20 years old.'서식 지정자로 소수점 표현하기서식 지정자로 실수를 넣는 방법이다.  ‘%f’ % 숫자실수를 넣을 때는 %f를 사용하며 고정 소수점 fixed point의 f이다. %f는 기본적으로 소수점 이하 6자리까지 표시하므로 2.3은 2.300000으로 표시된다. 소수점 이하 자릿수를 지정하고 싶다면 다음과 같이 f 앞에 .(점)과 자릿수를 지정해주면 된다.  ’%.자릿수f’ % 숫자'%f' % 2.3'2.300000''%.2f' % 2.3 #소숫점 이하 2자리까지 표시'2.30''%.3f' % 2.3 #소숫점 이하 3자리까지 표시'2.300'서식 지정자로 문자열 정렬하기서식 지정자와 숫자를 조합하여 문자열을 정렬하는 방법이다. 다음과 같이 % 뒤에 숫자를 붙이면 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남는 공간을 공백으로 채운다. %10s는 문자열의 길이를 10으로 만든 뒤 지정된 문자열을 넣고 오른쪽으로 정렬한다. 따라서 문자열 ‘python’은 길이가 6이므로 왼쪽 공간을 공백 4칸으로 채운다.  %길이s'%10s' % 'python''    python'왼쪽 정렬은 아래와 같다. %-10s는 문자열의 길이를 10으로 만든 뒤 지정된 문자열을 넣고 왼쪽으로 정렬한다. 따라서 문자열 ‘python’은 길이가 6이므로 오른쪽 공간을 공백 4칸으로 채운다.  %-길이s'%-10s' % 'python''python    '자릿수가 다른 숫자 출력하기문자열 오른쪽 정렬은 자릿수가 다른 숫자를 출력할 때 유용하다. %d와 %f도 숫자와 조합하여 오른쪽으로 정렬할 수 있다.  %길이d'%10d' % 150'       150''%10d' % 15000'     15000'  길이.자릿수f'%10.2f' % 2.3'      2.30''%10.2f' % 2000.3'   2000.30'서식 지정자로 문자열 안에 값 여러 개 넣기서식지정자로 문자열 안에 값을 여러개 넣는 방법이다.  ‘%d %s’ % (숫자, ‘문자열’)문자열 안에 값을 두개 이상 넣으려면 %를 붙이고 괄호 안에 값또는 변수를 콤마로 구분해서 넣어주면 된다. 특히 값을 괄호로 묶지 않으면 에러가 발생하니 주의해야 한다. 이처럼 서식 지정자가 여러 개면 괄호 안의 값(변수) 개수도 서식 지정자 개수와 똑같이 맞춰주어야 한다.'Today is %d %s.' % (3, 'April')'Today is 3 April.'format 메서드 사용하기파이썬은 문자열을 만들 때 서식 지정자 방식보다 더 간단한 문자열 포매팅(string formatting)을 제공한다. 문자열 포매팅은 { }(중괄호) 안에 포매팅을 지정하고 format 메서드로 값을 넣는다.  ‘{인덱스}’.format(값)'Hello, {0}'.format('world!')'Hello, world!''Hello, {0}'.format(100)'Hello, 100'format 메서드로 값을 여러 개 넣기값을 여러개 넣으려면 인덱스 값을 지정하고 format에는 인덱스가 증가하는 순서대로 값을 넣으면 된다.  ‘{인덱스}’.format(값)                                0       1       2'Hello, {0} {2} {1}'.format('Python', 'Script', 3.6)'Hello, Python 3.6 Script'format 메서드로 같은 값을 여러 개 넣기특히 같은 인덱스가 지정된 { }를 여러 개 넣으면 같은 값이 여러 개 들어간다. 다음은 문자열에 ‘Python’이 두 개, ‘Script’가 두 개 들어간다.'{0} {0} {1} {1}'.format('Python', 'Script')'Python Python Script Script'format 메서드에서 인덱스 생략하기만약 { }에서 인덱스를 생략하면 format에 지정한 순서대로 값이 들어간다.'Hello, {} {} {}'.format('Python', 'Script', 3.6)'Hello, Python Script 3.6'format 메서드에서 인덱스 대신 이름 지정하기{ }에 인덱스 대신 이름을 지정해 값을 할당할 수 있다.'Hello, {language} {version}'.format(language='Python', version=3.6)'Hello, Python 3.6'문자열 포매팅에 변수를 그대로 사용하기파이썬 3.6부터는 변수에 값을 넣고 { }에 변수 이름을 지정해 변수를 그대로 사용할 수 있다. 이때 문자열 앞에 포매팅(formatting)이라는 뜻으로 f를 붙인다.language = 'Python'version = 3.6f'Hello, {language} {version}''Hello, Python 3.6'# 중괄호 출력하기'{\\{ {0} }\\}'.format('Python')'{ Python }'format 메서드로 문자열 정렬하기문자열 포매팅도 문자열을 정렬할 수 있다. 다음과 같이 인덱스 뒤에 :(콜론)을 붙이고 정렬할 방향과 길이를지정해준다.  ‘{인덱스:&lt;길이}’.format(값)‘{0:&lt;10}’은 부등호 방향이 왼쪽을 가리키고있다. 따라서 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하고 남는 공간을 공백으로 채운다.'{0:&lt;10}'.format('python')'python    '다음과 같이 &gt;을 넣어서 오른쪽을 가리키도록 만들면 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하고 남는 공간을 공백으로 채운다.  ‘{인덱스:&gt;길이}’.format(값)'{0:&gt;10}'.format('python')'    python'인덱스를 사용하지 않는다면 :(콜론)과 정렬 방법만 지정해도 된다.'{:&gt;10}'.format('python')'    python'숫자 개수 맞추기d는 다음과 같이 %와 d 사이에 0과 숫자 개수를 넣어주면 자릿수에 맞춰서 앞에 0이 들어간다. 즉, %03d로 지정하면 1은 ‘001’, 35는 ‘035’가 된다. { }를 사용할 때는 인덱스나 이름 뒤에 :(콜론)를 붙이고 03d처럼 0과 숫자 개수를 지정하면 된다.  ‘%0개수d’ % 숫자  ‘{인덱스:0개수d’}’.format(숫자)'%03d' % 1'001''{0:03d}'.format(35)'035'실수도 숫자 개수를 맞출 수 있다. 특히 소수점 이하 자릿수를 지정하고 싶으면 %08.2f처럼 .(점) 뒤에 자릿수를 지정헤준다. 여기서 주의할 점은 ‘%08.2f’ % 3.6을 출력했을 때 ‘00003.60’이 나온다는 점이다. 실수는 숫자 개수에 정수 부분, 소수점, 소수점 이하 자릿수가 모두 포함된다. 따라서 ‘00003’ 5개, ‘.’ 1개, ‘60’ 2개 총 8개가된다.  ‘%0개수.자릿수f’ % 숫자  ‘{인덱스:0개수.자릿수f’}.format(숫자)'%08.2f' % 3.6'00003.60''{0:08.2f}'.format(150.37)'00150.37'채우기와 정렬을 조합해서 사용하기문자열 포매팅은 채우기와 정렬을 조합해서 사용할 수 있다. 다음과 같이 { }에 인덱스, 채우기, 정렬, 길이, 자릿수, 자료형 순으로 지정해 준다. 길이를 10으로 만들고 왼쪽, 오른쪽으로 정렬하고 남는 공간은 0으로 채워보자.  ‘{인덱스:[[채우기]정렬][길이][.자릿수][자료형]}’'{0:0&lt;10}'.format(15)    # 길이 10, 왼쪽으로 정렬하고 남는 공간은 0으로 채움'1500000000''{0:0&gt;10}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 남는 공간은 0으로 채움'0000000015'실수로 만들고 싶다면 다음과 같이 소수점 자릿수와 실수 자료형 f를 지정해주면 된다.'{0:0&gt;10.2f}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 소수점 자릿수는 2자리'0000015.00'채우기 부분에 0이 아닌 다른 문자를 넣어도 된다. 공백을 넣어도 되고, 문자를 넣어도 된다. 채우기 부분을 생략하면 공백이 들어가게된다.'{0: &gt;10}'.format(15)    # 남는 공간을 공백으로 채움'        15''{0:&gt;10}'.format(15)     # 채우기 부분을 생략하면 공백이 들어감'        15''{0:x&gt;10}'.format(15)    # 남는 공간을 문자 x로 채움'xxxxxxxx15'금액에서 천단위로 콤마 넣기숫자 중에서 금액은 천단위로 콤마를 넣는다. 파이썬에서 간단하게 천단위로 콤마를 넣을수 있다. \\ format 내장 함수를 사용하는 방법입니다. 다음과 같이 format 함수에 숫자와 ‘,’를 넣어준다.  format(숫자, ‘,’)format(1493500, ',')'1,493,500'format 함수는 서식 지정자와 함께 사용할 수 있습니다. 다음은 콤마를 넣은 숫자를 오른쪽 정렬한다.'%20s' % format(1493500, ',')    # 길이 20, 오른쪽으로 정렬'           1,493,500'포매팅에서 콤마를 넣으려면 다음과 같이 :(콜론)뒤에 ,(콤마)를 지정하면 된다.'{0:,}'.format(1493500)'1,493,500'만약 정렬을 하고 싶다면 정렬 방향과 길이 뒤에 콤마를 지정해준다. '{0:&gt;20,}'.format(1493500)     # 길이 20, 오른쪽으로 정렬'           1,493,500''{0:0&gt;20,}'.format(1493500)    # 길이 20, 오른쪽으로 정렬하고 남는 공간은 0으로 채움'000000000001,493,500'예제1표준 입력으로 문자열이 입력됩니다. 입력된 문자열에서 ‘the’의 개수를 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 단, 모든 문자가 소문자인 ‘the’만 찾으면 되며 ‘them’, ‘there’, ‘their’ 등은 포함하지 않아야 합니다.# 입력the grown-ups' response, this time, was to advise me to lay aside my drawings of boa constrictors, whether from the inside or the outside, and devote myself instead to geography, history, arithmetic, and grammar. That is why, at the, age of six, I gave up what might have been a magnificent career as a painter. I had been disheartened by the failure of my Drawing Number One and my Drawing Number Two. Grown-ups never understand anything by themselves, and it is tiresome for children to be always and forever explaining things to the.#결과6내가 쓴답paragraph = str(input())words = paragraph.split()count = 0for i in words:    if i.strip(\",.'\") == 'the':         count += 1         print(count)예제2표준 입력으로 물품 가격 여러 개가 문자열 한 줄로 입력되고, 각 가격은 ;(세미콜론)으로 구분되어 있습니다. 입력된 가격을 높은 가격순으로 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 가격은 길이를 9로 만든 뒤 오른쪽으로 정렬하고 천단위로 ,(콤마)를 넣으세요.# 입력51900;83000;158000;367500;250000;59200;128500;1304000#결과1,304,000  367,500  250,000  158,000  128,500   83,000   59,200   51,900내가 쓴 답. 지저분하다.price = str(input())x = price.replace(';',' ')x = x.split()x = list(map(int, x))x = sorted(x, reverse = True)for i in x:    print('{0:&gt;9,}'.format(i))다른 방식price = list(map(int,input().split(';')))price.sort(reverse=True) # 기존 리스트의 값들을 역순으로 정렬해준다for i in price:    print('{0:&gt;9,}'.format(i))",
        "url": "/python-basic22"
    }
    ,
    
    "python-basic21": {
        "title": "Python - Python 2차원 리스트 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기2차원 리스트 사용하기—1. 2차원 리스트 사용하기평면 구조의 2차원 리스트 만드는 법을 알아보자. 2차원 리스트는 가로X세로 형태로 이루어져 있으며 행 열 모두 0부터 시작한다.2차원 리스트를 만들고 요소에 접근하기평면 구조의 2차원 리스트 만드는 법을 알아보자. 2차원 리스트는 가로X세로 형태로 이루어져 있으며 행 열 모두 0부터 시작한다.a = [[10, 20], [30, 40], [50, 60]]a[[10, 20], [30, 40], [50, 60]]가로 2 세로 3의 2차원리스트가 만들어졌다. 리스트 입력시 알아보기 쉽게 아래 처럼 입력할 수도 있다.a = [[10, 20],     [30, 40],     [50, 60] ]2차원 리스트의 요소에 접근하기2차원 리스트의 요소에 접근하거나 값을 할당할 때는 리스트 뒤에 []를 두번 사용하며 []안에 세로 인덱스와 가로 인덱스를 지정해주면 된다.  리스트[세로인덱스][가로인덱스]  리스트[세로인덱스][가로인덱스]a = [[10, 20], [30, 40], [50, 60]]a[0] [0]            # 세로 인덱스 0, 가로 인덱스 0인 요소 출력10a[1][1]           # 세로 인덱스 1, 가로 인덱스 1인 요소 출력40a[2][1]           # 세로 인덱스 2, 가로 인덱스 0인 요소 출력60a[0][1] = 1000    # 세로 인덱스 0, 가로 인덱스 1인 요소에 값 할당a[0][1]10002차원 튜플다음과 같이 튜플 안에 튜플을 넣는 방식, 튜플 안에 리스트를 넣는 방식, 리스트 안에 튜플을 넣는 방식 등이 가능하다. 튜플은 내용을 변경할 수 없으므로 a는 안쪽과 바깥쪽 모두 요소를 변경할 수 없다. b는 안쪽 리스트만 요소를 변경할 수 있고, c는 바깥쪽 리스트만 요소를 변경할 수 있다.  튜플 = ((값, 값), (값, 값), (값, 값))  튜플 = ([값, 값], [값, 값], [값, 값])  리스트 = [(값, 값), (값, 값), (값, 값)]a = ((10, 20), (30, 40), (50, 60))    # 튜플 안에 튜플을 넣은 2차원 튜플b = ([10, 20], [30, 40], [50, 60])    # 튜플 안에 리스트를 넣음c = [(10, 20), (30, 40), (50, 60)]    # 리스트 안에 튜플을 넣음a[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생a[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생b[0][0] = 500        # 안쪽 리스트는 변경할 수 있음b[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생c[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생c[0] = (500, 600)    # 바깥쪽 리스트는 변경할 수 있음사람이 알아보기 쉽게 출력하기2차원 리스트의 사각형 구조를 유지하도록 출력하려면 pprint 모듈의 pprint함수를 사용한다. indent는 들여쓰기 칸 수, width는 가로 폭이다.from pprint import pprintpprint(a, indent=4, width=20)[   [10, 20],    [30, 40],    [50, 60]]2. 반복문으로 2차원 리스트의 요소를 모두 출력하기반복문을 사용해 2차원리스트의 요소를 출력하는 방법을 알아보자.for 반복문을 한 번만 사용하기for반복문을 한번만 사용하는 방식이다. 2차원 리스트에 for을 사용하면 가로 한 줄씩 반복하게 된다. 전체 리스트를 기준으로 보면 안쪽 리스트가 통째로 반복된다. for x, y in a:와 같이 in 앞에 변수를 두 개 지정해 안쪽 리스트에서 요소 두개를 꺼내온다. 당연히 in 앞에 변수의 개수는 2차원 리스트에서 가로 크기(안쪽 리스트의 요소 개수)와 일치해야 하고 특히, for반복문을 한번만 사용하는 방식은 2차원 리스트의 가로 크기가 크지 않을때 유용하다.a = [[10, 20], [30, 40], [50, 60]]for x, y in a:    # 리스트의 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼냄     print(x, y)10 2030 4050 60for 반복문을 두 번 사용하기이번에는 for반복문을 두 번 사용해서 2차원 리스트의 요소를 출력해보자. 첫번쨰 for문에서 a리스트 안의 요소묶음을 i에 대입하고, 두번째 for문에서 대입한 요소묶음의 값 하나하나를 꺼내 j에 대입한다. 그리고 j의 두 값 사이를 공백으로 처리하여 출려하고 다음 프린트문에서 줄바꿈을 해준다.a = [[10, 20], [30, 40], [50, 60]]for i in a:    for j in i:        print(j,end = ' ')    print()    10 20 30 40 50 60 for와 range 사용하기이번에는 for range에 세로 크기와 가로 크기를 지정해 2차원 리스트의 요소를 인덱스로 접근해보자.for range에 세로크기와 가로 크기를 넣르면 인덱스로 사용할 수 있다. 첫번째 for문에서 리스트의 길이는 3으로 세로 열이 3줄이 되고, 두번째 for문에서 리스트 안의 리스트는 길이가2로 인덱스 0,1을 가져올 수 있다. a[i][j] 리스트의 세로 i, 가로 j 인덱스의 값을 출력한다.a = [[10, 20], [30, 40], [50, 60]] for i in range(len(a)):            # 세로 크기 #012    for j in range(len(a[i])):     # 가로 크기 #01        print(a[i][j], end=' ')    print()#for i in range(len(a)):            # 세로 크기    for j in range(len(a[i])):     # 가로 크기while 반복문을 한 번 사용하기이번에는 while 반복문을 사용하여 2차원 리스트의 요소를 출력해보자. len(a)의 값은 3이고 012까지의 수를 i와 비교한다. 리스트에 인덱스를 지정하여 값을 꺼내 올 때는 다음과 같이 변수 두 개를 지정해주면 가로 한 줄 에서 요소 두개를 한꺼번에 가져올 수 있다. 리스트 a의 인덱스 0의값 [10. 20]을 출력하고 나머지 값도 차례로 출력한다.a = [[10, 20], [30, 40], [50, 60]] i = 0while i &lt; len(a):    # 반복할 때 리스트의 크기 활용(세로 크기)    x, y = a[i]      # 요소 두 개를 한꺼번에 가져오기    print(x, y)    i += 1           # 인덱스를 1 증가시킴10 2030 4050 60while 반복문을 두 번 사용하기while 반복문을 2번 사용할때는 for 문을 두번 사용할때와 비슷하다. i로 세로의 인덱스 값을 불러오고 j 로 가로의 인덱스 값을 불러온다.a = [[10, 20], [30, 40], [50, 60]] i = 0while i &lt; len(a):           # 세로 크기    j = 0    while j &lt; len(a[i]):    # 가로 크기        print(a[i][j], end=' ')        j += 1              # 가로 인덱스를 1 증가시킴    print()    i += 1                  # 세로 인덱스를 1 증가시킴10 2030 4050 60아래와 같이 두번째 while에서 i를 증가시키게 되면 두번쨰 while문이 도는동안 증가된 i의 값이 출력되기 때문에 주의해야한다.# 틀린 코드i = 0while i &lt; len(a):    j = 0    while j &lt; len(a[i]):        print(a[i][j], end=' ')        j += 1        i += 1    # 안쪽 while에서 i를 증가시키면 안 됨. 잘못된 방법    print()3. 반복문으로 리스트 만들기for 반복문과 append를 활용하여 리스트를 만드는 방법을 알아보자.for 반복문으로 1차원 리스트 만들기요소 10개가 일렬로 늘어서 있는 1차원 리스트를 만들어보자. 지금까지 사용했던 일반적인 리스트 이다.range(10)은 0~9까지의 값을 i에 대입하고 그럴때마다 리스트 a에 요소 0을 추가한다. 총 10개의 0요소를 가진 리스트가 생성된다.a = []    # 빈 리스트 생성 for i in range(10):    a.append(0)    # append로 요소 추가 print(a)for 반복문으로 2차원 리스트 만들기for 반복문을 통해 2차원 리스트를 만들어 보자. 빈리스트 a가 밖의 리스트가 되고 안쪽의 line이 행렬을 나타내는 리스트가 된다. 두번째 for 문이 range(3)만큼 반복되어 리스트 a의 요소로 추가된다. 0,0을 총 3번 반복하게 되어 [[0, 0], [0, 0], [0, 0]]이 출력된다.a = []    # 빈 리스트 생성 for i in range(3):    line = []              # 안쪽 리스트로 사용할 빈 리스트 생성    for j in range(2):        line.append(0)     # 안쪽 리스트에 0 추가    a.append(line)         # 전체 리스트에 안쪽 리스트를 추가 print(a)# [[0, 0], [0, 0], [0, 0]]리스트 표현식으로 2차원 리스트 만들기리스트 표현식을 사용해 2차원 리스트를 만들어 보자. 0 for j in range(2) 로 [0, 0]의 요소를 만들고 for i in range(3) 로 3번 반복하여 리스트에 담아준다.  [[0, 0], [0, 0], [0, 0]]a = [[0 for j in range(2)] for i in range(3)]a[[0, 0], [0, 0], [0, 0]]# 만약 for 반복문을 한 번만 사용하고 싶다면 다음과 같이 식 부분에서 리스트 자체를 곱한다.a = [[0] * 2 for i in range(3)]a[[0, 0], [0, 0], [0, 0]]톱니형 리스트 만들기가로 크기가 불규칙한 톱니형 리스트를 만들어 보자. 가로 크기를 알고 있다고 가정하고 리스트 a에 톱니형 리스트의 가로 크기를 미리 저장해 놓았다. 이 리스트를 a를 for로 반복하면 가로 크기를 꺼내면서 5번 반복한다.a = [3, 1, 3, 2, 5]    # 가로 크기를 저장한 리스트b = []    # 빈 리스트 생성 for i in a:      # 가로 크기를 저장한 리스트로 반복    line = []    # 안쪽 리스트로 사용할 빈 리스트 생성    for j in range(i):    # 리스트 a에 저장된 가로 크기만큼 반복        line.append(0)    b.append(line)        # 리스트 b에 안쪽 리스트를 추가 print(b)#[[0, 0, 0], # [0], # [0, 0, 0], # [0, 0], # [0, 0, 0, 0, 0]]리스트 표현식을 활용하면 간단하게 만들수 있다. 가로 크기가 들어있는 리스트 [3, 1, 3, 2, 5]에서 꺼낸 숫자만큼 리스트 [0]을 곱해서 톱니형 리스트를 만들었다.a = [[0] * i for i in [3, 1, 3, 2, 5]]a[[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]]sorted로 2차원 리스트 정렬하기2차원 리스트를 정렬할 때는 sorted함수를 사용한다.  sorted(반복가능한객체, key=정렬함수, reverse=True 또는 False)sorted의 key에 정렬 함수를 지정하여 안쪽 리스트의 요소를 기준으로 정렬했다. student[1]은 안쪽 리스트의 인덱스 1을 뜻하며 ‘A’, ‘B’, ‘C’ 순으로 정렬한다. 마찬가지로 student[2]는 안쪽 리스트의 인덱스 2를 뜻하며 7, 19, 25 순으로 정렬한다students = [    ['john', 'C', 19],    ['maria', 'A', 25],    ['andrew', 'B', 7]] print(sorted(students, key=lambda student: student[1]))  # 안쪽 리스트의 인덱스 1을 기준으로 정렬print(sorted(students, key=lambda student: student[2]))  # 안쪽 리스트의 인덱스 2를 기준으로 정렬# 결과 [['maria', 'A', 25], ['andrew', 'B', 7], ['john', 'C', 19]][['andrew', 'B', 7], ['john', 'C', 19], ['maria', 'A', 25]]4. 2차원 리스트의 할당과 복사 알아보기2차원 리스트의 할당과 복사를 알아보자. 다음과 같이 2차원 리스트를 만든 뒤 다른 변수에 할당하고, 요소를 변경해보면 두 리스트에 모두 반영된다. b[0][0] = 500은 인덱스 세로 0, 가로 0에 500을 할당한다.a = [[10, 20], [30, 40]]b = ab[0][0] = 500a[[500, 20], [30, 40]]b[[500, 20], [30, 40]]리스트 a를 copy 메서드로 b에 복사한 뒤 b의 요소를 변경해보면 리스트 a와 b에 모두 반영된다.a = [[10, 20], [30, 40]]b = a.copy()b[0][0] = 500a[[500, 20], [30, 40]]b[[500, 20], [30, 40]]2차원 이상의 다차원 리스트는 리스트를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 한다. 이렇게 하면 b의 요소를 변경해도 a리스트에는 영향을 미치지 않는다. copy.deepcopy 함수는 중첩된 리스트(튜플)에 들어있는 모든 리스트(튜플)를 복사하는 깊은 복사(deep copy)를 해준다.a = [[10, 20], [30, 40]]import copy             # copy 모듈을 가져옴b = copy.deepcopy(a)    # copy.deepcopy 함수를 사용하여 깊은 복사b[0][0] = 500a[[10, 20], [30, 40]]b[[500, 20], [30, 40]]23.7 심사문제: 지뢰찾기표준 입력으로 2차원 리스트의 가로(col)와 세로(row)가 입력되고 그 다음 줄부터 리스트의 요소로 들어갈 문자가 입력됩니다. 이때 2차원 리스트 안에서 *는 지뢰이고 .은 지뢰가 아닙니다. 지뢰가 아닌 요소에는 인접한 지뢰의 개수를 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다).여러 줄을 입력 받으려면 다음과 같이 for 반복문에서 input을 호출한 뒤 append로 각 줄을 추가하면 됩니다(list 안에 문자열을 넣으면 문자열이 문자 리스트로 변환됩니다).matrix = []for i in range(row):    matrix.append(list(input()))입력3 3.***...*.출력2***432*1입력5 5..*.....*..*....***.*.*..출력01*21123*12*5323***1*4*31col, row = map(int, input().split())matrix = []    for i in range(row):    matrix.append(list(input()))  # 입력한 값을 리스트로 만들어준다.for i in range(col): # 0 ~ 2    for j in range(row): # 0 ~ 2        if matrix[i][j]=='*': #2차원 리스트의 각 인덱스 값을 *와 비교.            print('*',end='') #*와 비교해 같으면 *을 출력.                    else:            count=0 # 초기값            for k in range(i-1,i+2): # 위for문의 i 값을 가져와 대입                for l in range(j-1,j+2): #  위for문의 j 값을 가져와 대입                    if k&lt;0 or k&gt;=col or l&lt;0 or l&gt;=row: # 지뢰 찾기 주변 8칸중 첫칸, 끝칸의 주변 값을 확일할때 인덱스 범위를 넘어가면 continue로 다시 반복하게 함.                        continue                    elif matrix[k][l]=='*':                        count+=1 # 값이 * 과일치하면 count의 값을 1씩 더해준다.            print(count,end='')    print()",
        "url": "/python-basic21"
    }
    ,
    
    "python-basic20": {
        "title": "Python - Python 리스트와 튜플 응용하기 - 2",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기리스트와 튜플 응용하기 - 2—4. 리스트의 가장 작은 수, 가장 큰 수, 합계 구하기리스트에 저장된 값 중 가장 작은 수, 가장 큰 수, 요소의 합계를 구해보자.가장 작은 수와 가장 큰 수 구하기반복문을 통해 요소를 모두 반복하면서 숫자를 찾아보자. 리스트 a의 요소를 하나씩 꺼내 i에 대입해 준다. 그다음 i가 a[0]의 값인 38보다 작으면  smallest에 대입해주고 차례로 리스트a의 값을 꺼내면서 작은 값을 i에 대입하게 된다. 제일작은 수인 19를 smallest에 대입하고 종료된다. 큰 수를 찾고싶다면 부등호만 바꿔주면 된다.a = [38, 21, 53, 62, 19]smallest = a[0]for i in a:     if i &lt; smallest:         smallest = ismallest19# 리스트 a의 값중 가장 큰 값 찾기a = [38, 21, 53, 62, 19]largest = a[0]for i in a:     if i &gt; largest:         largest = ilargest62sort메서드를 사용하여 요소들을 정렬한뒤 가장 작은값과 큰값을 찾아보자.a = [38, 21, 53, 62, 19]a.sort()a[0]19#가장 큰값은 정렬을 반대로한 첫번쨰 요소a.sort(reverse=True)a[0]62파이썬에서 제공하는 min, max함수를 사용하면 더 간단하다.a = [38, 21, 53, 62, 19]min(a)19max(a)62요소의 합계 구하기이번에는 리스트에서 요소의 합계를 구해보자. 함계를 구할 때도 반복문을 사용할 수 있다. 리스트 a의 요소를 하나씩 꺼내 i에 대입하고 i의 값을 반복해 꺼내 더해준다. 이때 x의 값은 0부터 시작해야한다. x에 다른 값을 할당하면 초기에 x의 값이 추가된채 더해지기 때문에 원하는 값을 얻을 수 없다.a = [10, 10, 10, 10, 10]x = 0for i in a:     x += i # x = x + ix50파이썬에서 제공하는 sum함수를 사용하면 더 간단한다.a = [10, 10, 10, 10, 10]sum(a)50여기서 설명한 min, max, sum에는 리스트뿐만 아니라 모든 반복 가능한 객체(iterable)를 넣을 수 있다. 반복 가능한 객체는 리스트, 튜플, 딕셔너리, 세트, range등 여러 가지가 있다.5. 리스트 표현식 사용하기파이썬의 리스트가 특이한 점은 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다는 점이다. 이렇게 리스트 안에 식, for 반복문, if 조건문 등을 지정하여 리스트를 생성하는 것을 리스트 컴프리헨션(list comprehension)이라고 한다. 컴프리헨션은 능력, 이해력, 시험 등의 뜻도 있지만, 어떤 것을 잡아서 담아둔다는 뜻이 있다. 즉, 식으로 지정해서 생성된 것을 리스트로 잡아두는 것이 리스트 컴프리헨션이다. 개념적으로 보면 “리스트 표현식”이라고 할 수 있다.리스트 표현식은 다음과 같이 리스트 안에 식, for반복문을 지정한다.  [식 for 변수 in 리스트]  list(식 for 변수 in 리스트)a = [i for i in range(10)]        # 0부터 9까지 숫자를 생성하여 리스트 생성a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]b = list(i for i in range(10))    # 0부터 9까지 숫자를 생성하여 리스트 생성b[0, 1, 2, 3, 4, 5, 6, 7, 8, 9][i for i in range(10)]는 변수 i를 그대로 사용하지만, 다음과 같이 식 부분에서 i를 다른 값과 연산하면 각 연산의 결과를 리스트로 생성한다. 아래와 같이 i+5와 i * 2를 식에 넣으면 i의 값에 연산을 하고 리스트에 담아준다.c = [i + 5 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 5를 더하여 리스트 생성c[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]d = [i * 2 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 2를 곱하여 리스트 생성d[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]리스트 표현식에서 if 조건문 사용하기이번에는 리스트 표현식에서 if조건문을 사용해 보자. 다음과 같이 if 조건문은 for 반복문 뒤에 지정한다.  [식 for 변수 in 리스트 if 조건식]  list(식 for 변수 in 리스트 if 조건식)[i for i in range(10) if i % 2 == 0]는 0부터 9까지 숫자를 생성하여 2의 배수인 숫자(짝수)로만 리스트를 생성한다. 즉, 다음과 같이 for 반복문 뒤에 if 조건문을 지정하면 숫자를 생성한 뒤 if 조건문에서 특정 숫자만 뽑아내서 리스트를 생성한다.a = [i for i in range(10) if i % 2 == 0]    # 0~9 숫자 중 2의 배수인 숫자(짝수)로 리스트 생성a[0, 2, 4, 6, 8]마찬가지로 식에 연산을 추가해 리스트를 만들 수 있다.b = [i + 5 for i in range(10) if i % 2 == 1]    # 0~9 숫자 중 홀수에 5를 더하여 리스트 생성b[6, 8, 10, 12, 14]for 반복문과 if 조건문을 여러 번 사용하기리스트 표현식은 for과 if를 여러번 사용할 수도 있다.[식 for 변수1 in 리스트1 if 조건식1     for 변수2 in 리스트2 if 조건식2     ...     for 변수n in 리스트n if 조건식n] list(식 for 변수1 in 리스트1 if 조건식1         for 변수2 in 리스트2 if 조건식2         ...         for 변수n in 리스트n if 조건식n)아래는 i와 j에 각각 range로 값을 대입해 구구단을 만들었다.a = [i * j for j in range(2, 10) for i in range(1, 10)]a[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]# 들여쓰기를 해주는 게좋다.a = [i * j for j in range(2, 10)            for i in range(1, 10)]6. 리스트에 map 사용하기리스트와 반복문을 사용해 모든 요소를 출력해 보자.for 반복문으로 요소 출력하기리스트에 map을 사용해보자. map은 리스트의 요소를 지정된 함수로 처리해주는 함수이다.(map은 원본 리스트를 변경하지 않고 새 리스트를 생성한다.)  list(map(함수, 리스트))  tuple(map(함수, 튜플))실수가 저장된 리스트가 있을때 리스트의 모든 요소를 정수로 변환해 주자. 먼저 for반복문으로 변환하는 방법이다. len(a)로 리스트의 길이를 구하고 range로 인덱스 값을 i에 대입해 줬다. 요소를 하나씩 꺼내 int (정수)로 변환해 다시 저장했다.a = [1.2, 2.5, 3.7, 4.6]for i in range(len(a)):     a[i] = int(a[i])a[1, 2, 3, 4]이번에는 map을 사용하여 변환해보자. a = list(map(int, a))한 줄로 변환 할 수 있다. map에 리스트와 int를 넣으면 리스트의 모든 요소를 int를 사용해서 변환한다. 다음에 list를 사용해서 map의 결과를 다시 리스트로 만들어준다.a = [1.2, 2.5, 3.7, 4.6]a = list(map(int, a))a[1, 2, 3, 4]range를 사용해 숫자를 만든 뒤 문자열로 변환하는것도 가능하다.a = list(map(str, range(10)))a['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']input().split()과 map지금까지 input().split()으로 값을 여러 개 입력받고 정수, 실수로 변환할 때도 map을 사용했었다. 그렇게 쓰일수 있는 이유는 input().split()의 결과가 문자열 리스트라서 map을 사용할 수 있었던 것이다. 10 20을 입력하면 [‘10’, ‘20’]처럼 문자열 두 개가 들어있는 리스트가 만들어진다.a = input().split()10 20 (입력)a['10', '20']이제 map을 사용해 정수로 변환해 보자. 10 20을 입력하면 맵 객체(map object)가 만들어지는데 이 상태로는 안에 들어있는 값을 볼 수 없다. list를 사용해서 리스트로 출력하고 리스트를 보면 [10, 20]처럼 정수 두 개가 들어있는걸 확인할 수 있다.a = map(int, input().split())10 20 (입력)a&lt;map object at 0x03DFB0D0&gt;list(a)[10, 20]이 리스트 [10, 20]을 변수 두 개에 저장하면 지금까지 사용한 a, b = map(int, input().split())와 같은 동작이 된다.a, b = [10, 20]a10b20사실 map이 반환하는 맵 객체는 이터레이터라서 변수 여러 개에 저장하는 언패킹(unpacking)이 가능하다. 그래서 a, b = map(int, input().split())처럼 list를 생략한 것이다a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드가 된다.x = input().split()    # input().split()의 결과는 문자열 리스트m = map(int, x)        # 리스트의 요소를 int로 변환, 결과는 맵 객체a, b = m               # 맵 객체는 변수 여러 개에 저장할 수 있음7. 튜플 응용하기이번에는 튜플의 메서드와 다양한 사용 방법을 알아보자. 튜플은 리스트와 달리 내용을 변경할  수 없다. 따라서 내용을 변경하는 append같은 메서드는 사용할 수 없고, 요소의 정보를 구하는 메서드만 사용할 수 있다.튜플에서 특정 값의 인덱스 구하기index(튜플요소의 값) 은 튜플에서 특정 값의 인덱스 값을 구할 수 있다. 같은 값이 여러 개일 경우 처음 찾은 인덱스를 구한다.a = (38, 21, 53, 62, 19, 53)a.index(53)2특정 값의 개수 구하기count(튜플요소의 값)은 튜플에서 특정 값의 개수를 구한다. 다음은 튜플(10, 20, 30, 15, 20, 40)에서 20의 개수를 구한다.a = (10, 20, 30, 15, 20, 40)a.count(20)2for 반복문으로 요소 출력하기for 반복문으로 튜플의 요소를 출력한다.a = (38, 21, 53, 62, 19)for i in a:     print(i, end = ' ')38 21 53 62 19튜플 표현식 사용하기튜플을 리스트 표현식처럼 생성할 떄는 다음과 같이 tuple안에 for반복문과 if 조건문을 지정한다.  tuple(식 for 변수 in 리스트 if 조건식)a = tuple(i for i in range(10) if i % 2 == 0)a(0, 2, 4, 6, 8)참고로 ( )(괄호) 안에 표현식을 넣으면 튜플이 아니라 제너레이터 표현식이된다.(뒤에 배울 내용)tuple에 map 사용하기튜플에 map을 사용하는 방법도 리스트와 같다.a = (1.2, 2.5, 3.7, 4.6)a = tuple(map(int, a))a(1, 2, 3, 4)튜플에서 가장 작은 수, 가장 큰 수, 합계 구하기튜플도 min, max 함수로 가장 작은 수와 가장 큰 수를 구하고, sum 함수로 요소의 합계를 구할 수 있다.a = (38, 21, 53, 62, 19)min(a)19max(a)62sum(a)193",
        "url": "/python-basic20"
    }
    ,
    
    "python-basic19": {
        "title": "Python - Python 리스트와 튜플 응용하기 - 1",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기리스트와 튜플 응용하기파이썬 리스트의 여러 기능들을 알아보자. 요소를 추가/삭제 하는 메소드와 정보를 조회하는 메서드 등이 있다. for문과 결합한 연속적이고 반복적인 값도 쉽게 처리할 수 있다.1. 리스트 조작하기리스트에 요소 추가하기  append: 요소 하나를 추가  extend: 리스트를 연결하여 확장  insert: 특정 인덱스에 요소 추가리스트에 요소 하나 추가하기append를 사용해 리스트 끝에 요소 하나를 추가해보자. 리스트 [10, 20, 30]에 500을 추가하여 리스트는 [10, 20, 30, 500]이 된다. 리스트에 요소를 추가하는 것 이지 새로운 리스트가 생성되는 것은 아니다.a = [10, 20, 30]a.append(500)a[10, 20, 30, 500]len(a)4비어있는 리스트에도 값을추가할 수 있다.a = []a.append(10)a[10]리스트 안에 리스트 추가하기append는 append(리스트)처럼 리스트를 넣으면 리스트 안에 리스트가 들어간다. 다음은 리스트 a안에 [500, 600]이 들어가서 중첩 리스트가 만들어진다. 요소 하나를 리스트 a의 끝에 추가해 주기 때문에 리스트의 길이가 5가 아닌 4가된다. 즉, append는 항상 리스트의 길이가 1씩 증가한다.a = [10, 20, 30]a.append([500, 600])a[10, 20, 30, [500, 600]]len(a)4리스트 확장하기리스트에 요소를 여러개 추가할 수도 있다. extend(리스트)를 사용하여 끝에 다른 리스트를 연결해 준다. 다음은 리스트 [10, 20, 30]에 다른 리스트 [500, 600]을 연결하여 [10, 20, 30, 500, 600]이 된다. 리스트를 연결 했음으로 리스트의 길이는 5가 된다.a = [10, 20, 30]a.extend([500 ,600])a[10, 20, 30, 500, 600]len(a)5리스트의 특정 인덱스에 요소 추가하기insert는 리스트의 특정 인덱스에 요소 하나를 추가한다. insert(인덱스, 요소)로 사용하고 아래는 [10, 20, 30]의 인덱스 2에 500을 추가하여 [10, 20, 500, 30]이 된다.a = [10, 20, 30]a.insert(2, 500) # index 2 위치에 500요소 추가a[10, 20, 500, 30]len(a)4insert에서 자주 사용하는 패턴은 2가지이다.  insert(0, 요소): 리스트의 맨 처음에 요소를 추가  insert(len(리스트), 요소): 리스트 끝에 요소를 추가리스트의 0번 인덱스에 500추가a = [10, 20, 30]a.insert(0, 500)a[500, 10, 20, 30]insert를 하고 리스트의 마지막 인덱스보다 큰 값을 지정하면 리스트 끝에 요소 하나를 추가할 수 있다.a = [10, 20, 30]a.insert(len(a), 500)a[10, 20, 30, 500]len(리스트)는 마지막 인덱스보다 1이 더 크기 때문에 리스트 끝에 값을 추가할때 자주 사용한다. 이방법은 a.append(500)과 같다. insert는 요소 하나를 추가하므로 insert에 리스트를 넣으면 append처럼 리스트 안에 리스트가 들어간다. 다음은 리스트 [10, 20, 30]의 인덱스 1에 리스트 [500, 600]을 추가하여 중첩 리스트가 된다.a = [10, 20, 30]a.insert(1, [500, 600])a[10, [500, 600], 20, 30]만약 리스트 중간에 요소 여러개를 추가하고 싶다면 슬라이스 요소 할당하기를 활용하면 된다. 다음은 리스트 [10, 20, 30]의 인덱스 1부터 500, 600을 추가하여 [10, 500, 600, 20, 30]이 된다.a = [10, 20, 30]a[1:1] = [500, 600] #인덱스 1의위치에 500, 600요소 추가a[10, 500, 600, 20, 30]리스트에서 요소 삭제하기리스트에서 요소를 삭제하는 방법이다.  pop: 마지막 요소 또는 특정 인덱스의 요소를 삭제  remove: 특정 값을 찾아서 삭제리스트에서 특정 인덱스의 요소를 삭제하기pop()은 리스트의 마지막 요소를 삭제한 뒤 삭제한 요소를 반환한다. 다음은 리스트 [10, 20, 30]에서 pop으로 마지막 요소를 삭제한 뒤 30을 반환합니다. 따라서 리스트는 [10, 20]이 된다.a = [10, 20, 30]a.pop() #마지막 요소인 30을 삭제하고 반환한다.30a[10, 20]원하는 인덱스의 요소를 삭제하려면 pop에 인덱스를 지정하면 된다.a = [10, 20, 30]a.pop(1) #인덱스 1의 위치의 요소(20)를 삭제하고 반환한다.20a[10, 30]]# 또는a = [10, 20, 30]del a[1] #인덱스 1의 위치의 요소를 삭제하지만 반환하지는 않는다.a[10, 30]리스트에서 특정 값을 찾아서 삭제하기pop과 del은 인덱스로 요소를 삭제한다. 리스트에서 원하는 값을 찾아 삭제하고 싶을때는 remove를 사용한다. remove(값)은 리스트에서 특정 값을 찾아서 삭제한다. 다음은 리스트 [10, 20, 30]에서 20을 삭제하여 [10, 30]이 된다.a = [10, 20, 30]a.remove(20)a[10, 30]만약 리스트에 같은 값이 여러 개 있을 경우 처음 찾은 값을 삭제한다.a = [10, 20, 30, 20]a.remove(20)a[10, 30, 20]리스트로 스택과 큐 만들기리스트 메서드로 스택(stack)과 큐(queue)를 만들 수 있다. 스택이란 한쪽으로만 들어오고 나가는 구조이다. ABC가들어오면 CBA순서로 나갈 수 있다. 큐라는 구조는 들어오는 곳과 나가는 곳이 따로 있는 구조이다. ABC가 들어가면 A가 먼저 삭제되고 나머지가 삭제되는 밀어내기 구조이다. append와 pop을 호출하는 그림을 90도 돌리면 스택의 모습이 된다.여기서 pop() 대신 pop(0)을 사용하면 큐가 된다.물론 append(), pop(0)이 아닌 insert(0, 요소), pop()을 사용해서 추가/삭제 방향을 반대로 해도 큐가 된다.파이썬에서 스택은 리스트를 그대로 활용해도 되지만, 큐는 좀 더 효율적으로 사용할 수 있도록 덱(deque, double ended queue)이라는 자료형을 제공한다. 덱은 양쪽 끝에서 추가/삭제가 가능한 자료 구조다.  deque(반복가능한객체)from collections import deque    # collections 모듈에서 deque를 가져옴a = deque([10, 20, 30])adeque([10, 20, 30])a.append(500)    # 덱의 오른쪽에 500 추가adeque([10, 20, 30, 500])a.popleft()     # 덱의 왼쪽 요소 하나 삭제10adeque([20, 30, 500])리스트에서 특정 값의 인덱스 구하기index(값)은 리스트에서 특정 값의 인덱스를 구한다. 이때 같은 값이 여러 개일 경우 처음 찾은 인덱스를 구한다(가장 작은 인덱스). 다음은 20이 두 번째에 있으므로 인덱스 1이 나온다.a = [10, 20, 30, 15, 20, 40]a.index(20)1특정 값의 개수 구하기count(값)은 리스트에서 특정 값의 개수를 구한다. 다음은 리스트 a에서 20의 개수를 구합니다.a = [10, 20, 30, 15, 20, 40]a.count(20)2특정 값의 개수 구하기reverse()는 리스트에서 요소의 순서를 반대로 뒤집는다.a = [10, 20, 30, 15, 20, 40]a.reverse()a[40, 20, 15, 30, 20, 10]리스트의 요소를 정렬하기sort()는 리스트의 요소을 작은 순서대로 정렬힌다(오름차순).  sort() 또는 sort(reverse=False): 리스트의 값을 작은 순서대로 정렬(오름차순)  sort(reverse=True): 리스트의 값을 큰 순서대로 정렬(내림차순)  sorted함수는 정렬된 새 리스트를 생성a = [10, 20, 30, 15, 20, 40]a.sort()    # a의 내용을 변경하여 정렬a[10, 15, 20, 20, 30, 40]b = [10, 20, 30, 15, 20, 40]sorted(b)    # 정렬된 새 리스트를 생성[10, 15, 20, 20, 30, 40]리스트의 모든 요소를 삭제하기clear()는 리스트의 모든 요소를 삭제한다.a = [10, 20, 30]a.clear()a[]# clear대신 del a[:]로 리스트 전체를 지정해 모든 요소를 삭제할 수도 있다.a = [10, 20, 30]del a[:]a[]리스트를 슬라이스로 조작하기리스트는 메서드를 사용하지 않고, 슬라이스로 조작할 수도 있다. 다음은 리스트 끝에 값이 한개 들어있는 리스트를 추가한다. a[len(a):] = [500]과 같이 값이 한 개 들어있는 리스트를 할당하면 리스트 a 끝에 값을 한 개 추가하며 a.append(500)과 같다.a = [10, 20, 30]a[len(a):] = [500]a[10, 20, 30, 500]a[len(a):] = [500, 600]과 같이 요소가 여러 개 들어있는 리스트를 할당하면 리스트 a 끝에 다른 리스트를 연결하며 a.extend([500, 600])과 같다.a = [10, 20, 30]a[len(a):] = [500, 600]a[10, 20, 30, 500, 600]리스트를 슬라이스로 조작하기리스트(시퀀스 객체)가 비어있는지 확인 하려면 if조건문을 사용하면 된다.if not len(seq):    # 리스트가 비어 있으면 Trueif len(seq):        # 리스트에 요소가 있으면 True위와같이 판단할 수도 있지만 리스트(시퀀스 객체)를 바로 if조건문으로 판단하는 방법이 좋다.if not seq:    # 리스트가 비어 있으면 Trueif seq:        # 리스트에 요소가 있으면 True리스트가 비어있는 지확인하는 방법은 리스트의 마지막 요소에 접근할 때 유용하게 사용할 수 있다.리스트가 비어있는 경우에 인덱스를 -1로 지정하면 에러가 발생한다. 이때는 if 조건문을 활용해 리스트에 요소가 있을 때 만 마지막 요소를 가져오면 된다.seq = []if seq:               # 리스트에 요소가 있는지 확인    print(seq[-1])    # 요소가 있을 때만 마지막 요소를 가져옴2. 리스트의 할당과 복사 알아보기 할당과 복사는 비슷한것 같지만 큰 차이가 있다. 아래와 같이 b = a로 리스트를 다른 변수에 할당하면 리스트는 두 개가 될 것 같지만 실제로는 리스트가 한개이다.a = [0, 0, 0, 0, 0]b = aa와 b를 is 연산자로 비교해보면 True가 나온다. 즉, 변수 이름만 다를 뿐 리스트 a와 b는 같은 객체이다. a와 b는 같으므로 b[2] = 99와 같이 리스트 b의 요소를 변경하면 a와 b에 모두 반영된다.a is bTrue&gt;&gt;&gt; b[2] = 99&gt;&gt;&gt; a[0, 0, 99, 0, 0]&gt;&gt;&gt; b[0, 0, 99, 0, 0]리스트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 한다. b = a.copy()와 같이 copy를 사용한 뒤 b에 할당해주면 리스트 a의 요소가 모두 b에 복사된다.a = [0, 0, 0, 0, 0]b = a.copy()a와 b를 is 연산자로 비교해 보면 False가 나온다. 즉, 두 리스트는 다른 객체이다. 그러나 복사된 요소는 같으므로 ==로 비교하면 True가 나온다. 이제 리스트 a와 b는 별개이므로 한쪽의 값을 변경해도 다른 리스트에 영향을 미치지 않는다. b의 요소를 변경해도 a의요소는 바뀌지 않았다.&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; b[2] = 99&gt;&gt;&gt; a[0, 0, 0, 0, 0]&gt;&gt;&gt; b[0, 0, 99, 0, 0]3. 반복문으로 리스트의 요소를 모두 출력하기리스트와 반복문을 사용해 모든 요소를 출력해 보자.for 반복문으로 요소 출력하기for 반복문은 in뒤에 리스트를 지정한다.for 변수 in 리스트:     반복할 코드다음은 for로 리스트 a의 모든 요소를 출력한다. for i in a:는 리스트 a에서 요소를 꺼내서 i에 저장하고, 꺼낼 때마다 코드를 반복한다.a = [38, 21, 53, 62, 19]for i in a:     print(i)3821536219인덱스와 요소를 함께 출력하기for 반복문으로 요소를 출력할 때 인덱스도 함께 출력 해야 할 이때는 enumerate를 사용한다.  for 인덱스, 요소 in enumerate(리스트):for index, value in enumerate(a):와 같이 enumerate에 리스트를 넣으면 for 반복문에서 인덱스와 요소를 동시에 꺼내 올 수 있다.a = [38, 21, 53, 62, 19]for index, value in enumerate(a):     print(index, value)0 381 212 533 624 19앞의 코드는 인덱스를 0부터 출력하는데 1부터 출력하고 싶을 수도 있습니다. 다음과 같이 그냥 index + 1을 출력하면 되겠다.for index, value in enumerate(a):     print(index + 1, value)1 382 213 534 625 19위와같이 +1을 해줘도 되지만 다음과 같이 enumerate에 start를 지정해주면 된다. enumerate(a, start=1)처럼 start에 1을 지정하여 인덱스가 1부터 시작하도록 만들었다.  for 인덱스, 요소 in enumerate(리스트, start=숫자):for index, value in enumerate(a, start=1):     print(index, value)1 382 213 534 625 19for 반복문에서 인덱스로 요소를 출력하기for에서 인덱스를 지정하여 요소를 가져올 때는 range에 len으로 리스트의 길이(요소 개수)를 구해서 넣어주면 인덱스를 순서대로 만들어준다.a = [38, 21, 53, 62, 19]for i in range(len(a)):     print(a[i])3821536219while반복문으로 요소 출력하기이번에는 while 반복문으로 리스트의 요소를 출력해보자. len(a)는 5이고 index의 가장 큰 값은 4이기 때문에 i가 0부터 4까지 while문이 돌게 된다.a = [38, 21, 53, 62, 19]i = 0while i &lt; len(a):     print(a[i])     i += 13821536219만약 i &lt;= len(a)처럼 &lt;=을 사용하면 리스트의 범위를 벗어나게 되므로 주의해야 한다.a = [38, 21, 53, 62, 19]i = 0while i &lt;= len(a):     print(a[i])     i += 13821536219Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;IndexError: list index out of rangewhile 반복문 안에서 요소를 출력할 때는 print(a[i])와 같이 리스트의 인덱스 부분에 i를 지정하여 출력한다. 그다음에는 i가 1씩 증가하도록 만들면 된다.while i &lt; len(a):    print(a[i])    i += 1",
        "url": "/python-basic19"
    }
    ,
    
    "practice-2": {
        "title": "Python으로 웹 스크래퍼 만들기-1",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python으로 웹 스크래퍼 만들기-1indeed.py파일import requestsfrom bs4 import BeautifulSoupLIMIT = 50URL = f\"https://kr.indeed.com/%EC%B7%A8%EC%97%85?q=python&amp;limit={LIMIT}&amp;radius=25&amp;start=0&amp;vjk=0699e6dbb5a0ec38\"def get_last_page():  result = requests.get(URL)  soup = BeautifulSoup(result.text,\"html.parser\")  # html의 내용을 가져온다.  pagination = soup.find(\"div\",{\"class\" : \"pagination\"})  # html의 내용중 pagination을 찾는다.                            links = pagination.find_all('a')  pages = [] #for반복문으로 찾은 link을 리스트에 담아주기 위해서 pages라는 빈 리스트를 생성.  for link in links[:-1]:    pages.append(int(link.string)                )  max_page = pages[-1]  return max_pagedef extract_job(html):    title = html.find(\"span\",title=True).text    company = html.find(\"span\", {\"class\" : \"companyName\"}).string    location = html.find(\"div\",{\"class\" : \"companyLocation\"}).string    job_id = html[\"data-jk\"]    return{'title': title, 'company': company, 'location': location,'link' : f\"https://kr.indeed.com/%EC%B7%A8%EC%97%85?q=python&amp;radius=25&amp;start=50&amp;vjk={job_id} \"}def extract_jobs(last_pages):  jobs = []  for page in range(last_pages):    print(f\"Scrapping page {page}\")    result = requests.get(f\"{URL}&amp;start={page*LIMIT}\")    soup = BeautifulSoup(result.text,\"html.parser\")    results = soup.find_all('a',{\"class\" : \"fs-unmask\"} )    for result in results:      job = extract_job(result)      jobs.append(job)  return(jobs)def get_jobs():  last_page = get_last_page()  jobs = extract_jobs(last_page)  return jobsmain.pyfrom indeed import get_jobs as get_indeed_jobsfrom so import get_jobs as get_so_jobs#indeed_jobs = get_indeed_jobs()so_jobs = get_so_jobs()#print(indeed_jobs)so.pyimport requestsfrom bs4 import BeautifulSoup# s-paginationURL = f\"https://stackoverflow.com/jobs/companies?q=python\"def get_last_page():  result = requests.get(URL)  soup = BeautifulSoup(result.text, \"html.parser\")    pages = soup.find(\"div\", {\"class\":\"s-pagination\"}).find_all(\"a\")  last_page = pages[-2].get_text(strip=True)  return int(last_page)def extract_jobs(last_page):  jobs = []  for page in range(last_page):    result = requests.get(f\"{URL}&amp;pg={page+1}\")    soup = BeautifulSoup(result.text, \"html.parser\")    results = soup.find_all(\"div\", {\"class\":\"d-flex\"})    for result in results:      print(results)          def get_jobs():  last_page = get_last_page()  jobs = extract_jobs(last_page)  return jobs",
        "url": "/practice-2"
    }
    ,
    
    "python-basic18": {
        "title": "Python - Python 터틀 그래픽스로 그림 그리기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기터틀 그래픽스로 그림 그리기터틀 그래픽스(Turtle graphics) 모듈을 사용해서 간단한 그림을 그려보자.1. 사각형 그리기t.shape(‘turtle’)까지 입력하면 파이썬 터틀 그래픽스(Python Turtle Graphics) 창이 표시되고 오른쪽을 바라보는 거북이가 나온다.import turtle as tt.shape('turtle')t.forward(100)t.forward(100)을 입력하면 거북이를 100픽셀만큼 앞으로 이동시킨다. t.right(90)를 입력하면 거북이가 오른쪽으로 90도 회전한다. 다시 t.forward(100)을 입력하면 회전한 방향에서 100픽셀 만큼 이동하게된다. 이런식으로 반복하여 사각형을 그려보자.  fd, bk, lt, rt 같이 짧게 줄여서 입력할 수 있다.  앞으로 이동: forward, fd  뒤로 이동: backward, bk, back  왼쪽으로 회전: left, lt  오른쪽으로 회전: right, rtimport turtle as t t.shape('turtle') t.fd(100)t.rt(90)t.fd(100)t.rt(90)t.fd(100)t.rt(90)t.fd(100)2. 다각형 그리기이번에는 반복문을 사용해 사각형을 그려보자.import turtle as t t.shape('turtle')for i in range(4):    # 사각형이므로 4번 반복    t.forward(100)    t.right(90)오각형 그리기오각형의 한각의 크기는 360/5를 하여 구할 수 있다.import turtle as t t.shape('turtle')for i in range(5):      # 오각형이므로 5번 반복    t.forward(100)    t.right(360 / 5)    # 360을 5로 나누어서 외각을 구함입력값에 해당하는 다각형 그리기이 소스 코드를 응용해서 사용자가 숫자를 입력하면 해당 숫자에 해당하는 다각형을 그려보자.import turtle as t n = int(input())        # 사용자의 입력을 받음t.shape('turtle')for i in range(n):      # n번 반복    t.forward(100)    t.right(360 / n)    # 360을 n으로 나누어서 외각을 구함다각형에 색칠하기소스 코드를 실행해보면 빨간색 육각형이 나온다. 먼저 color는 펜의 색을 설정한다. 여기서는 ‘red’를 지정하여 빨간색으로 만들었다. 그리고 도형을 그리기 전에 t.begin_fill()로 색칠할 준비를 한다. 그다음에 for 반복문으로 도형을 그린 뒤에 t.end_fill()을 사용하면 도형에 현재 펜 색이 칠해진다. 색은 rgb 코드로도 입력할 수 있다.import turtle as t n = 6    # 육각형t.shape('turtle')t.color('red')          # 펜의 색을 빨간색으로 설정t.begin_fill()          # 색칠할 영역 시작for i in range(n):      # n번 반복    t.forward(100)    t.right(360 / n)    # 360을 n으로 나누어서 외각을 구함t.end_fill()            # 색칠할 영역 끝    3. 복잡한 도형 그리기이번에는 원을 그려보자. 터틀에서 원을 그릴 때는 circle을 사용한다. t.circle에 120을 지정하여 반지름이 120인 원을 그렸다.import turtle as tt.shape('turtle')t.circle(120)원을 반복해서 그리기for 반복문을 사용해 원을 반복해서 그려보자. 오른쪽으로 6도씩 회전하면서 원을 그리게 된다. speed는 거북이의 속도를 설정한다. 속도는 다음과 같이 문자열 또는 숫자로 설정할 수 있다(숫자는 0.5부터 10까지 설정할 수 있다). 여기서는 ‘fastest’를 지정해서 가장 빠른 속도로 그렸다.  ‘fastest’: 0  ‘fast’: 10  ‘normal’: 6  ‘slow’: 3  ‘slowest’: 1import turtle as t n = 60    # 원을 60번 그림t.shape('turtle')t.speed('fastest')      # 거북이 속도를 가장 빠르게 설정for i in range(n):    t.circle(120)       # 반지름이 120인 원을 그림    t.right(360 / n)    # 오른쪽으로 6도 회전선으로 복잡한 무늬 그리기이번에는 선을 이용해서 복잡한 무늬를 그려보자. 소스 코드를 실행해보면 복잡한 무늬가 그려진다. 먼저 for로 i가 0부터 299까지 반복하는데 forward로 i만큼 앞으로 이동하도록 만들었다. 즉, 반복할 때마다 선이 길어진다. 그리고 right로 91도 회전했다. 이렇게 하면 미세하게 틀어진 사각형이 그려지면서 바깥으로 퍼져 나가게 된다. 각자 반복 횟수, 선의 길이, 각도를 조금씩 바꿔가면서 그려보자.import turtle as t t.shape('turtle')t.speed('fastest')      # 거북이 속도를 가장 빠르게 설정for i in range(300):    # 300번 반복    t.forward(i)        # i만큼 앞으로 이동. 반복할 때마다 선이 길어짐    t.right(91)         # 오른쪽으로 91도 회전예제표준 입력으로 삼각형의 높이가 입력됩니다. 입력된 높이만큼 산 모양으로 별을 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 출력 결과는 예제와 정확히 일치해야 합니다. 모양이 같더라도 공백이나 빈 줄이 더 들어가면 틀린 것으로 처리됩니다.count = int(input())for i in range(count): # 0~4    for j in reversed(range(count)): #4~0        if j &gt; i:            print(' ', end='')        else :            print('*', end='')    print('*'*i)",
        "url": "/python-basic18"
    }
    ,
    
    "python-basic17": {
        "title": "Python - Python FizzBuzz 문제",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기FizzBuzz 문제FizzBuzz는 매우 간단한 프로그래밍 문제이며 규칙은 다음과 같다.  1에서 100까지 출력  3의 배수는 Fizz 출력  5의 배수는 Buzz 출력  3과 5의 공배수는 FizzBuzz 출력1. 1부터 100까지 숫자 출력하기FizzBuzz 문제는 반복문, 조건문, 나머지 연산자, 비교 연산자를 모두 동원해야 풀 수 있다. 먼저 1부터 100까지 숫자를 출력해보자.for i in range(1, 101):    # 1부터 100까지 100번 반복    print(i)# 출력123... (생략)98991002. 3의 배수일 때와 5의 배수일 때 처리하기이제 3의 배수와 5의 배수일 때 숫자 대신 ‘Fizz’, ‘Buzz’를 출력해보자. i를 3으로 나눈 나머지가 0이면 Fizz를 출력하고 i를 5를 나눈 나머지가 0이면 Buzz를 출력한다. 3과5를 나누었을때 나머지가 0이 아닌i는 그대로 출력하게 한다.for i in range(1, 101):    # 1부터 100까지 100번 반복    if i % 3 == 0:         # 3의 배수일 때        print('Fizz')      # Fizz 출력    elif i % 5 == 0:       # 5의 배수일 때        print('Buzz')      # Buzz 출력    else:        print(i)           # 아무것도 해당되지 않을 때 숫자 출력# 출력    12Fizz... (생략)9798FizzBuzz3. 3과 5의 공배수 처리하기3과 5의 공배수를 처리하는 코드를 작성하자. 3과 5의 배수이면 FizzBuzz를 출력하려면 and 연산자를 사용한다. and는 두 값이 모두 True여야 True로 판정한다. i % 3 == 0 and i % 5 == 0로 작성해줘야하고 만약 i가 30일때 3의 배수를 먼저 검사하면 3과 5의 공배수는 검사하지 않고 넘어가기 때문에 3과 5의 공배수를 먼저 검사한뒤 elif로 3의 배수, 5의 배수를 검사해야 한다.for i in range(1, 101):              # 1부터 100까지 100번 반복    if i % 3 == 0 and i % 5 == 0:    # 3과 5의 공배수일 때        print('FizzBuzz')            # FizzBuzz 출력    elif i % 3 == 0:                 # 3의 배수일 때        print('Fizz')                # Fizz 출력    elif i % 5 == 0:                 # 5의 배수일 때        print('Buzz')                # Buzz 출력    else:        print(i)                     # 아무것도 해당되지 않을 때 숫자 출력#출력12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz4. 논리 연산자를 사용하지 않고 3과 5의 공배수 처리하기and를 사용하지 않고 3과 5의 공배수를 검사하게 만들어보자. 3과5의 최소공배수는 15임으로 15로 나누었을때 나머지가 0인 i를 FizzBuzz로 출력해주면 된다. 하지만 실무에서는 i % 3 == 0 and i % 5 == 0처럼 의미를 명확하게 드러내는 것이 좋다.for i in range(1, 101):      # 1부터 100까지 100번 반복    if i % 15 == 0:          # 15의 배수(3과 5의 공배수)일 때        print('FizzBuzz')    # FizzBuzz 출력    elif i % 3 == 0:         # 3의 배수일 때        print('Fizz')        # Fizz 출력    elif i % 5 == 0:         # 5의 배수일 때        print('Buzz')        # Buzz 출력    else:        print(i)             # 아무것도 해당되지 않을 때 숫자 출력# 결과 12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz5. 코드 단축하기이번에는 코드를 단축해 문제를 해결해 보자. 파이썬에선 문자열에 True를 곱하면 문자열이 그대로 출력되고, False를 곱하면 문자열이 출력되지 않는다. True는 1, False는 0으로 연산되기 때문이다. Fizz뒤의 불과, Buzz뒤의 불이 모두 충족되면 +를 사용해 FizzBuzz를 출력하게 하고, or 연산자로 앞의 두 불이 False여도 i를 출력하게 만들었다. 0이 아닌 숫자가 i에 오면 True이기 때문에 3과 5의 배수나 공배수가 아니더라도 i의 값이 출력된다.for i in range(1, 101):    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)    # 문자열 곱셈과 덧셈을 이용하여 print 안에서 처리# 결과 12Fizz... (생략)FizzBuzz9192Fizz94BuzzFizz9798FizzBuzz",
        "url": "/python-basic17"
    }
    ,
    
    "python-basic16": {
        "title": "Python - Python 중첩루프",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기중첩루프이번에는 지금까지 배운 for 반복문과 if 조건문을 사용하여 계단식으로 별(*)을 출력해보자.***************1. 중첩 루프 사용하기콘솔(터미널, 명령 프롬프트)은 2차원 평면이므로 별을 일정한 모양으로 출력하려면 반복문을 두 개 사용하는 것이 편리하다. i를 사용하는 바깥루프는 세로방향을 처리하고, j를 사용하는 안쪽 루프는 가로 방향을 처리한다.첫번째 for문 i가 0일때 두번째 for문 j는 0부터 4까지의 j를 출력한다. 출력후 다음 print문에서 줄바꿈을 출력하게되고 다시 i = 1로 시작해 두번쨰 for문을 돈다.for i in range(5):          # 5번 반복. 바깥쪽 루프는 세로 방향    for j in range(5):      # 5번 반복. 안쪽 루프는 가로 방향        print('j:', j, sep='', end=' ')    # j값 출력. end에 ' '를 지정하여 줄바꿈 대신 한 칸 띄움    print('i:', i, '\\\\n', sep='')    # i값 출력, 개행 문자 모양도 출력                                     # 가로 방향으로 숫자를 모두 출력한 뒤 다음 줄로 넘어감                                     # (print는 기본적으로 출력 후 다음 줄로 넘어감)# 출력j 0 j 1 j 2 j 3 j 4 I 0 //nj 0 j 1 j 2 j 3 j 4 I 1 //nj 0 j 1 j 2 j 3 j 4 I 2 //nj 0 j 1 j 2 j 3 j 4 I 3 //nj 0 j 1 j 2 j 3 j 4 I 4 //n중첩 루프는 2차원 평면을 다룰 수 있다. 영상처리, 이미지 처리, 좌표계 처리 등에 주로 쓰인다.2. 사각형으로 별 출력하기중첩 반복문으로 5x5 사각형 별을 그려보자. 안쪽의 for문을 실행하면 가로방향으로 이5개 출력된다. 5번 반복해 print()를 하는데 끝에 end=’‘를 사용해 줄바꿈을 하지 않기 때문이다. 바깥쪽의 for i in range(5):의 경우 안쪽의 for j in range(5):를 5번 반복한다. 마지막 print()는 기본적으로 end=’\\n’ 상태이므로 아무것도 기입하지 않아도 \\n은 출력되어 줄바꿈을 해주게 된다.for i in range(5) :    for j in range(5):        print('*', end='')    print()# 출력    *************************사각형 모양 바꾸기이제 for 반복문의 조건식을 수정하여 사각형의 모양을 바꿔보자.for i in range(3):            # 3번 반복. 세로 방향    for j in range(7):        # 7번 반복. 가로 방향        print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)#출력*********************3. 계단식으로 별 출력하기계단식으로 별을 출력해 보자. 계단식으로 출력하려면 출력하지 않는 부분이 있기 때문에 if문을 사용한다. j &lt;= i로 i가 1일때 j는 1보다 작거나 같아야만 출력이된다.for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향        if j &lt;= i:                # 세로 방향 변수 i만큼            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)#출력***************대각선으로 별 출력하기별을 대각선으로 출력해 보자. i = 1일때 *출력 이후 else부분의 공백이 4개 들어가게 된다.for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향        if j == i:                # 세로 방향 변수와 같을 때            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음        else:                     # 세로 방향 변수와 다를 때            print(' ', end='')    # 공백 출력. end에 ''를 지정하여 줄바꿈을 하지 않음    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감               # (print는 출력 후 기본적으로 다음 줄로 넘어감)# 결과 * *  *   *    *예제표준 입력으로 삼각형의 높이가 입력됩니다. 입력된 높이만큼 산 모양으로 별을 출력하는 프로그램을 만드세요(input에서 안내 문자열은 출력하지 않아야 합니다). 이때 출력 결과는 예제와 정확히 일치해야 합니다. 모양이 같더라도 공백이나 빈 줄이 더 들어가면 틀린 것으로 처리됩니다.count = int(input())for i in range(count): # 0~4    for j in reversed(range(count)): #4~0        if j &gt; i:            print(' ', end='')        else :            print('*', end='')    print('*'*i)",
        "url": "/python-basic16"
    }
    ,
    
    "python-basic15": {
        "title": "Python - Python break, continue로 반복문 제어하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기break, continue로 반복문 제어하기break와 continue를 사용해 반복문을 제어하는 방법을 알아보자. break는 for와 while의 문법에서 제어흐름을 벗어나기 위해 사용한다. 즉, 루프를 중단한다. continue는 제어흐름을 유지한 상태에서 코드의 실행만 건너뛴다.  break: 제어흐름 중단  continue: 제어흐름 유지, 코드 실행만 건너뜀1. break로 반복문 끝내기break를 사용해 for와 while 에서 반복을 끝내는 방법을 알아보자.while에서 break로 반복문 끝내기while 무한 루프에서 숫자를 증가시키다 변수 i가 100일 때 반복문을 끝내도록 만들었다. i값을 출력하고 증가시키므로 99까지 출력하고 반복을 멈추게 된다.i = 0while True:    # 무한 루프    print(i)    i += 1          # i를 1씩 증가시킴    if i == 100:    # i가 100일 때        break       # 반복문을 끝냄. while의 제어흐름을 벗어남#결과012... (생략)979899for에서 break로 반복문 끝내기for에 range(10000)을 지정했다. 0부터 9999까지 반복하는데 i 가 100일때 break를 실행 함으로 0부터 100까지만 출력하고 반복문을 끝낸다. 100일때 100을 출력하고 반복을 멈추게 된다.for i in range(10000):    # 0부터 9999까지 반복    print(i)    if i == 100:    # i가 100일 때        break       # 반복문을 끝냄. for의 제어흐름을 벗어남#출력012... (생략)98991002. continue로 코드 실행 건너뛰기continue를 사용해 일부 코드를 실행하지 않고 건너 뛰어 보자.for에서 continue로 코드 실행 건너뛰기for반복문에 range(100)를 사용해 0부터 99까지 반복한다. 그리고 if를 사용해 i가 짝수이면 continue를 실행한다. 마지막으로 print i의 값을 출력하고 99 까지 출력후 종료된다.for i in range(100):       # 0부터 99까지 증가하면서 100번 반복    if i % 2 == 0:         # i를 2로 나누었을 때 나머지가 0면 짝수        continue           # 아래 코드를 실행하지 않고 건너뜀    print(i)# 결과135... (생략)959799while 반복문에서 continue로 코드 실행 건너뛰기while i &lt; 100 : 으로 0부터 99까지 반복한다. i값을 1씩증가시킨뒤 if를 사용해 i가 짝수이면 continue를 실행한다. i의 초기값은 0이고 i +=1로 1로증가시킨 값부터 시작한다.i = 0while i &lt; 100:        # i가 100보다 작을 때 반복. 0부터 99까지 증가하면서 100번 반복    i += 1            # i를 1씩 증가시킴    if i % 2 == 0:    # i를 2로 나누었을 때 나머지가 0이면 짝수        continue      # 아래 코드를 실행하지 않고 건너뜀    print(i)만약 무한루프에서 continue를 사용하면 홀수만 계속 출려될 뿐 반복문은 끝나지 않는다.반복문과 passfor, while의 반복할 코드에서 아무 일도 하지 않지만, 반복문의 형태를 유지하고 싶다면 pass를 사용하면 된다.for i in range(10):    # 10번 반복    pass               # 아무 일도 하지 않음while True:    # 무한 루프    pass       # 아무 일도 하지 않음3. 입력한 횟수대로 반복하기count에 input으로 입력을 받아 count변수에 저장하고 i에 0을 항당해 while True를 지정한 무한 루프로 만든다. 반복문 안에서는 i의 값을 출력하고, 변화식 에서는 i를 1씩증가시킨다. i의 값이 count의 값과 같으면 break를 실행한다.count = int(input('반복할 횟수를 입력하세요: ')) i = 0while True:    # 무한 루프    print(i)    i += 1    if i == count:    # i가 입력받은 값과 같을 때        break         # 반복문을 끝냄#출력반복할 횟수를 입력하세요: 3 (입력)012입력한 숫자까지 홀수 출력하기input으로 입력 값을 받아서 count 변수에 저장했다. 그리고 for의 range에 count + 1을 지정하여 count에 들어있는 값만큼 반복하도록 만들었다. 왜냐하면 range(count)는 0부터 시작하므로 count의 값은 반복에 포함되지 않기 때문이다.반복문 안에서는 if를 사용하여 i가 짝수이면 continue를 실행한다. 그다음에 print를 사용하여 i의 값을 출력한다.여기서는 9를 입력했으므로 0부터 9까지 반복하면서 i가 짝수이면 print를 실행하지 않고 건너뛰며 i가 홀수이면 print를 사용하여 숫자를 출력한다. 따라서 1 3 5 7 9가 출력된다.count = int(input('반복할 횟수를 입력하세요: ')) for i in range(count + 1):       # 0부터 증가하면서 count까지 반복(count + 1)    if i % 2 == 0:               # i를 2로 나누었을 때 나머지가 0이면 짝수        continue                 # 아래 코드를 실행하지 않고 건너뜀    print(i)# 결과 반복할 횟수를 입력하세요: 9 (입력)13579",
        "url": "/python-basic15"
    }
    ,
    
    "python-basic14": {
        "title": "Python - Python while 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기while 반복문while 반복문은 조건식으로만 동작하며 반복할 코드 안에 조건식에 영향을 주는 변화식이 들어간다.여기서는 조건식 → 반복할 코드 및 변화식 → 조건식으로 순환하는 부분이 루프(loop)이다.i = 0                     # 초기식while i &lt; 100:            # while 조건식     print('Hello, world!')    # 반복할 코드     i += 1                    # 변화식while반복문은 초기식부터 시작해 조건식을 판별하고 이때 조건식이 참(True)이면 반복할 코드와 변화식을 함께 수행한다. 그리고 다시 조건식을 판별하여 참(True)이면 코드를 계속 반복하고, 거짓(False)이면 반복문을 끝낸 뒤 다음 코드를 실행한다.1. while 반복문 사용하기다음과 같이 whil반복문은 조건식을 지정하고 끝에 :(클론)을 붙여준다. 그리도 다음줄에 반복할 코드와 변화식을 넣어준다.초기식while 조건식:     반복할 코드     변화식while 다음줄에 오는 코드는 반드시 들여쓰기를 해줘야한다. while 반복문으로 ‘Hello, world!’를 100번 출력해보자. 먼저 while 반복문에 변수 i에 0을 할당하고 조건식을 지정한다. 그리고 변화식을 정해줘야하는데 이때 조건식만 지정하고 변화식을 지정하지 않으면 무한루프가 되므로 변화식을 꼭 써야한다.i = 0while i &lt; 100 :    print('Hello, world!')    i += 1 # i를 1씩 증가시킨다. i = i + 1#출력Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!Hello, world!.....초깃값을 1부터 시작하기초기 값을 1로 할당하여 ‘Hello, world!’를 100번 출력해 보자. i가 0부터라면 99까지 나오면 100번이기 때문에 i &lt; 100 이지만 1부터기 때문에 i &lt;=100으로 작성해 줘야한다.i가 101이 되면 i &lt;= 100은 거짓( False)이므로 반복문을 끝낸다.i = 1while i &lt;= 100:    print('Hello, world!', i)    i += 1#출력Hello, world! 1Hello, world! 2Hello, world! 3...  (생략)Hello, world! 99Hello, world! 100초깃값을 감소시키기지금까지 초기값을 증가시키면서 루프를 실행했다. 반대로 초깃값을 크게주고, 변수를 감소시키면서 반복해 보자. 시작 값은 100이고 조건식을 i&gt;0과 같이 지정해 1까지만 반복하도록 만들었다. 변화식은 i-=1로 지정해 변수의 값을 1씩 감소시킨다. i가 0이되면 i&gt;0은 거짓(False)가 되기떄문에 반복이 종료된다.i = 100while i &gt; 0:    print('Hello, world!', i)    i -= 1 # i = i-1#출력Hello, world! 100Hello, world! 99Hello, world! 98... (생략)Hello, world! 2Hello, world! 1입력한 횟수대로 반복하기입력한 횟수대로 반복을 해보자. input입력값을 3으로 입력하고 반복을 실행하면 3번 반복하게된다. 반복문의 조건을 i &lt; count로 지정해 count에 들어있는 값만큼 반복하도록 만들었다.count = int(input('반복할 횟수를 입력하세요: ')) i = 0while i &lt; count:     # i가 count보다 작을 때 반복    print('Hello, world!', i)    i += 1# 출력Hello, world! 0Hello, world! 1Hello, world! 2초깃값을 받은 뒤 초깃값만큼 출력하게 만들었다. 여기서는 변수 i 대신 count를 바로 사용하므로 변화식을 count -= 1로 지정하여 반복할 때마다 count를 감소시키고 count가 0이 되면 반복문을 끝낸다.count = int(input('반복할 횟수를 입력하세요: ')) while count &gt; 0:     # i가 count보다 작을 때 반복    print('Hello, world!', count)    count -= 1# 출력Hello, world! 3Hello, world! 2Hello, world! 12. 반복 횟수가 정해지지 않은 경우지금까지 조건식에서 반복 횟수를 정한 뒤 변수 i를 증가시키거나 감소시켜 while 반복문을 사용했다. 하지만 while 반복문은 반복 횟수가 정해지지 않았을 때 주로 사용한다. 이번에는 난수를 생성해서 숫자에 따라 반복을 끝내 보자. 난수(random number)란 특정 주기로 반복되지 않으며 규칙 없이 무작위로 나열되는 숫자를 뜻한다.파이썬에서 난수를 생성하려면 random 모듈이 필요하다. 모듈은 다음과 같이 import 키워드를 사용하여 가져올 수 있다.  import 모듈import random    # random 모듈을 가져옴이제 random.random() 으로 random모듈의 random함수를 호출해 보자.random.random()0.6308359530867019random.random()0.9884423768957599random.random()0.526192298540528숫자를 알아보기 쉽도록 정수를 생성하는 random모듈의 randint함수를 사용해보자. randint 함수는 난수를 생성할 범위를 지정하며, 범위에 지정한 숫자도 난수에 포함된다.random. randint(1, 6)2random. randint(1, 6)4random. randint(1, 6)3random. randint(1, 6)5random.randint(1, 6)과 while반복문을 사용해보자. 아래 코드는 1에서 6사이의 난수를 생성하고 3이 나오면 반복을 끝낸다.i = 0while i != 3: # i가 3이 아닐때 계속 반복    i = random.randint(1, 6)    print(i)    12113 # 3이 나와 종료,random.choicerandom.choice 함수를 사용하면 시퀀스 객체에서 요소를 무작위로 선택할 수 있다. 다음은 1, 2, 3, 4, 5, 6이 들어있는 리스트에서 무작위로 숫자를 선택한다. random.choice 함수는 시퀀스 객체를 받으므로 리스트뿐만 아니라 튜플, range, 문자열 등을 넣어도 된다.dice = [1, 2, 3, 4, 5, 6]random.choice(dice)1random.choice(dice)4random.choice(dice)33. while 반복문으로 무한 루프 만들기while 반복문으로 무한 루프를 만들어 보자.while True:    # while에 True를 지정하면 무한 루프    print('Hello, world!')# 출력... (생략)Hello, world!Hello, world!Hello, world!Hello, world!... (계속 반복)while에 True대신 True로 취급하는 값을 사용해도 무한 루프로 동작한다.while 1:    # 0이 아닌 숫자는 True로 취급하여 무한 루프로 동작    print('Hello, world!')while 'Hello':    # 내용이 있는 문자열은 True로 취급하여 무한 루프로 동작    print('Hello, world!')",
        "url": "/python-basic14"
    }
    ,
    
    "python-basic13": {
        "title": "Python - Python for 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기for 반복문‘Hello, world!’문자열을 100번 출력하려면 print를 100번 사용하면 되지만, for문을 사용해 반복하는 기능을 알아보자.1. for와 range 사용하기파이썬의 for반복문은 다양한  사용 방법이 있지만, 먼저 range와 함께 사용하는 방법부터 알아보자. 다음과 같이 for 반복문은 range에 반복할 횟수를 지정하고 앞에 in과 변수를 입력한다. 그리고 :(클론)을 붙이고 다음 중ㄹ에 반복할 코드를 입력한다. for다음 줄에 오는 코드는 반드시 들여쓰기를 해준다.for 변수 in range(횟수):     반복할 코드‘Hello, world!’를 100번 출력해 보자. range(100)과 같이 지정하면 0부터 99까지 숫자 100개를 생성한다. 그리고 for는 in으로 숫자를 하나씩 꺼내 변수i에 지정하고, print를 실행한다. 즉, range(100)에서 숫자를 100번 꺼내면서 print를 실행하므로 ‘Hello, world!’가 100번 출력되게 된다.for i in range(100) :    print('Hello, world!')for 변수 in range(횟수) → 반복할 코드로 순환하는 것을 루프(loop)라고 부른다.반복문에서 변수의 변화 알아보기‘Hello, world!’를 100번 출력하는 동시에 i의 값을 확인해보자.for i in range(100) :    print('Hello, world!',i)변수 i를 루프 인덱스라고도 부르며 index의 첫 머리글자를 따서 i를 주로 사용한다.2. for와 range 응용하기이번에는 range의 다양한 기능을 활용하여 for반복문을 사용해보자.시작하는 숫자와 끝나는 숫자 지정하기range에 횟수만 지정하면 숫자가 0부터 시작하지만, 다음과 같이 시작하는 숫자와 끝나는 숫자를 지정해 반복할 수도 있다. for i in range(5, 12):와 같이 지정하면 5부터 11까지 5, 6, 7, 8, 9, 10, 11이 나오고 7번 반복한다. 즉, 마지막 숫자는 range의 끝나는 숫자보다 1이 작다(끝나는 숫자는 생성된 숫자에 포함되지 않음).for i in range(5, 12) : # 5부터 11까지의 숫자를 생성    print('Hello, world!', i)#출력Hello, world! 5Hello, world! 6Hello, world! 7Hello, world! 8Hello, world! 9Hello, world! 10Hello, world! 11증가폭 사용하기range는 증가폭을 지정해서 해당 값만큼 숫자를 증가시킬 수 있다.  for 변수 in range(시작, 끝, 증가폭):for i in range(0, 10, 2) :    print('Hello, world!', i)#출력Hello, world! 0Hello, world! 2Hello, world! 4Hello, world! 6Hello, world! 8숫자를 감소시키기for과 range는 숫자가 증가하면서 반복했다. 숫자를 감소시켜보자. range는 숫자가 증가하는 기본값이 양수 1이기 때문에 for i in range(10, 0)로 코드를 작성한다고 해서 숫자가 감소하지 않는다. range에 증가폭을 음수로 지정해 감소시킬 수 있다. 특히 range의 끝나는 숫자 0은 생성되는 숫자에 포함되지 않으므로 1까지만 감소한다. range는 그냥 증가, 감소에 상관없이 끝나는 숫자는 생성되는 숫자에 포함되지 않는다는 점만 기억하자.for i in range(0, 10, -1) : # 10에서 1까지 1씩감소    print('Hello, world!', i)#출력Hello, world! 10Hello, world! 9Hello, world! 8Hello, world! 7Hello, world! 6Hello, world! 5Hello, world! 4Hello, world! 3Hello, world! 2Hello, world! 1증가폭을 음수로 지정하지 않고 reversed를 사용해 순서를 반대로 뒤집어 보자. reversed의 경우 range(10)을 반대로 뒤집은것 이기 때문에 0부터 9까지 숫자를 만들고 만들어진 숫자를 뒤집는다. 따라서 9~0까지의 숫자가 출력된다.  for 변수 in reversed(range(횟수))  for 변수 in reversed(range(시작, 끝))  for 변수 in reversed(range(시작, 끝, 증가폭))for i in reversed(range(10)) :    print('Hello, world!', i)#출력          Hello, world! 9Hello, world! 8Hello, world! 7Hello, world! 6Hello, world! 5Hello, world! 4Hello, world! 3Hello, world! 2Hello, world! 1Hello, world! 0반복문의 i변수를 할당해 보았다. 반복할 코에서 변수 i에 10을 할당하여 10이 출력될것 같은데, 0부터 9까지 출력되었다. 변수i는 반복할 때마다 다음 값으로 덮어써지기 때문에 값을 할당해도 변수에 영향을 주지 못한다.for i in range(10):     print(i, end=' ')     i = 10 0 1 2 3 4 5 6 7 8 9입력한 횟수대로 반복하기이번에는 입력한 횟수대로 반복을 해보자. count라는 변수에 input으로 입력값을 받아 for문에 range에 입력한 횟수를 count변수가 받아 반복문이 실행된다.count = int(input('반복할 횟수 입력: '))for i in range(count) :     print('Hello, world!', i)# 출력반복할 횟수 입력: 3          Hello, world! 0Hello, world! 1Hello, world! 23. 시퀀스 객체로 반복하기for문에 range대신 시퀀스객체를 넣어 반복을 실행해 보자. range대신 리스트를 넣어 실행해 보았다.a = [10, 20, 30, 40, 50]for i in a:    print(i)# 출력1020304050튜플을 넣어 실행해 보았다.fruits = ('apple', 'orange', 'grape')for fruits in fruits:    print(fruits)# 출력appleorangegrape문자열을 넣어 실행해 보자.for i in 'Python' :    print(i, end=' ')# 출력P y t h o n 문자열을 reversed로 뒤집어 출력해 보자.for i in reversed('Python') :    print(i, end=' ')# 출력n o h t y P ",
        "url": "/python-basic13"
    }
    ,
    
    "python-basic12": {
        "title": "Python - Python  elif를 사용하여 여러 방향으로 분기하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python elif를 사용하여 여러 방향으로 분기하기elif는 조건식을 여러 개 지정하여 각 조건 마다 다른 코드를 실행할 수 있다.if 콜라 버튼을 눌렀다면:    콜라를 내보냄elif 사이다 버튼을 눌렀다면:    사이다를 내보냄elif 환타 버튼을 눌렀다면:    환타를 내보냄:else:    제공하지 않는 메뉴1. elif 사용하기elif는 else인 상태에서 조건식을 지정할 때 사용하며 else if라는 뜻이다. 물론 if, else와 마찬가지로 조건식 끝에 :(콜론)을 붙여야 하고, elif 단독으로 사용할 수 없다.if 조건식:     코드1elif:     코드2x = 20if x == 10:    print('10이다.')elif x == 20:    print('20이다.')    # 20이다.if, elif, else를 모두 사용하기elif와 else는 단독으로 사용할 수 없으며 if, else 형태로 사용하거나, if, elif, else 형태로 사용한다. 이번에는 if, elif, else를 모두 사용해보자.if 조건식:    코드1elif 조건식:    코드2else:    코드3  아래 코드는 if, elif의 조건식이 모두 거짓일 때만 else의 코드가 실행된다. 여기서는 x가 30이라 if, elif의 조건식에 모두 만족하지 않는다. 따라서 마지막 else의 ‘10도 20도 아닙니다.’가 출력된다.x = 30 if x == 10:             # x가 10일 때    print('10입니다.')elif x == 20:           # x가 20일 때    print('20입니다.')else:                   # 앞의 조건식에 모두 만족하지 않을 때    print('10도 20도 아닙니다.') # 10도 20도 아닙니다.음료수 자판기 만들기버튼 1번은 ‘콜라’, 2번은 ‘사이다’, 3번은 ‘환타’이고 각 버튼에 따라 음료수 이름을 출력한다고 하자(1, 2, 3이외의 숫자는 ‘제공하지 않는 메뉴’ 출력).button = int(input()) if button == 1:    print('콜라')elif button == 2:    print('사이다')elif button == 3:    print('환타')else:    print('제공하지 않는 메뉴')# 1 (입력)# 콜라",
        "url": "/python-basic12"
    }
    ,
    
    "python-basic11": {
        "title": "Python - Python  else를 사용하여 두 방향으로 분기하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python else를 사용하여 두 방향으로 분기하기if 조건문은 분기를 위한 문법이다. 즉, 분기는 ‘둘이상으로 갈라지다’라는 뜻으로 프로그램의 흐름을 둘 이상으로 나누는 것을 말한다. if조건 문은 조건식에 맞는 코드를 실행한다. if에 else를 사용하면 조건식이 만족할 때와 만족하지 않을 때 각각 다른 코드를 실행할 수 있다.1. else 사용하기else는 if조건문 뒤에 오며 단독으로 사용할 수 없다. if와 마찬가지로 else도 :(콜론)을 붙이며 다음 줄에 실행할 코드가 온다.if 조건식:     코드1else:     코드2x = 5    if x == 10:         print('10입니다.')    else:         print('10이 아닙니다.')# 10이 아닙니다.if와 else의 기본 형태와 실행 흐름 알아보기else는 if의 조건식이 만족하지 않을 때 코드를 실행한다. 여기에서는 x에 5를 할당해서 x == 10을 만족하지 않음으로 else의 print가 실행되어 ‘10이 아닙니다.’가 출력된다.x = 5if x == 10:         print('10입니다.')    else:         print('10이 아닙니다.')# 10이 아닙니다.   변수에 값 할당을 if, else로 축약하기변수 x에 10이 들어있으면 y에 x를 할당하고, 아니면 y에 0을 할당하는 코드는 다음과 같이 만들수 있다.x = 5    if x == 10:        y = x    else:        y = 0y0이렇게 if, else에서 변수에 값을 할당할 때는 변수 = 값 if 조건문 else 값 형식으로 축약할 수 있으며 이런 문법을 조건부 표현식(conditional expression)이라고 부른다.x = 5y = x if x == 10 else 0y02. else와 들여쓰기else는 if와 들여쓰기 규칙이 같다. 다음은 들여쓰기가 잘못된 코드다.x = 5 if x == 10:    print('10입니다.') else:print('x에 들어있는 숫자는')    # unexpected indent 에러 발생     print('10이 아닙니다.')올바른 코드로 고쳐보자.if x == 10:    print('10입니다.') else:    print('x에 들어있는 숫자는')    print('10이 아닙니다.') else가 여러 줄일 때는 마지막 줄의 들여쓰기를 하지 않으면 의도치 않은 동작이 된다.x = 10 if x == 10:    # x가 10이라 조건식이 참    print('10입니다.')    # 출력else:     print('x에 들어있는 숫자는')print('10이 아닙니다.')    # 출력되지 않아야 하는데 출력됨x가 10이라는 조건식이 참이므로 ‘10입니다.’가 출력된다. 하지만 else의 ‘10이 아닙니다.’도 함께 출력되어 버렸다. print(‘10이 아닙니다.’)는 들여쓰기가 없어서 else와는 상관없는 코드가 되었기 때문이다. print를 한 줄 띄워보면 왜 잘못되었는지 알 수 있다.x = 10 if x == 10:    # x가 10이라 조건식이 참    print('10입니다.')else:    print('x에 들어있는 숫자는') print('10이 아닙니다.')3. if 조건문의 동작 방식 알아보기이번에는 조건식이 아닌 값으로 if와 else의 코드를 동작시켜 보자. True는 if 코드가 실행되고 Fasle는 else의 코드가 실행된다. 특히 None은 Fasle로 취급되므로 else의 코드가 실행 된다. 실제 코드를 작성할 때 변수에 들어있는 값이나 함수의 결과가 None인 경우가 많으므로 이 부분은 꼭 기억해두자.if True:    print('참')    # True는 참else:    print('거짓') if False:    print('참')else:    print('거짓')    # False는 거짓 if None:    print('참')else:    print('거짓')    # None은 거짓# 결과# 참# 거짓# 거짓if 조건문에 숫자 지정하기숫자는 정수(2진수, 10진수, 6진수), 실수와 관계없이 0이면 거짓, 0이 아닌 수는 참이다.if 0:    print('참')else:    print('거짓')    # 0은 거짓 if 1:    print('참')    # 1은 참else:    print('거짓') if 0x1F:    # 16진수    print('참')    # 0x1F는 참else:    print('거짓') if 0b1000:    # 2진수    print('참')    # 0b1000은 참else:    print('거짓') if 13.5:    # 실수    print('참')    # 13.5는 참else:    print('거짓')# 결과# 거짓# 참# 참# 참# 참if 조건문에 문자열 지정하기문자열은 내용이 있을때 참, 빈 문자열은 거짓이다.if 'Hello':    # 문자열    print('참')    # 문자열은 참else:    print('거짓') if '':    # 빈 문자열    print('참')else:    print('거짓')    # 빈 문자열은 거짓# 결과# 참# 거짓0, None, 빈 문자열을 not으로 뒤집으면?0, None, 빈 문자열 ‘‘을 not으로 뒤집으면 참(True)이 되므로 if를 동작시킬 수 있다.if not 0:    print('참')    # not 0은 참 if not None:    print('참')    # None은 참 if not '':    print('참')    # not 빈 문자열은 참# 결과# 참# 참# 참True, False로 취급하는 것들다음은 파이썬 문법 중에서 False로 취급하는 것들입니다.      None        False        0인 숫자들: 0, 0.0, 0j        비어 있는 문자열, 리스트, 튜플, 딕셔너리, 세트: ‘’, “”, [], (), {}, set()        클래스 인스턴스의 bool(), len() 메서드가 0 또는 False를 반환할 때  앞에서 나열한 것들을 제외한 모든 요소들은 True로 취급합니다.4. 조건식을 여러 개 지정하기지금까지 if에 조건식을 하나만 지정했다. 만약 조건이 복잡하다면 어떻게 해야할까? if 조건문에는 논리 연산자를 사용하여 조건식을 여러 개 지정할 수 있다. x == 10이고 y == 20처럼 and 논리 연산자를 사용하면 x == 10이면서 y == 20일 때 if 코드가 실행된다.x = 10y = 20 if x == 10 and y == 20:     # x가 10이면서 y가 20일 때    print('참')else:    print('거짓')만약 둘중 하나라도 만족했을때 ‘참’이 출력되도록 만드려면 or 논리 연산자를 사용하면 된다.중첩 if조건문과 논리 연산자보통 여러 조건을 판단할 때 if를 계속 나열해서 중첩 if 조건문으로 만드는 경우가 많다. 예를 들어 x가 양수이면서 20보다 작은지 판단하려고 한다. if로 x가 0보다 큰지 검사하고(0보다 크면 양수), 다시 if로 20보다 작은지 검사했다.x = 10y = 20 if x &gt; 0:    if x &lt; 20:        print('20보다 작은 양수입니다.')이런 중첩 if 조건문은 and 논리 연산자를 사용해서 if 하나로 줄일 수 있다.x = 10y = 20 if x &gt; 0 and x &lt; 20:    print('20보다 작은 양수입니다.')   위보다 더 간단하게 만들 수 있다.x = 10y = 20 if 0 &lt; x &lt; 20:    print('20보다 작은 양수입니다.')   ",
        "url": "/python-basic11"
    }
    ,
    
    "python-basic10": {
        "title": "Python - Python  if 조건문으로 특정 조건일 때 코드 실행하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python if 조건문으로 특정 조건일 때 코드 실행하기조건문은 특정 조건일 경우 코드를 실행하는 문법이다. 조건문은 여러 가지 상황을 처리해야 하는 경우 다양한 상황에 대처할 때 사용한다.1. if 조건문 사용하기if 조건문은 if에 조건식을 지정하고 :(클론)을 붙이며 다음줄에 실행할 코드가 나온다. 이때 코드는 반드시 들여쓰기를 해야한다.if 조건식 :  코드x = 10if x = 10 :    print('10입니다')    # 출력 : 10입니다.if 조건문의 기본 형태와 실행 흐름 알아보기파이썬에서 if 조건문은 if 조건식 : 형식으로 사용하며 그 다음 줄에는 들여쓰기를 한 뒤 조건식이 만족할 때 실행할 코드를 넣는다. 이 조건식이 만족할 때 실행할 코드를 if 본문(if body)이라고 부른다.if x == 10 : # 조건식    print('10입니다.') #if 본문# 들여쓰기4칸    if 의 조건식이 만족하면 참(True), 만족하지 않으면 거짓(False)이라고 부른다.if 조건문을 사용할 때 주의할 점if 조건문을 사용할 때 주의할 점이 있는데 파이썬에서는 =을 할당으로 사용하고 있으므로 값을 비교할때는 ==로 사용한다. 자주 틀리는 부분이니 if안에서 == 을 사용했는지 반드시 확인하자. 또한 :(클론)을 빠뜨리지 않도록 주의한다.if x = 10:   File \"&lt;stdin&gt;\", line 1    if x = 10:         ^SyntaxError: invalid syntax if x == 10    File \"&lt;stdin&gt;\", line 1    if x == 10             ^SyntaxError: invalid syntax if 조건문에서 코드를 생략하기if 조건문에 조건식만 작성하고 코드를 생략하는 방법을 알아보자. if 다음줄에 pass라는 특별한 키워드를 넣었다. 여기서 pass는 아무 일도 하지 않고 그냥 넘어간다는 뜻이다. 파이썬은 if 다음줄에 아무 코드도 넣지 않으면 에러가 발생하므로 if 조건문의 형태를 유지하기 위해 pass를 사용한다.pass는 아무 일도 하지 않는 코드라서 의미가 없을 것 같지만 나중에 작성해야 할 코드를 표시할 때 사용할 수 있다. 즉, 다음과 같이 pass만 넣고 나중에 할 일은 주석으로 남겨놓는 방식이다.if x == 10:    pass    # TODO: x가 10일 때 처리가 필요함  TODO : TODO는 해야 할 일이라는 뜻인데 보통 주석에 넣는다. 이렇게 TODO를 넣어 두면 검색으로 쉽게 찾을 수 있다.그래서 프로그래머들은 주석에 TODO 이외에도 FIXME, BUG, NOTE 등과 같이 코드는 아니지만 일관된 주석을 사용한다.2. if 조건문과 들여쓰기파이썬은 들여쓰기도 문법으로 정해져 있으며 if 조건문도 들여쓰기가 중요하다.아래 코드를 실행하면 unexpected indent 에러가 발생한다.x = 10 if x == 10:     print('x에 들어있는 숫자는')         print('10입니다.')     # unexpected indent 에러 발생올바른 코드로 고쳐보자.x = 10 if x == 10:     print('x에 들어있는 숫자는')     print('10입니다.')# 실행결과  x에 들어있는 숫자는# 10입니다.if 다음에 오는 코드들은 반드시 들여쓰기 깊이가 같아야 한다. 만약 첫 번째 print만 들여쓰기를 하고, 두 번째 print는 들여쓰기를 하지 않으면 의도치 않은 동작이 된다.x = 10 if x == 10:     print('x에 들어있는 숫자는')print ('10입니다.')# 실행결과  x에 들어있는 숫자는# 10입니다.print 두 개가 모두 실행되 잘 동작하는것 같지만 x의 값을 5로 하면 어떻게 될까? x에 5를 할당했기 때문에 if의 조건식을 만족하지 않음으로 다음에 오는 print는 실행이 되지 않는다. 그런데 print(‘10입니다.’)는 실행이 되었다. 들여쓰기가 없어서 if와는 상관없는 코드가 되었기 때문이다.x = 5          # x에 5를 할당 if x == 10:    # x가 5라서 조건식을 만족하지 않음     print('x에 들어있는 숫자는')print ('10입니다.')# 10입니다.즉, if 다음 줄에 들여쓰기가 된 코드는 if의 영향을 받아서 조건식에 따라 실행이 결정되지만 들여쓰기가 되지 않은 코드는 항상 실행된다. 이런 코드는 일단 실행이 되기 때문에 잘못된 부분을 찾기가 쉽지 않다. 내가 의도한 부분의 코드의 들여쓰기가 일치하는지 항상 확인하자. 파이썬에서 :가 나오면 그 다음 줄부터는 무조건 들여쓰기를 한다는 점만 기억하면 된다.if와 들여쓰기 칸 수if에서 처음부터 들여쓰기를 4칸으로 했다면 계속 4칸으로 유지하고, 2칸으로 했다면 계속 2칸으로 유지한다. 어떨 땐 4칸 어떨 땐 2칸 이렇게는 안 된다. 파이썬 코딩 스타일 가이드(PEP 8)에서는 공백4칸으로 규정하고 있으므로 4칸을 권장한다.3. 중첩 if 조건문 사용하기if 를 여러번 사용하는 중첩 if 조건문을 사용해보자. 다음은 변수의 값이 10이상이면 ‘10 이상입니다.’를 출력한 뒤 15이면 ‘15입니다.’, 20이면 ‘20입니다.’를 출력한다.x = 15 if x &gt;= 10:     print('10 이상입니다.')      if x == 15:         print('15입니다.')      if x == 20:         print('20입니다.')# 출력 10 이상입니다.#      15입니다.들여쓰기에 주목하자. x가 10이상일때 출력하는 코드안에 if를 보면 들여쓰기가 되어있다. 이렇게 들여쓰기가 된 if x == 15:와 if x == 20:은 처음에 나온 if x &gt;= 10:에 속한 코드이다. 즉, if x &gt;= 10:의 조건식이 만족해야만 실행되는 코드라는 말이다.if x &gt;= 10:    print('10 이상입니다.')     if x == 15:        print('15입니다.')     if x == 20:        print('20입니다.') 그리고 다시 안쪽의 if에 속한 print는 들여쓰기를 한번 더 해준다.if x &gt;= 10:    print('10 이상입니다.')     if x == 15:        print('15입니다.')      if x == 20:        print('20입니다.') 4. 사용자가 입력한 값에 if 조건문 사용하기이번에는 input을 사용하여 사용자가 입력한 값을 변수에 저장하고, if 조건문으로 값을 비교해 보자.x = int(input())          # 입력받은 값을 변수에 저장 if x == 10:               # x가 10이면    print('10입니다.')    # '10입니다.'를 출력 if x == 20:               # x가 20이면    print('20입니다.')    # '20입니다.'를 출력입력 값이 x에 저장되고, if로 x가 10인지 비교하였다. 여기서는 10을 입력했으므로 ‘10입니다.’가 출력된다. 20과 다른 값을 입력하여 if가 동작하는 모습을 살펴보자.지금까지 if 조건문에 대해 알아보았다. if 조건문은 조건식이 만족했을 때 코드를 실행한다는 점이 중요하다. 특히 if 조건문은 들여쓰기에 따라 문법 에러가 발생하거나, 의도치 않은 동작이 나올 수 있으므로 들여쓰기 규칙을 정확히 익혀 두는것이 중요하다.",
        "url": "/python-basic10"
    }
    ,
    
    "python-basic9": {
        "title": "Python - Python 딕셔너리 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 딕셔너리 사용하기파이썬은 연관된 값을 묶어 저장하는 용도로 딕셔너리라는 자료형을 제공한다. 게임 캐릭터의 능력치를 딕셔너리에 저장해봤다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}이제 딕셔너리만 봐도 lux라는 캐릭터의 체력(health)은 490, 마나(mana)는 334, 사거리(melee)는 550, 방어력(armor)은 18.72라는 것을 쉽게 알 수 있다.1. 딕셔너리 만들기딕셔너리는 {}안에 키 : 값 의 형식으로 저장하며 각 키와 값은 ,(콤마)로 구분해 준다. 키를 먼저 지정하고 :(콜론)을 붙여서 값을 표현한다. 특히 키에는 값을 하나만 지정할 수 있으며 이런 특성을 따서 키 - 값 쌍(key-value pair)이라 부른다(키-값은 1:1 대응).lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}키 이름이 중복되면?딕셔너리의 키값이 중복되면 가장 뒤에있는 값만 사용한다. 중복된 키는 저장되지 않는다. 딕셔너리 lux를 만들 때 ‘health’: 490이 있고 그 뒤에 ‘health’: 800을 넣었다. lux[‘health’]를 출력해보면 800이 나오는걸 알 수 있다.lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health']    # 키가 중복되면 가장 뒤에 있는 값만 사용함800lux    # 중복되는 키는 저장되지 않음{'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}딕셔너리 키의 자료형딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불 도 사용할 수 있으며 자료형을 섞어서 사용해도 된다. 그리고 값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있다. 단, 키에는 리스트와 딕셔너리를 사용할 수 없다.x = {100: 'hundred', False: 0, 3.5: [3.5, 3.5]}x{100: 'hundred', False: 0, 3.5: [3.5, 3.5]}x = {100 : 20, 100 : {100: 800}}x{100: {100: 800}}# 키에는 리스트와 딕셔너리를 사용할 수 없다.x = {[10, 20]: 100}Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    x = {[10, 20]: 100}TypeError: unhashable type: 'list'x = \\{\\{'a': 10}: 100\\}Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    x = \\{\\{'a': 10\\}: 100\\}TypeError: unhashable type: 'dict'빈 딕셔너리 만들기비어있는 딕셔너리를 만들때는 {}만 지정하거나 dict을 사용하면 된다. 보통 {}를 주로 사용한다.  딕셔너리 = {}  딕셔너리 = dict()x = {}x# {}y = dict()y# {}dict로 딕셔너리 만들기dict는 다음과 같이 키와 값을 연결하거나, 리스트, 튜플, 딕셔너리로 딕셔너리를 만들때 사용한다.  딕셔너리 = dict(키1=값1, 키2=값2)  딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))  딕셔너리 = dict([(키1, 값1), (키2, 값2)])  딕셔너리 = dict({키1: 값1, 키2: 값2})다음과 같이 dict에서 키=값 형식으로 딕셔너리를 만들 수 있다. 이때는 키에 ‘ ‘(작은따옴표)나 “ “(큰따옴표)를 사용하지 않아야 한다. 키는 딕셔너리를 만들고 나면 문자열로 바뀐다.lux1 = dict(health=490, mana=334, melee=550, armor=18.72)    # 키=값 형식으로 딕셔너리를 만듦lux1{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}두 번째 방법은 dict에서 zip 함수를 이용하는 방법이다. 다음과 같이 키가 들어있는 리스트와 값이 들어있는 리스트를 차례대로 zip에 넣은 뒤 다시 dict에 넣어주면 된다. 물론 키와 값을 리스트가 아닌 튜플에 저장해서 zip에 넣어도 된다.lux2 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))     # zip 함수로lux2      # 키 리스트와 값 리스트를 묶음{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}세 번째 방법은 리스트 안에 (키, 값) 형식의 튜플을 나열하는 방법이다.lux3 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])lux3    # (키, 값) 형식의 튜플로 딕셔너리를 만듦{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72} 네 번째 방법은 dict 안에서 중괄호로 딕셔너리를 생성하는 방법이다.lux4 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})     # dict 안에서lux4  # 중괄호로 딕셔너리를 만듦{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}2. 딕셔너리의 키에 접근하고 값 할당하기딕셔너리의 키에 접근할 때는 딕셔너리 뒤에  를 사용하며 [ ] 안에 키를 지정해주면 된다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health']490lux['armor']18.72#딕셔너리에 키를 지정하지 않은상태는 해당 딕셔너리 전체를 뜻한다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux    # 딕셔너리에 키를 지정하지 않으면 딕셔너리 전체를 뜻함{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}딕셔너리의 키에 값 할당하기딕셔너리는 []로 키에 접근한 뒤 값을 할당할 수 있다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['health'] = 2037lux['mana'] = 1184lux{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72}딕셔너리에 없는 키에 값을 할당하면 해당 키와 값이 추가된다.lux['mana_regen'] = 3.28lux{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}딕셔너리에 없는 키값을 가져오려고 하면 에러가 발생한다.\\lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}lux['attack_speed']    # lux에는 'attack_speed' 키가 없음Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    lux['attack_speed']KeyError: 'attack_speed'딕셔너리에 키가 있는지 확인하기딕셔너리 안에 키가 있는지 확인하려면 in연산자를 사용한다.  키 in 딕셔너리딕셔너리에 특정 키가 있으면 True 없으면 Fasle가 나온다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}'health' in luxTrue'attack_speed' in luxFalse반대로 not in을 하면 특정 키가 없는지 확인한다. 없으면 True 있으면 False가 나온다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}&gt;&gt;&gt; 'attack_speed' not in luxTrue&gt;&gt;&gt; 'health' not in luxFalse  해시 : 딕셔너리는 해시(Hash) 기법을 이용해서 데이터를 저장한다. 보통 딕셔너리와 같은 키-값 형태의 자료형을 해시, 해시 맵, 해시테이블 등으로 부르기도 한다.딕셔너리의 키 개수 구하기딕셔너리를 사용하다 보면 딕셔너리의 키 개수를 구할 필요가 있다. 딕셔너리의 키와 값을 직접 타이핑 할 때는 키의 개수를 알기가 쉽다. 하지만 실무에서는 함수 등을 사용해서 딕셔너리를 생성하거나 키를 추가하기 때문에 키의 개수가 눈에 보이지 않는다. 따라서 다음과 같이 키의 개수는 len함수를 사용하여 구한다.  len(딕셔너리)len에 딕셔너리 변수를 넣어도 되고 딕셔너리를 그대로 넣어도 된다.lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}len(lux)4len({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})4",
        "url": "/python-basic9"
    }
    ,
    
    "python-basic8": {
        "title": "Python - Python 시퀀스 자료형 활용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 시퀀스 자료형 활용하기지금까지 사용했던 리스트, 튜플, range, 문자열을 잘 보면 공통점이 있다. 이들 모두 값이 연속적(sequence)으로 이어져 있다는 점이다. 파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.—1. 시퀀스 자료형의 공통 기능 사용하기시퀀스 자료형의 가장 큰 특징은 공통된 동작과 기능을 제공한다는 점이다. 따라서 시퀀스 자료형의 기본적인 사용 방법을 익혀 두면 나중에 어떠한 시퀀스 자료형을 접하게 되더라도 큰 어려움 없이 바로 사용할 수 있다.시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부른다.특정 값이 있는지 확인하기시퀀스 객체 안에 특정 값이 있는지 확인하는 방법이다. 아래 코드는 a에서 30과 100이 있는지 확인한다. 확인하려는 값이 있으면 True 없으면 False가 나온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]30 in aTrue100 in aFalsein 앞에 not을 붙이면 값이 없는지 확인한다. 없으면 True 있으면 False가 나온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]100 not in aTrue30 not in aFalse튜플, range, 문자열 에도 사용 가능하다.43 in (38, 76, 43, 62, 19)True1 in range(10)True'p' in 'Hello, Python'False시퀀스 객체 연결하기시퀀스 객체는 +연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있다.a = [0, 10, 20, 30]b = [9, 8, 7, 6]a + b[0, 10, 20, 30, 9, 8, 7, 6]range는 +연산자로 객체를 연결할 수 없다.range(0, 10) + range(10, 20)Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    range(0, 10) + range(10, 20)TypeError: unsupported operand type(s) for +: 'range' and 'range' range를 연결하고 싶다면 리스트 또는 튜플로 연결해야 한다.list(range(0, 10)) + list(range(10, 20))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]tuple(range(0, 10)) + tuple(range(10, 20))(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)문자열은 +연산자로 여러 문자열을 연결할 수 있다.'Hello, ' + 'world!''Hello, world!'문자열에 정수,실수를 연결하고 싶다면 str을 사용해 숫자를 문자열로 변환해 연결해 주면 된다.'Hello, ' + str(10)      # str을 사용하여 정수를 문자열로 변환'Hello, 10''Hello, ' + str(1.5)     # str을 사용하여 실수를 문자열로 변환'Hello, 1.5'시퀀스 객체 반복하기*연산자를 사용하면 시퀀스 객체를 특정 횟수만큼 반복할 수 있다. 0또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없다.[0, 10, 20, 30] * 3[0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30][0, 10, 20, 30] * 0[][0, 10, 20, 30] * -1[][0, 10, 20, 30] * 3.2Traceback (most recent call last):  File \"&lt;pyshell#45&gt;\", line 1, in &lt;module&gt;    [0, 10, 20, 30] * 3.2TypeError: can't multiply sequence by non-int of type 'float'range는 연결과 마찬가지로 *연산자를 사용해 반복할 수 없다. range를 리스트나 튜플로 만들어 연결할 수 있다.list(range(0, 5, 2)) * 3[0, 2, 4, 0, 2, 4, 0, 2, 4]tuple(range(0, 5, 2)) * 3(0, 2, 4, 0, 2, 4, 0, 2, 4)문자열은 *연산자를 사용해 반복이 가능하다.'ansang' * 3'ansangansangansang'2. 시퀀스 객체의 요소 개수 구하기요소의 길이는 len함수를 사용해 구할 수 있다.리스트와 튜플의 요소 개수 구하기리스트의 요소는 아래와 같이 구할 수 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]len(a)10튜플도 마찬가지 이다.b = (38, 76, 43, 62, 19)len(b)5range에 len을 사용하면 숫자가 생성되는 개수를 구할 수 있다. 예제에서는 요소의 수가 적어 알기 쉽지만 실무에서는 요소가 많고 추가 삭제 반복을 하기 때문에 len을 사용해야한다.문자열의 길이 구하기문자열도 시퀀스 자료형이므로 len 함수를 사용하면 된다. 공백도 포함이되고 문자열을 묶은 따옴표는 제외된다. 따옴표는 문자열을 표현하는 문법일뿐 길이에는 포함되지 않는다.(문자열의 큰따옴표와 작은따옴표의 경우는 포함된다.)hello = 'Hello, world!'len(hello)13hello = '안녕하세요'len(hello)53. 인덱스 사용하기시퀀스 객체에 들어있는 요소에 접근하는 방법을 알아보자. 시퀀스 객체의 각 요소는 순서가 정해져 있으며, 이 순서를 인덱스라고 부른다. 인덱스의 시작 숫자는 항상 0부터 시작하는것을 기억하자.리스트a = [38, 21, 53, 62, 19]a[0]    # 리스트의 첫 번째(인덱스 0) 요소 출력38a[2]    # 리스트의 세 번째(인덱스 2) 요소 출력53a[4]    # 리스트의 다섯 번째(인덱스 4) 요소 출력19튜플b = (38, 21, 53, 62, 19)b[0]        # 튜플의 첫 번째(인덱스 0) 요소 출력38ranger = range(0, 10, 2) # 02468r[2]        # range의 세 번째(인덱스 2) 요소 출력4문자열hello = 'Ansang coding'hello[7]    # 문자열의 여덟 번째(인덱스 7) 요소 출력'c'시퀀스 객체에 인덱스를 지정하지 않으면 해당 객체 전체를 뜻한다. 시퀀스 객체에서 []를 사용하면 실제로는 __getitem__메서드를 호출하는 것과 같다. 따라서 __getitem__을 사용해 요소를 가져올 수도 있다.a = [38, 21, 53, 62, 19]a.__getitem__(1)21음수 인덱스 지정하기인덱스를 음수로 지정하면 요소의 뒤에서부터 접근한다. -1은 뒤에서 첫번째를 의미하게 되는것이다.# 리스트a = [38, 21, 53, 62, 19]a[-1]   # 리스트의 뒤에서 첫 번째(인덱스 -1) 요소 출력19a[-5]   # 리스트의 뒤에서 다섯 번째(인덱스 -5) 요소 출력38#튜플b = (38, 21, 53, 62, 19)b[-1]        # 튜플의 뒤에서 첫 번째(인덱스 -1) 요소 출력19#ranger = range(0, 10, 2)r[-3]        # range의 뒤에서 세 번째(인덱스 -3) 요소 출력4#문자열hello = 'Ansang coding'hello[-4]    # 문자열의 뒤에서 네 번째(인덱스 -4) 요소 출력'd'인덱스의 범위를 벗어나면?시퀀스 객체의 인덱스는 요소의 숫자보다 하나 작은 값이 마지막 인덱스 값이 된다.a = [38, 21, 53, 62, 19]a[5]    # 인덱스 5는 범위를 벗어났으므로 에러Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    a[5]IndexError: list index out of range 마지막 요소에 접근하기시퀀스 객체의 인덱스를 -1로 지정하게되면 뒤에서 첫번째 요소에 접근한다. 시퀀스 객체의 마지막 요소에 접근하는 다른 방법을 알아보자.아래와 같이 len함수를 사용해 길이를 구하고 그 값을 그대로 넣으면 에러가 발생한다. 인덱스 값은 요소의 전체 숫자보다 하나가 작기 때문이다.a = [38, 21, 53, 62, 19]a[len(a)]Traceback (most recent call last):  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;    a[len(a)]IndexError: list index out of range 요소의 길이를 구하고 -1을 해주게끔 코드를 바꿔보자.a = [38, 21, 53, 62, 19]a[len(a)-1]# 19요소에 값 할당하기시퀀스 객체중 리스트만이 요소를 수정, 변경, 삭제할 수 있다. 튜플, range, 문자열은 값 할당이 불가능하다. 시퀀스 객체는 []로 요소에 접근한뒤 = 로 값을 할당한다. 이때도 볌위를 벗어난 인덱스는 지정할 수 없다.a = [0, 0, 0, 0, 0]    # 0이 5개 들어있는 리스트a[0] = 38a[1] = 21a[2] = 53a[3] = 62a[4] = 19a[38, 21, 53, 62, 19]a[0]38a[4]19# 인덱스 범위를 벗어나 지정할 경우a[5] = 90Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    a[5] = 90IndexError: list assignment index out of range del로 요소 삭제하기마찬가지로 리스트만 삭제가 가능하고 튜플, range, 문자열은 불가능하다. 삭제 방법은 del 시퀀스객체[index]로 삭제할 수 있다.a = [38, 21, 53, 62, 19]del a[2]a[38, 21, 62, 19]4. 슬라이스 사용하기슬라이스는 시퀀스 객체의 일부를 잘라내 사용하는 방법이다. 다음은 리스트의 일부를 잘라내 새 리스트를 만든다. 인덱스의 끝 값은 가져오려는 범위에 포함되지 않는것을 기억하자.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[0:4]  # 인덱스의 0부터 3까지 잘라내 새 리스트를 만든다.[0, 10, 20, 30]# 처음부터 끝까지 가져오려고 할때a[0:10] # 요소의 숫자는 9개지만 모두 가져오려고 한다면 10을 끝인덱스로 지정해야한다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]슬라이스를 했을 때 실제로 가져오는 요소는 시작 인덱스 부터 끝인덱스 -1까지 이다.리스트의 중간 부분 가져오기리스트 중간의 부분을 가져오는 방법도 동일하다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[4:7] # 4, 5, 6 인덱스를 가져왔다.[40, 50, 60]인덱스를 음수로 지정하면 마찬가지로 끝인덱스의 -1까지 가져온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[4:-1] # 인덱스 4부터 인덱스 -2까지[40, 50, 60, 70, 80]인덱스 증가폭 사용하기슬라이스는 range처럼 인덱스의 증가폭을 지정해 범위내의 요소를 가져올 수 있다.다음은 인덱스를 3씩 증가시키며 요소를 가져온다. 주의할 점은 인덱스의 증가폭이지 요소의 값 증가폭이 아니라는 점이다. 인덱스 2의값 그다음 5의값 그다음 8의 값을 가져올것 같지만 슬라이스는 마지막 인덱스값의 -1까지만 가져오게 되어있고 마지막 인덱스 8의 -1인 7까지에서 3씩 증가시킨 값인 2와 5의 값만을 가져오게 된다. 인덱스의 증가폭을 지정하더라도 가져오려는 인덱스를 넘어설 수 없다는 것이다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:3] # 인덱스 2~8(-1인 7까지)의 값중 3씩증가시킨 인덱스 2와 5의 값[20, 50]만약 끝 인덱스 -1과 증가폭으로 증가한 인덱스가 일치하면 해당 요소까지 가져올 수 있다. 다음은 끝 인덱스를 9로 지정하여 인덱스 8의 80까지 가져온다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:9:3] # 인덱스 2~9(-1인 8까지)의 값중 3씩증가시킨 인덱스 2, 5, 8의 값[20, 50, 80]인덱스 생략하기슬라이스 사용시 시작인덱스와 끝인덱스를 생략할 수 있다. 생략하는 방법은 객체의 길이를 몰라도 값을 가져올 수 있기 때문에 자주 쓰이는 방식이다. 주로 시퀀스 객체의 마지막 일부분만 출력할 때 사용한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:7] # 인덱스 0부터 6까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60]a[7:] # 인덱스 7부터 끝까지의 값을 가져온다.[70, 80, 90]a[:] # 인덱스 처음부터 끝까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]인덱스를 생략하면서 증가폭 사용하기인덱스의 처음또는 끝 값을 생략하면서 증가폭을 가지고 값을 가져올수도 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:7:2] # 인덱스 0(처음)부터 6까지의 값중 인덱스 값을 2씩 증가시킨 인덱스의 값을 가져온다. 0, 2, 4, 6의 값을 가져온다.[0, 20, 40, 60]a[7::2] # 인덱스 7부터 끝까지의 값중 인덱스 값을 2씩 증가시킨 인덱스 값을 가져온다. 인덱스 7, 9의 값을 가져온다.[70, 90]a[::2] # 인덱스 처음부터 끝까지의 값중 인덱스 값을 2 씩증가시킨 인덱스 값을 가져온다. 인덱스 0, 2, 4, 6, 8의 값을 가져온다.[0, 20, 40, 60, 80]a[5:1:-1] # 인덱스 5부터 2까지의 값중 인덱스의 값을 -1씩 감소시킨 인덱스 값을 가져온다. 인덱스 5, 4, 3, 2의 값을 가져온다.[50, 40, 30, 20]a[::] # 시작, 끝, 증가폭을 모두 생략하면 리스트 전체를 가져온다. 즉, a[:]와 a[::]의 결과는 같다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[::-1] # 리스트 전체에서 인덱스를 1씩 감소시키며 값을 가져옴으로 리스트를 반대로 뒤집게 된다.[90, 80, 70, 60, 50, 40, 30, 20, 10, 0]len 응용하기len을 사용하여 리스트 전체를 가져올 수 있다. len(a)의 값은 10이기 때문에 인덱스 9까지의 값을 가져오게 된다. 요소의 갯수가 9개이기 때문에 모든 값을 가져올 수 있다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[0:len(a)] # 인덱스 0부터 9까지의 값을 가져온다.[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[:len(a)] # 시작 인덱스를 생략[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]튜플, range, 문자열에 슬라이스 사용하기튜플, range, 문자열도 시퀀스 자료형이기 때문에 슬라이스를 사용할 수 있다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)b[4:7] # 인덱스 4부터 6까지의 값(40, 50, 60)b[4:] # 인덱스 4부터 마지막까지의 값(40, 50, 60, 70, 80, 90)b[:7:2] # 인덱스 처음부터 6까지 중 2씩 증가한 값 0, 2, 4, 6(0, 20, 40, 60)range도 연속된 숫자를 만든다. range에 슬라이스를 사용하면 지정된 범위의 숫자를 생성하는 range객체를 새로 만든다.r = range(10)# 0~9까지의 값을 만든다.rrange(0, 10)r[4:7] # 인덱스 4부터 6까지 숫자 4, 5, 6을 생성하는 range객체를 만든다.range(4, 7)r[4:] # 인덱스 4부터 끝까지 숫자 4, 5, 6, 7, 8, 9를 생성하는 range객체를 만든다.range(4, 10)r[4:10] # 인덱스 4부터 9까지 숫자 4, 5, 6, 7, 8, 9를 생성하는 range객체를 만든다.range(4, 10)r[:7:2] # 인덱스 0부터 6까지 증가폭2를 갖는 인덱스 값에 해당되는 0, 2, 4, 6을 생성하는 range객체를 만든다.range(0, 7, 2)range는 리스트 튜플과 달리 요소가 모두 표시되지 않고 범위만 표시한다. list에 넣어 표시하게 만들어보자.list(r[4:7])[4, 5, 6]list(r[4:])[4, 5, 6, 7, 8, 9]list(r[4:10])[4, 5, 6, 7, 8, 9]list(r[:7:2])[0, 2, 4, 6]문자열도 시퀀스 자료형이기 때문에 슬라이스를 사용할 수 있다.hello = 'Hello, world!'hello[2:9]'llo, wo'hello[2:]'llo, world!'hello[:9:2]'Hlo o파이썬에서는 slice객체를 사용하여 시퀀스 객체를 잘라낼 수도 있다. 다음과 같이 시퀀스 객체의 []또는 getitem 메서드에 slice객체를 넣어주면 지정된 범위만큼 잘라내서 새 객체를 만든다.range(10)[slice(4, 7, 2)]range(4, 7, 2)range(10).__getitem__(slice(4, 7, 2))range(4, 7, 2)#슬라이스 객체를 하나만 만든뒤 여러 시퀀스 객체에 사용하는 방법a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]s = slice(4, 7)a[s][40, 50, 60]r = range(10)r[s]range(4, 7)list(range(4,7))[4, 5, 6]hello = 'Hello, world!'hello[s]'o, 슬라이스에 요소 할당하기시퀀스 객체는 슬라이스로 범위를 지정해 여러 요소의 값을 할당할 수 있다. 리스트를 만들고 특정 범위의 요소에 값을 할당해 보자. 이렇게 범위를 지정해서 요소를 할당했을 경우에는 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않는다.  시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a', 'b', 'c'] # 인덱스 2부터 4까지의 값을 a, b, c로 값을 할당한다.a[0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]슬라이스 범위와 할당할 리스트의 요소 개수를 맞추지 않아도 알아서 할당된다. 개수가 적으면 리스트 요소도 줄어들고 많으면 요소 개수도 늘어난다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a'] # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어든다.a[0, 10, 'a', 50, 60, 70, 80, 90]a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어난다.a[0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]슬라이스는 인덱스 증가폭을 지정할 수 있었다. 이번에는 인덱스 증가폭을 지정하여 인덱슬를 건너뛰면서 할당해보자. 단, 인덱스 증가폭을 지정할때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.  시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:2] = ['a', 'b', 'c'] # 인덱스 2부터 7까지 2씩증가시키면서 a,b,c를 2씩 증가된 인덱스 위치에 할당.a[0, 10, 'a', 30, 'b', 50, 'c', 70, 80, 90]# 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]a[2:8:2] = ['a', 'b']Traceback (most recent call last):  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;    a[2:8:2] = ['a', 'b']ValueError: attempt to assign sequence of size 2 to extended slice of size 3 튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)b[2:5] = ('a', 'b', 'c')Traceback (most recent call last):  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;    b[2:5] = ('a', 'b', 'c')TypeError: 'tuple' object does not support item assignment r = range(10)r[2:5] = range(0, 3)Traceback (most recent call last):  File \"&lt;pyshell#4&gt;\", line 1, in &lt;module&gt;    r[2:5] = range(0, 3)TypeError: 'range' object does not support item assignment hello = 'Hello, world!'hello[7:13] = 'Python'Traceback (most recent call last):  File \"&lt;pyshell#6&gt;\", line 1, in &lt;module&gt;    hello[7:13] = 'Python'TypeError: 'str' object does not support item assignment del로 슬라이스 삭제하기시퀀스 객체의 슬라이스를 삭제해보자. 슬라이스 삭제는 다음과 같이 del뒤에 삭제할 범위를 지정해주면 된다.  del 시퀀스객체[시작인덱스:끝인덱스]다음은 리스트의 인덱스 2부터4까지 요소를 삭제한다. del로 요소를 삭제하면 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않는다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]del a[2:5] # 리스트a에서 2~4까지의 요소를 삭제.a[0, 10, 50, 60, 70, 80, 90]인덱스 증가폭을 지정하면 인덱스를 건너뛰면서 삭제한다.a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]del a[2:8:2] # 인덱스 2부터 7까지 2씩증가시키며 삭제. 인덱스 2, 4, 6의 값이 삭제된다.a[0, 10, 30, 50, 70, 80, 90]마찬가지로 튜플, range, 문자열은 del로 슬라이스를 삭제할 수 없다.b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)del b[2:5]Traceback (most recent call last):  File \"&lt;pyshell#8&gt;\", line 1, in &lt;module&gt;    del b[2:5]TypeError: 'tuple' object does not support item deletionr = range(10)del r[2:5]Traceback (most recent call last):  File \"&lt;pyshell#10&gt;\", line 1, in &lt;module&gt;    del r[2:5]TypeError: 'range' object does not support item deletion hello = 'Hello, world!'del hello[2:9]Traceback (most recent call last):  File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;    del hello[2:9]TypeError: 'str' object does not support item deletion",
        "url": "/python-basic8"
    }
    ,
    
    "python-basic7": {
        "title": "Python - Python 리스트와 튜플 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 리스트와 튜플 사용하기1. 리스트 만들기지금까지는 변ㄴ수에 값을 한 개씩만 저장했다. 여러 값을 저장할 수 있는 리스트를 알아보자. 대괄호로 원하는 값들을 묶어주면 된다.a = [38, 21, 53, 62, 19]a[38, 21, 53, 62, 19]리스트에 여러 가지 자료형 저장하기리스트는 문자열, 정수, 실수, 불 등 모든 자료형을 저장할 수 있고 섞어서 저장해도 된다.person = ['ansang', 31, 9.15, True]person['ansang', 31, 9.15, True]빈 리스트 만들기빈리스트는 []또는 list()로 만들수 있다.a = []a# []b = list()b# []range를 사용하여 리스트 만들기range를 사용해 리스트를 만들어 보자. range는 연속된 숫자를 생성한다. range에 10을 지정하면 0에서 9까지의 숫자를 생성한다.range(10)range(0, 10)a = list(range(10))a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range는 시작숫자와 끝나는 숫자를 지정할 수도 있다. 이떄도 끝나는 숫자는 생성되지 않는다.b = list(range(5, 12))b[5, 6, 7, 8, 9, 10, 11]증가폭을 다르게 할수도 있다. 이때는 range(시작, 끝, 증가폭)의 형식으로 작성해주면 된다. 음수로 작성하면 해당 값만큼 감소하는 리스트가 생성된다.c = list(range(-4, 10, 2))c[-4, -2, 0, 2, 4, 6, 8]d = list(range(10, 0, -1))d[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]2. 튜플 사용하기튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제할 수 없다. 튜플이 있는 이유는 요소가 변경되지 않고 유지되어야할 때 사용한다. 변수에 값을 저장할때 ()로 묶어주거나 괄호로묶지 않고 ,로 값만 콤마로 구분해도 튜플이 된다.a = (1, 2, 3, 4, 5, 6, 7)a# (1, 2, 3, 4, 5, 6, 7)a = 1, 2, 3, 4, 5, 6, 7a# (1, 2, 3, 4, 5, 6, 7)튜플도 리스트 처럼 여러 자료형을 섞어서 저장할 수 있다.person = ('ansang', 31, 9.15, True)person('ansang', 31, 9.15, True)not은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True요소가 한 개 들어있는 튜플 만들기함수 클래스를 사용하다보면 값이 아닌 튜플을 넣어야 하는 경우도 있다. 이때 요소가 하나인 튜플을 사용해야한다.아래와 같이 요소가 한개 있는 튜플을 만들면 그냥 값이된다.a = (38)a38요소가 하나인 튜플을 만들 때는 ()안에 값을 넣은후 ,를 붙여준다. 또는 괄호로 묶지 않고 값 한개에 ,를 붙여도 된다.a = (38,)a# (38,)a = 38,a# (38,)range를 사용하여 튜플 만들기리스트와 마찬가지로 range를 사용해 튜플을 만들어 보자.a = tuple(range(10))a(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)b = tuple(range(5, 12))b(5, 6, 7, 8, 9, 10, 11)c = tuple(range(-4, 10, 2))c(-4, -2, 0, 2, 4, 6, 8)튜플을 리스트로 만들고 리스트를 튜플로 만들기튜플과 리스트는 요소를 변경, 추가, 삭제할 수 있는지 없는지만 다를 뿐 기능과 형태는 같다. 따라서 튜플을 리스트로 만들거나 리스트를 튜플로 만들 수도 있다.a = [1, 2, 3]a[1, 2, 3]tuple(a)(1, 2, 3)반대로 list안에 튜플을 넣으면 새 리스트가 생성된다.b = (4, 5, 6)b(4, 5, 6)list(b)[4, 5, 6]list와 tuple안에 문자열을 넣으면 문자 리스트, 문자 튜플이 생성된다.list('hello')['h', 'e', 'l', 'l', 'o']tuple('hello')('h', 'e', 'l', 'l', 'o')리스트와 튜플을 사용하면 변수 여러개를 한번에 만들 수 있다. 이떄 변수의 갯수와 리스트의 요소 갯수는 같아야한다.a, b, c = [1, 2, 3]d, e, f = (4, 5, 6)print(a, b, c)1 2 3print(d, e, f)4 5 6리스트와 튜플 변수로도 변수 여러개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.x = [1, 2, 3]a, b, c = xprint(a, b, c)1 2 3y = (4, 5, 6)d, e, f = yprint(d, e, f)4 5 6‘입력 값을 변수 두 개에 저장하기’에서 사용한 input().split()은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있었다.input().split()10 20['10', '20']x = input().split()10 20a, b = x         # a, b = input().split()과 같음print(a, b)10 20리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.a = [1, 2, 3]    # 리스트 패킹b = (1, 2, 3)    # 튜플 패킹c = 1, 2, 3      # 튜플 패킹",
        "url": "/python-basic7"
    }
    ,
    
    "python-basic6": {
        "title": "Python - Python 문자열 사용하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 문자열 사용하기1.문자열 사용하기문자열은 영문 문자열뿐만 아니라 한글 문자열도 사용가능하다. 변수에 문자열을 담아보자.hello = '안녕하세요'파이썬에선 문자열을 작은따옴표, 큰따옴표, 작은따옴표3개, 큰따옴표3개로 묶을 수 있다.hello = '안녕하세요'hello = \"안녕하세요\"hello = '''안녕하세요'''hello = \"\"\"안녕하세요\"\"\"여러 줄로 된 문자열 사용하기여러줄로 된 문자열을 표현하는 방법을 알아보자.hello = \"\"\"안녕하세요파이썬 입니다작성하는 사람은접니다.\"\"\"문자열 안에 작은따옴표나 큰따옴표 포함하기문자열에 작은따옴표나 큰따옴표를 포함하고 싶다면 작은따옴표를 큰따옴표로 감싸주거나 큰따옴표를 작은따옴표로 묵어주면되고 작은따옴표에 작은따옴표를 넣거나 큰따옴표에 큰따옴표를 넣고싶다면 \\를 사용하면 된다.single_quote = '''\"안녕하세요.\"'파이썬'입니다.'''# \"안녕하세요.\"  '파이썬'입니다. double_quote1 = \"\"\"\"Hello\"'Python'\"\"\" #\"Hello\" 'Python'double_quote2 = \"\"\"Hello, 'Python'\"\"\" # Hello, 'Python'a = 'Python isn\\'t difficult'# \"Python isn't difficult\"\\n을 사용하면 여러개의 따옴표를 쓰지 않고도 여러 줄로된 문자열을 사용할 수 있다.print('Hello\\nPython')#결과HelloPython",
        "url": "/python-basic6"
    }
    ,
    
    "python-basic5": {
        "title": "Python - Python 불과 비교, 논리 연산자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 불과 비교, 논리 연산자1.불과 비교 연산자 사용하기if, while문에서 많이 사용하게되는 논리 연산자와 참(True), 거짓(False)을 나타내는 불리언(boolean)의 사용방법을 알아보자.boolean은 True, False로 표현하며 1, 3.6, ‘Python’처럼 값의 일종이다.비교 연산자의 판단 결과Python에서 비교 연산자와 논리 연산자의 판단 결과로 True, False를 사용한다. 즉, 비교 결과가 맞으면 True, 틀리면 False이다.1&gt;2False1&lt;2True숫자가 같은지 다른지 비교하기두 숫자가 같은지 다른지 비교하는 데에는 ==(equal), !=(not equal)을 사용한다.10==10True10 != 11True문자열이 같은지 다른지 비교하기문자열도 ==와 !=연산자로 비교 할 수 있다. 이때 문자열의 대소문자도 구분해야 한다. 같은 단어여도 대소문자가 다르면 다른 문자열로 판단한다.'Python' == 'Python'True'Python' == 'python'False'Python' != 'python'True부등호 사용하기부등호는 큰지, 작은지, 크거나 작거나 같은지를 판별한다. 기준은 첫번째 값이다.10 &gt; 20    # 10이 20보다 큰지 비교False10 &lt; 20    # 10이 20보다 작은지 비교True10 &gt;= 10    # 10이 10보다 크거나 같은지 비교True10 &lt;= 10    # 10이 10보다 작거나 같은지 비교True객체가 같은지 다른지 비교하기객체가 같은지 다른지 비교할땐 is와 is not을 사용한다. ==, !=는 값 자체를 비교하고 is와 is not은 객체를 비교한다.1과 1.0은 정수와 실수이다. 데이터의 타입은 다르지만 값은 같기때문에 ==는 True가 나온다. 하지만 1과 1.0을 is로 비교해 보면 False가 나온다. 이유는 1은 정수 객체, 1.0은 실수객체이기 때문이다. 객체로서는 다르기 떄문에 is not으로 비교하면 True가 나온다.1 == 1.0True1 is 1.0False1 is not 1.0True정수객체와 실수객체가 서로 다른지 확인하기정수 객체와 실수 객체가 서로 다른지 확인하려면 id함수를 사용한다. id는 객체의 고유한 값(메모리 주소)를 구한다.(이 값은 파이썬을 실행하는 동안에는 계속 유지되며 다시 실행하면 달라진다)id(1)2156471124208id(1.0)2156509782960값 비교에 is를 쓰지 않기값 자체를 비교할때는 ==와 !=를 사용한다. 변수 a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문이다. 따라서 다른 객체가 되므로 값이 같더라고 is로 비교하면 False가 나온다. 값을 비교할 때는 is가 아닌 비교 연산자를 사용해야 한다.a = -5a is -5Truea = -6a is -6Falsea == -6True2. 논리 연산자 사용하기논리 연산자는 and, or, not을 사용한다. and는 두값이 모두 True여야 True이다. 하나라도 False이면 False가 나온다.True and True# TrueTrue and False# FalseFalse and True# FalseFalse and False# Falseor는 두 값 중 하나라도 True이면 True, 두값이 모두 False면 False가 된다.True or True#TrueTrue or False# TrueFalse or True# TrueFalse or False# Falsenot은 논리값을 뒤집는다. not True는 False가 되고, not False는 True가 된다. 여기서 and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or순으로 판단한다.not True and False or not False# False and False or True# False or True# True순서가 헷갈릴 때는 괄호로 판단 순서를 명확히 나타내 주는 것이 좋다.((not True) and False) or (not False)# True논리 연산자와 비교 연산자를 함께 사용하기논리연산자와 비교 연산자를 함께 사용해보자. 이때는 비교 연산자(is, is not, ==, !=, &lt;, &gt;, &lt;=, &gt;=)를 먼저 판단하고 논리 연산자(not, and, or)를 판단하게된다.10 == 10 and 10 != 5    # True and True# True10 &gt; 5 or 10 &lt; 3        # True or False# Truenot 10 &gt; 5              # not True# Falsenot 1 is 1.0            # not False# True정수, 실수, 문자열을 불로 만들기정수, 실수, 문자열을 True, False로 만들어 보자. 정수1은 True 0은 False이다. 문자열의 내용이 ‘False’라도 불로 만들면 Ture가 된다. 문자열의 경우 값이 있으면 True로 나타낸다. 정수0, 0.0이외의 숫자는 모두 True, 빈문자열 ‘’, ““를 제외한 모든 문자열은 True가된다.bool(1)# Truebool(0)# Falsebool(1.5)# Truebool('False')# Truebool('')# Falsebool(\"\")# Falsebool(0)# Falsebool(0.0)# False단락 평가논리 연산에서 중요한 것이 단락 평가(short-circuit evalution)이다. 단락 평가는 첫번째 값만으로 결과가 확실할 때 두 번째 값은 평가하지 않는 방법이다.# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정print(False and True)     # Falseprint(False and False)    # False# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정print(True or True)     # Trueprint(True or False)    # TrueTrue and ‘Python’를 확인하면 True가 나올것 같지만 ‘Python’이 나온다. 파이썬에서 논리 연산자는 마지막 단락 평가를 실시한 값을 그대로 반환하기 때문이다. 마지막에 단락평가를 실시한 값이 불이면 불을 반환한다.True and 'Python'# 'Python'True and 'ansang'# 'ansang''Python' and True# True'ansang' and True# True여기서는 문자열 ‘Python’을 True로 쳐서 and 연산자가 두 번째 값까지 확인하므로 두 번째 값이 반환된다.만약 다음과 같이 and 연산자 앞에 False나 False로 치는 값이 와서 첫 번째 값 만으로 결과가 결정나는 경우에는 첫 번째 값이 반환된다.False and 'Python'#False0 and 'Python'    # 0은 False이므로 and 연산자는 두 번째 값을 평가하지 않음#0or 연산자도 마찬가지로 마지막으로 단락 평가를 실시한 값이 반환된다. 다음은 or 연산자에서 첫 번째 값만으로 결과가 결정되므로 첫 번째 값이 반환된다.True or 'Python'# True'Python' or True# 'Python'만약 두번째 값까지 판한해야 한다면 두 번째 값이 반환된다.False or 'Python'# 'Python'0 or False# False",
        "url": "/python-basic5"
    }
    ,
    
    "python-basic4": {
        "title": "Python - Python 출력 방법",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 출력 방법 알아보기1.값을 여러 개 출력하기print 하나로 여러개의 값을 출력하는 방법을 알아보자.print에 변수나 값 여러개를 ,(콤마)로 구분하여 여러개를 넣을 수 있다.print(1, 2, 3)# 1 2 3print('Hello', 'python')# Hello pythona=20b=30c=40print(a,b,c)# 20 30 40sep로 값 사이에 문자 넣기그런데 값 사이에 공백이 아닌 다른 문자를 넣고 싶을 수도 있다. 이때는 다음과 같이 print의 sep에 문자 또는 문자열을 지정해주면 된다.print(1, 2, 3, sep=', ')    # sep에 콤마와 공백을 지정# 1, 2, 3print(4, 5, 6, sep=',')    # sep에 콤마만 지정# 4,5,6print('Hello', 'Python', sep='')    # sep에 빈 문자열을 지정# HelloPythonprint(1920, 1080, sep='x')    # sep에 x를 지정# 1920x10802. 줄바꿈 활용하기출력되는 값을 줄바꿈 해 출력하는 방법을 알아보자. print의 sep에 개행 문자(\\n)라는 특별한 문자를 지정하면 값을 한 줄에 하나씩 출력할 수 있다.print(1, 2, 3, sep='\\n')123print에서도 여러줄로 출력이 가능하다.다음과 같이 문자열 안에 \\n를 넣으면 1 2 3은 세 줄로 출력이 된다.print('1\\n2\\n3')123제어 문자제어 문자는 화면에 출력되지 않지만 출력 결과를 제어한다고해서 제어 문자라고 부른다. 제어 문자는 \\로 시작하는 이스케이프 시퀀스 이다.  \\n: 다음 줄로 이동하며 개행이라고도 부릅니다.  \\t: 탭 문자, 키보드의 Tab 키와 같으며 여러 칸을 띄웁니다.  \\: \\ 문자 자체를 출력할 때는 \\를 두 번 써야 합니다.end 사용하기print는 기본적으로 출력하는 값 끝에 \\n을 붙인다. 그래서 print를 여러 번 사용하면 값이 여러 줄에 출력된다.print(1)print(2)print(3)# 결과123print를 여러 번 사용해서 print(1, 2, 3)처럼 한 줄에 여러 개의 값을 출력할 수 있다. 이때는 print의 end에 빈 문자열을 지정해주면 된다.print(1, end='')    # end에 빈 문자열을 지정하면 다음 번 출력이 바로 뒤에 오게 됨print(2, end='')print(3)#결과123즉, end는 현재 print가 끝난 뒤 그 다음에 오는 print 함수에 영향을 준다. 만약 1 2 3 사이를 띄워주고 싶다면 end에 공백 한 칸을 지정하면 된다.print(1, end=' ')    # end에 공백 한 칸 지정print(2, end=' ')print(3)# 결과1 2 3",
        "url": "/python-basic4"
    }
    ,
    
    "python-basic3": {
        "title": "Python - Python 변수 만들기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 변수 만들기1.변수와 입력 사용하기변수(variable)을 만들고 결과를 저장하는 방법을 알아보자.변수 만들기x = 100 이라고 입력하면 100이 들어있는 변수 x가 만들어진다. 즉, 변수이름 = 값 형식이다. 이렇게 하면 변수가 생성되는 동시에 값이 할당(저장)된다.  영문 문자와 숫자를 사용할 수 있습니다.  대소문자를 구분합니다.  문자부터 시작해야 하며 숫자부터 시작하면 안 됩니다.  _(밑줄 문자)로 시작할 수 있습니다.  특수 문자(+, -, *, /, $, @, &amp;, % 등)는 사용할 수 없습니다.  파이썬의 키워드(if, for, while, and, or 등)는 사용할 수 없습니다.x = 100y = \"Hello, world\"변수의 자료형 알아내기변수도 마찬가지로 type을 넣어 변수(객체)의 타입이 나온다.type(x)&lt;class 'int'&gt;type(y)&lt;class 'str'&gt;변수 여러 개를 한 번에 만들기변수를 한번에 여러개 만드는 방법은 아래와 같다. 변수이름1, 변수이름2, 변수이름3 = 값1, 값2, 값3 형식으로 변수를 ,(콤마)로 구분한 뒤 각 변수에 할당될 값을 지정해주면 된다. 변수와 값의 갯수는 동일하게 맞춰주어야 한다.x, y, z = 10, 20, 30x# 10y# 20z# 30여러개의 변수를 만들때 값이 같다면 = 같은 값을 지정할수 있다.변수1 = 변수2 = 변수3 = 값 형식으로 변수 여러 개를 =로 연결하고 마지막에 값을 할당해주면 같은 값을 가진 변수 3개가 만들어진다.x = y = z = 20x#20y#20z#20두 변수의 값을 바꿀 수 있다. 변수1, 변수2 = 변수2, 변수1 형식으로 두 변수의 값을 바꿀 수 있다.x, y = 10, 20x, y = y, xx# 20y# 10변수를 삭제하려면 del을 사용하면 되고 확인 해 보면 아래와 같이 찾을수 없다고 나온다.del xxTraceback (most recent call last):  File \"&lt;pyshell#20&gt;\", line 1, in &lt;module&gt;    xNameError: name 'x' is not defined값이 들어있지 않은 빈 변수도 만들 수 있다. 변수 = None형식으로 만든다. 파이썬에서 None은 아무것도 없는 상태를 말하고 다른 언어에서는 null이라고 표현한다.x = Nonex# 아무것도 출력되지 않는다.2.변수로 계산하기계산값을 변수로 지정해 저장하는 방법을 알아보자. 변수 a, b에 숫자를 할당한 뒤에 a와 b의 값을 더해서 변수 c에 할당했다. 이렇게 변수는 변수끼리 계산할 수 있고, 계산 결과를 다른 변수에 할당할 수 있다.a=10b=20c=a+bc30산술 연산 후 할당 연산자 사용하기변수의 값을 증가시키는 방법이다. a의 값에20을 더할뿐 결과를 저장히지는 않는다.a=10a+2030a10변수의 값을 저장하려면 결과를 다시 변수에 저장해야 한다.a = 10a += 20 # a = a + 20a30a를 다시 입력하지 않고 결과를 저장하는 방법이다. +=처럼 산술연신자 앞에 할당연산자(+)를 붙이면 연산 결과를 변수에 저장한다. -=, /=, //=, %=, *=도 사용 가능하다.a=10a=a+20a30할당 연산자를 만들때 주의할 점이다. 변수d를 지정하지 않고 코드를 입력하면 아래와 같은 에러가 나온다. 변수를 지정하고 변수를 사용해 계산을 해야한다.d = d +10Traceback (most recent call last):  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;    d = d +10NameError: name 'd' is not defined. Did you mean: 'id'?값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;계산을 하다보면 부호를 붙여야 할 때도 있다. 이때는 값이나 변수 앞에 양수, 음수 부호를 붙이면 된다.x = -10+x-10-x10복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.입력 값을 변수에 저장하기매번 다른 값을 변수에 할당하는 방법을 알아보자. input()을 사용하면 사용자가 입력한 값을 가져올 수 있다.input()hello, world!'hello, world!'input()안상현'안상현'함수의 결과를 변수에 할당하기input함수의 결과를 변수에 할당했다.x = input()hello world!x'hello world!'위 코드에서 불편한점은 input함수가 실행된 다음에 아무 내용이 없어서 입력을 받는 상태인지 출력이 없는 상태인지 알 수가 없다는 점이다. 이때는 input의 괄호 안에 문자열을 지정해준다.x = input('문자열을 입력하세요')문자열을 입력하세요우리집 강아지는 보름이x'우리집 강아지는 보름이'위 코드는 사용자에게 입력받는 값의 용도를 미리 알려줄 때 사용한다. 다른 말로는 prompt라고도 부른다.두 숫자의 합 구하기숫자 두개를 입력받은 뒤에 두  숫자의 합을 구해보자. 아래 코드를 실행한 결과는 1020이다. input에서 입력받은 값은 항상 문자열 형태이기 때문이다.a = input('첫 번째 숫자를 입력하세요: ')첫 번째 숫자를 입력하세요: 10b = input('두 번째 숫자를 입력하세요: ')두 번째 숫자를 입력하세요: 20print(a + b)1020변수에 값을 input으로 할당하고 데이터 타입을 확인하면 아래와 같이str(string)이 출력되게 된다.a = input()10type(a)# &lt;class 'str'&gt;입력 값을 정수로 변환하기10 + 20의 결과가 30이 나오게 하려면 input에서 입력받은 문자열을 숫자(정수)로 들어주어야 한다. int로 문자열’10’을 정수 10으로 바꿔준다. 만약 실수를 더하려면 int대신 float를 사용한다.a = int(input('첫 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환b = int(input('두 번째 숫자를 입력하세요: '))    # int를 사용하여 입력 값을 정수로 변환 print(a + b)4. 입력 값을 변수 두 개에 저장하기input 한번에 값을 여러 개 입력받는 방법을 알아보자. input에서 split을 사용하여 변수 여러 개에 저장해주면 된다. 공백으로 변수 a와 b의 값을 구분짓는다.a, b = input('문자열 두 개를 입력하세요: ').split()문자열 두 개를 입력하세요: an sangprint(a)anprint(b)sang두 숫자의 합 구하기두 숫자의 합을 구해보는 예제이다. 전 항목에서와 마찬가지로 input으로 입력받은 값은 문자열 이기 때문에 합의 값이 1020이 나온다.a, b = input('숫자 두개를 입력하세요: ').split()숫자 두개를 입력하세요: 10 20print(a + b)1020입력 값을 정수로 변환하기a = int(a)와 같이 int에 변수를 넣은 뒤 다시 변수에 저장해주면 변수가 정수 자료형으로 변환된다.a = int(a)b = int(b)print(a + b)30print안에서 int로 바꾸어 정수값을 얻는 방법도 있다.print(int(a) + int(b))# 30map을 사용하여 정수로 변환하기 map에 int와 input().split()을 넣으면 int로 변환하지 않아도 split의 결과를 모두 int로 변환해준다(실수로 변환할 때는 int 대신 float를 넣는다.).a, b = map(int, input('숫자 두 개를 입력하세요: ').split())숫자 두 개를 입력하세요: 10 20print(a + b)30### 입력받는 값을 콤마를 기준으로 분리하기split에 기준 문자열을 지정하여 공백이 아닌 다른 문자로 값을 분리해 보자.a, b = map(int, input('숫자 두 개를 입력하세요: ').split(','))숫자 두 개를 입력하세요: 10,20print(a + b)30",
        "url": "/python-basic3"
    }
    ,
    
    "python-basic2": {
        "title": "Python - Python 숫자 계산하기",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 숫자 계산하기1.정수 계산하기파이썬은 파이썬 셸을 통하여 입력한 코드의 결과를 즉스 출력할수 있었다. 파이썬의 숫자의 타입은 정수, 실수, 복소수가 있다. 정수는 말그대로 123같은 숫자를 나타내고 실수는 소수점이 있는 숫자, 복소수는 제곱을 할때 -가 나오는 수를 말한다. 정수는 int, 실수는 float, 복소수는 complex라고 한다.사칙연산사칙연산은 +,-,*(곱하기),/(나누기)를 사용할 수 있다.1+1# 21-1# 01-2# -12*2# 45/2# 2.54/2# 2.0연산자 // (버림 나눗셈)나눗셈후 소수점 이하를 버리는 연산자는 //이다. 정수로 계산을하면 정수로 테이터를 얻을수 있다. 하지만 실수로 계산하면 실수로 나오고 소수점 이하는 버리게되어 .0으로 나오게된다.5 // 2#24 // 2# 25.5 // 2# 2.04 // 2.0# 2.04.1 // 2.1# 1.0연산자 % (나머지를 구하는 연산자)%로 나누기를 하게되면 나머지 값을 구할 수 있다.5 % 2# 1연산자 ** (거듭제곱을 구하는 연산자)**를 사용해 거듭 제곱을 할 수 있다.2**3# 82**10# 1024값을 정수로 만들기계산결과가 실수로 나왔을때 강제로 정수로 만들 수 있다. int뒤에 괄호를 붙이고 숫자 또는 계산식을 넣어주면 된다. int뒤에 문자열을 넣어도 정수로 만들 수 있다. 하지만 정수로된 문자열만 가능하다. 실수 문자열을 넣어주면 아래와 같은 문법오류가 나온다.int(5.20)#5int('10.3')# Traceback (most recent call last):#   File \"&lt;pyshell#14&gt;\", line 1, in &lt;module&gt;#     int('10.3')# ValueError: invalid literal for int() with base 10: '10.3'int(-8.3)#-8객체의 자료형 알아내기객체의 타입을 알아내는 함수는 type이고 ()에 타입을 확인하고 싶은 데이터를 넣는다. &lt;class ‘int’&gt;라고 하는것은 정수라는 이야기고 class는 python에서 객체를 나타내는 표현법이다. 정수로 만드는 방법인 int()의 경우 ()안의 데이터를 int클래스로 된 객체로 만들겠다는 말이다.type(10)      # &lt;class 'int'&gt;몫과 나머지를 함께 구하기몫과 나머지를 함께 구하려면 diwmod를 사용한다.divmod(5, 2)      # (2, 1) 데이터를 괄호로 묶은 형태를 튜플(tuple)이라고 한다.a, b = divmod(5, 2)      print(a, b)      2 12진수, 8진수, 16진수정수는 10진수 이외에도 2진수, 8진수, 16진수로도 표현할 수 있다.      2진수: 숫자 앞에 0b를 붙이며 0과 1을 사용한다.        8진수: 숫자 앞에 0o(숫자 0과 소문자 o)를 붙이며 0부터 7까지 사용한다.        16진수: 숫자 앞에 0x 또는 0X를 붙이며 0부터 9, A부터 F까지 사용한다(소문자 a부터 f도 가능).  0b110# 60o10# 80xF# 152.실수 계산하기소수점이 붙은 것을 실수라한다. 실수의 계산을 알아보자.아래 뺄셈의 경우 다소 어려운 주제이다. 실무에서 실수를 다룰때는 적절한 처리가 필요하다.3.5+2.1# 5.64.3-2.7# 1.59999999999999961.5*3.1# 4.655.5/3.1# 1.7741935483870968실수와 정수를 함께 계산실수와 정수를 함께 계산할 경우 표현 범위가 넓은 실수로 출력된다.4.2+5# 9.2값을 실수로 만들기어떤 값을 강제로 실수로 만드는 방법을 알아보자.float는 부동소수점(floating point)에서 따왔으며 값을 실수로 만들어준다. 즉, 실수는 float 자료형이며 type에 실수를 넣어보면 &lt;class ‘float’&gt;가 나온다.float(1+2)#3.0float('5')# 5.0float(5.3)# 5.3type(3.5)      &lt;class 'float'&gt;복소수파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있다. 이때 허수부는 숫자 뒤에 j를 붙인다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용한다).두 실수를 복소수로 만들 때는 complex를 사용하면 된다.1.2+1.3j# (1.2+1.3j)#두 실수를 복소수로 만들 때complex(1.2, 1.3)# (1.2+1.3j)3.괄호 사용하기곱셈보다 덧셈을 먼저 계산하고 싶다면 괄호로 묶어준다.7 + (10 - 5) * 2# 17",
        "url": "/python-basic2"
    }
    ,
    
    "practice-1": {
        "title": "연습문제 - 나도코딩 예제",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python 연습문제나도코딩 예제예) http://naver.com규칙 1 : http://부분을 제외 규칙 2 : 처음 만나는 점(.) 이후 부분은 제외규칙 3 : 남은 글자 중 처음 세자리 + 글자 갯수 + 글자 내 “e” 갯수 + “!” 로 구성예) 생성된 비밀번호 : nav51!아래 문제의 포인트는 url주소가 naver가 아니더라도 출력이 잘 되야 하는것이다.#내가 푼 답안url = \"http://naver.com\"first = url[7 : url.index(\".\")]first1 = first[:3]len = len(first)e = first.count(\"e\")print(f\"생성된 비밀번호 : {first1}{len}{e}%s\" %\"!\")# 선생님답안url = \"http://naver.com\"rule1 = url.replace(\"http://\", \"\")rule1 = rule1[:rule1.index(\".\")]password = rule1[:3] + str(len(rule1)) + str(rule1.count(\"e\"))+\"!\"print(\"{}의 비밀번호는 {} 입니다.\".format(url, password))",
        "url": "/practice-1"
    }
    ,
    
    "python-basic": {
        "title": "Python - Python 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Python    Python 기본    Python 숫자 계산하기    Python 변수 만들기    Python 출력 방법    Python 불과 비교, 논리 연산자    Python 문자열 사용하기    Python 리스트와 튜플 사용하기    Python 시퀀스 자료형 활용하기    Python 딕셔너리 사용하기    Python if 조건문으로 특정 조건일 때 코드 실행하기    Python else를 사용하여 두 방향으로 분기하기    Python elif를 사용하여 두 방향으로 분기하기    Python for 반복문    Python while 반복문    Python break, continue로 반복문 제어하기    Python 중첩루프    Python FizzBuzz 문제    Python 터틀 그래픽스로 그림 그리기    Python 리스트와 튜플 응용하기    Python 리스트와 튜플 응용하기 - 2    Python 2차원 리스트 사용하기    Python 문자열 응용하기    Python 딕셔너리 응용하기    Python 세트 사용하기    Python 파일 사용하기    Python 회문 판별과 N-gram 만들기    Python 함수 사용하기    Python 함수에서 위치 인수와 키워드 인수 사용하기    Python 함수에서 재귀호출 사용하기    Python 람다 표현식 사용하기    Python 클로저 사용하기    Python 클래스 사용하기    Python 클래스 속성과 정적, 클래스 메서드 사용하기    Python 클래스 상속 사용하기    Python 두 점 사이의 거리 구하기    Python 예외 처리 사용하기    Python 이터레이터 사용하기    Python 제너레이터 사용하기    Python 코루틴 사용하기    Python 데코레이터 사용하기    Python 정규표현식 사용하기    Python 모듈과 패키지 사용하기    Python 모듈과 패키지 만들기Python 기본Python은 세미콜론(;)을 안붙여도 된다.파이썬은 세미콜론이 없어도 된다. 세미콜론을 붙여도 문법적 오류가 발생하지 않는다. 하지만 필요없는 내용을 코드에 작성할 필요는 없을것 같다.Python의 주석파이썬에서 사람만 알아볼 수 있도록 작성하는 부분을 주석(comment)라고 한다. 즉, 주석은 파이썬 인터프리터가 처리하지 않으므로 프로그램의 실행에는 영향을 주지 않는다. 아래는 파이썬의 주석처리 방법이다.한줄 주석의 경우 주석의 내용 앞에 #를 붙여준다. 일반적으로 #뒤에 한칸을 띄어쓰기하고 사용한다.# print(\"파이썬 공부하자\")파이썬의 여러줄 주석은 ‘'’이나 “\"”을 앞뒤로 붙여주면 된다.'''print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")'''\"\"\"print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")print(\"파이썬 공부하자\")\"\"\"들여쓰기들여쓰기란 코드의 가독성을 높이기 위해 일정한 간격을 띄워서 작성하는 방법이다. 파이썬은 들여쓰기가 문법으로 되어있어 들여쓰기를 하지 않으면 문법 오류가 나오게 된다.if a == 10:print('10입니다.')    # 들여쓰기 문법 에러#IndentationError: expected an indented blockif a == 10:   print('10입니다.')  코드블록특정한 동작을 위해 코드가 모여있는 상태를 코드블록 이라고 한다. 주의할 점은 같은 블록은 들여쓰기 칸수가 같아야고 공백과 tap을 같이 사용하면 안된다.if a == 10:      print('10')      print('입니다.')",
        "url": "/python-basic"
    }
    ,
    
    "javascript-basic25": {
        "title": "Javascript - JavaScript 객체지향 - 참조",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 참조1. 복제란?바로 이러한 특징이 소프트웨어를 기존의 산업과 구분하는 가장 큰 특징일 것이다. 프로그래밍에서 복제가 무엇인가를 살펴보자.아래 코드의 결과는 1이다. 2행에서 var b = a; 3행에서 b = 2;기떄문에 2가 아닌가 생각할 수 있지만 그렇지 않다. a와 b는 각각다른 데이터를 갖고있기 때문에 a의 값에는 영향을 주지 않는다. 두 변수는 연결되어 있지 않은 별도의 데이터이다.var a = 1;var b = a;b = 2;console.log(a); //12. 참조객체는 어떻게 동작하는지 알아보자. b = a;라고 했고 b에는 {‘id’:1};이런 값이 들어가게 될것이다. 그상태 에서 b.id로 b의 id값을 2로바꿨다. 그리고 a의 id값을 체크하면 값이 2가된다. 이말은 b의 프로퍼티 값을 변경하면 a의 프로퍼티 값이 변경 된다는 것이다.var a = {'id':1}; //a라는 변수에 di가 1인 객체를 지정var b = a;b.id = 2;console.log(a.id);  // 2아래의 예제는 1을 출력한다. b = {‘id’ : 2};로 새로운 객체를만들어 변수b에 할당을 한것이다. 그렇기 때문에 b라는 변수는 더이상 {‘id’:1};를 의미하지 않고 새롭게 만들어진 {‘id’ : 2};를 의미하게 되는 것이다.var a = {'id':1}; var b = a;b = {'id' : 2};  //객체를 생성한것이다.console.log(a.id); //1//사실상 아래의 코드와 같다.var a = 1;var b = a;b = 2;console.log(a); //1변수에 담겨진 값이 객체인경우 b = a;라고 했을때 b와 a는 똑같은 객체를 바라보게된다. 하지만 데이터가 원시 데이터 타입인 경우 b = a;라고하면 이순간에 a에 담겨있던 값이 복제되어 새로만들어지고 그값이 b에 담겨지게 되는것이다. 즉 참조건 복제건 상관없이, 원시데이터이건 객체건 상관없이 새로운 데이터를 만들어서 그것을 변수에 할당하면 새로운 데이터의 값을 바라보게 되지만 지만 객체는 b = a; 라고 했을 때 객체는 똑같은 객체를 각각의 변수들이 바라보게 되는것이고 원시데이터에서 b = a;라고 했을땐 a가 바라보던 값을 b가 만들어졌을땐 복제한 별개의 값을 바라보게 되는것이다.3. 함수와 참조그럼 일종의 변수할당이라고 할 수 있는 메소드의 매개변수는 어떻게 동작하는가를 살펴보자. 조금 복잡하므로 꼼꼼하게 살펴봐야 한다. 예제를 보자.다음은 원시 데이터 타입을 인자로 넘겼을 때의 동작 모습이다. a에 1이라는 값이 담겨있다. 그리고 함수를 정의했는데 매개변수(parameter)인 b의값을 2로 바꾸고있다. 그리고 함수를 호출할때 a를 전달했다. 이말은 b = a;라는 것과 같다. a=1인상태이고 b=a;, 그리고 b=2; 인것이다. 여기서 a=1이고 함수가 b = a;라는 의미이기 때문에 복제와 같다. a=1의 값이 함수 b에 들어가지만 함수내의 b=2;로 b=2가되고 개별의 데이터인 a는 그대로 1이되게 된다.var a = 1;function func(b){ // b = a; 라는것이다.    b = 2;}func(a);console.log(a);이번에는 변수에 담긴 값이 객체이다. a = {‘id’:1};이고 위 함수와 마찬가지로 b = a;를 의미하고 a는 객체이기 때문에 b와 a는 똑같은 객체를 바라보고 있는 상황이지만 b = {‘id’:2};가 새로운 객체를 만들었고 b에 새로운 객체를 할당했기 때문에 b는 {‘id’:2};를 바라보고 있다. 그렇기 때문에 b와 a가 같은 객체를 바라보지 않게 되는것이다. 따라서 결과는 1이다.var a = {'id':1};function func(b){    b = {'id':2};}func(a);console.log(a.id);  // 1아래는 결과가 다르다. 아래도 마찬가지로 b = a;를 함수로 나타내고 있지만 b.id = 2;로 b와a는 데이터가 객체이기 때문에 같은 객체를 바라보고 있다. b.id = 2;로 a의 값도 바뀌기 때문에 결과는 2가된다.var a = {'id':1};function func(b){    b.id = 2;}func(a);console.log(a.id);  // 2",
        "url": "/javascript-basic25"
    }
    ,
    
    "javascript-basic24": {
        "title": "Javascript - JavaScript 객체지향 - 데이터타입",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-테이터 타입1. 원시 데이터 타입과 객체데이터 타입은 크게 2가지로 구분할 수 있다. 원시 데이터 타입과 객체 데이터 타입이다. 원식 데이터 타입은 기본데이터 타입이라고도 하고 객체 데이터 타입은 참조 데이터 타입이라고도 한다. 객체가 아닌 데이터 타입을 원시 테이터 타입이라고 하고 아래와같다.  숫자  문자열  boolean(true/false)  null  nudefined위 항목의 데이터 타입을 원시 데이터 타입 이라고 하고 이외의 모든 데이터 타입을 객체 데이터 타입이라고 한다.2. 래퍼 객체위와 같은 데이터 타입을 분류하는게 중요한것은 아니고 개발자 입장에서 이러한것이 효용을 갖기 위해서는 원시데이터 타입과 객체가 서로 다르게 동작할 때에 효용이 있는것 이다.아래 코드는 문자열을 변수에 담았다. 문자열의 길이와 문자열의 첫번째 값을 출력한다. 객체가 아닌것은 원시데이터 타입이다. 문자열은 원시데이터 타입인데 아래 console.log를보면 객체처럼 동작하고 있다. 이 .의 정식 명칭은 Object access operator이고 객체접근 연산자 라는 뜻이다. 이 .을썻다는것은 .앞에있는 것이 객체라는 것을 의미한다. 객체이기 때문에 length프로퍼티와 charAt(0)메소드가 존재하는것이다. 이말은 str에 담겨있는 무엇인가가 객체이고 문자열은 객체라는 것이다. Javascript에서 문자열이 원시데이터가 맞긴한데 그문자열을 우리가 제어하기 위해서, 여기서는 문자열의 길이와 첫번째 값을 구하기 위해서는 원시데이터 타입인 문자열이 마치 객체인 것 처럼 동작 해야지만 이런 작업을 할 수 있다. 그런 이유로 인해서 Javascript에서 문자열과 같은 원시데이터 타입은 그것을 객체로서 사용할때 그것을 임시로 객체데이터 타입으로 만들어준다. 우리가 str.length를 할때 그순간에 내부적으로 str = new String(‘coding’); 이라고하는 객체를 생성해 str변수에 담아준것과 같은 작업이 1행과 2행 사이에 생긴다고 보면 된다.var str = 'coding';console.log(str.length);        // 6console.log(str.charAt(0));     // \"C\"‘coding’이라는 문자열을 str변수에 담았고 str.prop로 prop라는 프로퍼티를 지정했다. 거기에 ‘everybody’라는 텍스트를 넣었다. console.log(str.prop);로 출력을 하려고하면 undefined가 출력된다. 이말은 우리가 우리가 str.prop = ‘everybody’를통해 문자열을 객체화 시킨후 그 다음행으로 문제없이 넘어갈 수 있게 되는데 이순간엔 객체가 만들어졌지만 끝난후에 그 객체를 제거하고 원래의 원시 데이터 타입으로 변경했기 때문에 prop라는 값이 존재하지 않는것이다.var str = 'coding';str.prop = 'everybody';console.log(str.prop);      // undefined원시 데이터 타입은 객체처럼 사용하려고 할때 자동으로 만들어지는 객체를 래퍼객체(Wrapper Object)라고 한다. 원시 데이터 타입이 있을 때 그 원시 데이터 타입을 감싸주는 객체가 만들어져 객체화 시켜주는게 래퍼객체이다.  숫자 (Number)  문자열 (String)  boolean(true/false) (Boolean)  null X  nudefined Xnull과 nudefined은 래퍼객체가 존재하지 않는다. 객체화 시키려고 하면 타입에러가 발생할 것이다.",
        "url": "/javascript-basic24"
    }
    ,
    
    "javascript-basic23": {
        "title": "Javascript - JavaScript 객체지향-Object",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-Object1. Object란?Object객체는 객체의 가장 기본적인 형태를 가지고 있는 객체이다. 다시 말해서 아무것도 상속받지 않는 순수한 객체다. Javascript에서는 값을 지정하는 기본적인 단위로 Object를 사용한다. var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};우리는 이전에 property에대해 배울 때 Ultra, Super, Sub라는 생성자 예제를 통해 상속에대해 알아보았다. Sub는 Super를 Super는 Ultra를 상속받았다. Ultra는 최상위에 있는것처럼 보이지만 암시적으로는 사실 Object라는 객체에 상속되어 있는것이다. Object라는 객체의 프로퍼티는 모든 객체가 갖고있는 프로퍼티가 되는것이다. 즉 Object의 prototype은 모든객체가 사용할 수 있는 prototype이 된다는 것이다. 우리가 모든 객체가 가지고 있었으면 하는 기능이 있다면 Object의 prototype에 우리가 직접 기능을 추가하는 것을 통해서 모든객체가 그기능을 갖게 할 수 있다는 것이다.2. Object API사용법Object.keys는 배열이 어떠한 인덱스값을 가지고 있는지 배열로 리턴하는 메소드이다. 따라서 첫번째 결과는 Object.keys(arr)[‘0’, ‘1’, ‘2’] 이된다. toString은 문자열을 리턴해준다고 생각하자. 중요한 것은 Object.keys()와 Object.prototype.toString()에서 prototype이 있고 없고의 차이가 뭔지 알아야한다. prototype이 있는 것은 어떠한 객체를 만든다. 그리고 그객체를 담고있는 식별자. toString이라고 한다. 그런데 prototype이 없는 Object.keys같은 경우에는 Object.keys(arr)처럼 어떠한 인자를 받아서 처리한다. 이러한 차이는 Object라고 하는 것이 생성자 함수인 것이다. 함수는 javascript에서 객체이기 때문에 프로퍼티를 가질수 있다. 그래서 Object.keys가 가능한 것이고 이렇게 정의되었을 것이다 Object.keys = function(){}. toString의 경우는 prototype의 프로퍼티이다. 즉 Object.prototype.toString = function(){} 로 정의되어 있다. 어떠한 메소드가 new Object를 실행을 시키는 순간에 어떠한 객체를 만들고 그객체는 prototype이라고 하는 특수한 프로퍼티에 저장되어있는 객체를 원형으로 하는 객체가 생성이 되는것이다. 그렇게 생성된 객체는 toString이라는 메소드를 사용할 수 있기 때문에 메소드로서 사용하게 되는것이다.//Object.keys()var arr = [\"a\", \"b\", \"c\"];console.log('Object.keys(arr)',Object.keys(arr));//Object.prototype.toString()var o = new Object();console.log('o.toString()',o.toString());var a = new Array(1,2,3);console.log('a.toString()'),a.toString());3. Object 확장우리가 필요한 기능을 모든 객체에서 사용 가능한 Object를 만드는 방법을 알아보자.아래 배열과 객체에서 contain.(인자)메소드로 어떤 인자를 전달하게되면 인자가 해당 되는 값이 그 객체나 배열에 있다면 true 없다면 false를 리턴하게하는 코드를 만들어 보았다. 모든 객체의 부모는 Object이기 때문에 Object라고 적어주고, o와a모두 객체이다. 객체에 어떤 기능, 메소드를 갖도록 추가하고 싶다면 prototype이라고하는 프로퍼티안의 객체를 변경하면 된다. for in문으로 배열과 객체를 차례로 나열하여 값을 확인하는 코드를 작성했다. 아래 코드에서 메소드 안의 this는 그 메소드가 소속되어있는 객체를 의미한다. name에는 각각의 객체에대한 키값이 담기게 된다. 현재 열거되고 있는 value값을 가져오려면 this[name]으로 가져오고 그값과 neddle을 비교하여 두 값이 일치하면 true를 리턴한다. 마지막 value까지 나열했는데 일치하는 값이 없다면 false를 리턴한다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));4. Object 확장의 위험확장의 위험성에 대해 알아보자. 확장을 함으로써 모든 객체에 영향을 주기때문에 주의해야한다.크롬 개발자 도구에서 아래 코드를입력후 for(var name in o){console.log(o[name]);}을 출력한 결과를 보자. 함수까지 출력된 상황이다. 이유는 contain이 포함되었기 때문이다. 개발자 도구에서 다시 코드를 작성해보자. for(var name in o){console.log(name)}의 결과는 name, city, contian이다.for(var name in a){console.log(name)}의 실행결과 역시 0,1,2,contain이다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}console.log(o.contain('ansang'));var a = ['ansang', 'sang', 'hyun'];console.log(a.contain('sang'));// 개발자 도구에서 for(var name in o){console.log(name)}을 출력한 결과for(var name in o){    console.log(o[name]);}VM693:2 ansangVM693:2 suwonVM693:2 ƒ (neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}// 개발자 도구에서 for(var name in a){console.log(name);}을 출력한 결과12contain부모로 부터 contain이라는 프로퍼티까지 상속받았기 때문에 위와같은 결과가 나오는 것이다. 그렇다면 이런 문제를 해결할수 있는 메소드를 알아보자. a.hasOwnProperty(name)는 실행되는 객체가 인자로 전달된 값을 자신의 프로퍼티로 가지고 있는지 확인할 수 있는 메소드이다. contain은 부모로부터 상속받은 프로퍼티이기 때문에 어떠한 프로퍼티의 이름이 그객체의 직접적으로 정의되어있는지 확인하는 기능인 hasOwnProperty로 구별할 수 있다.Object.prototype.contain = function(neddle) {    for(var name in this){        if(this[name] === neddle){            return true;        }    }    return false;}var o = {'name' : 'ansang', 'city' : 'suwon'}var a = ['ansang', 'sang', 'hyun'];for(var name in o){    if(o.hasOwnProperty(name)){        console.log(name)    }}//name, cityfor(var name in a){    if(a.hasOwnProperty(name)){        console.log(name)    }}//0,1,25. prototype vs proto이번엔 prototype과 _proto__의 관계를 알아보자. 그전에 함수란 무엇인가를 확인해 보면. 함수는 javascript에서는 객체이다. function Person(){}는 var Person = new Function();으로 표현할수 있다. javascript에서 함수는 객체이기 때문에 프로퍼티를 가질 수 있다. 아래와 같은 함수를정의하면 객체이기 때문에 함수에 해당되는 Person이라고하는 객체가 생성되고 Person의 prototype이라는 객체가 하나 더 생긴다. 두개의 객체는 서로 연관되어 있기 때문에 Person이라고하는 객체는 내부적으로 prototype이라는 프로퍼티가 생기고 그 프로퍼티는 Person의 prototype객체를 의미한다. 그래서  Pserson.prototype이라 함은 Person의 prototype객체를 의미한다. Person의 prototype객체도 자신이 Person의 소속인것을 표시하기 위해서 어딘가에 기록해야한다. 그러기 위해서 Person의 prototype객체 안에 constructor라고하는 프로퍼티를 만들고 이 프로퍼티는 Person을 가르키게 된다. 서로간의 상호참조를 하고있는 것이다. Person은 prototype프로퍼티를 통해서 Person의 prototype객체를 가르키고 Person의 prototype객체는 constructor프로퍼티를 통해서 Person객체를 가르킨다는 것이다. 그다음person.prototype.sum = function(){} 를정의하게 되면 Person의 prototype객체에 sum이라는 함수가 없기때문에 생성하고 함수를 정의한다. var kim=new Person(‘kim’,10,20) 이렇게 객체를 생성하면 kim이라고하는 객체가 생성되고 kim이라는 객체 안에 프로퍼티 값으로 name,first,second 그리고 __proto__가 생성이 된다. kim객체의 __proto_ 프로퍼티는 Person의 prototype객체를 의미한다. 그렇다면 Person.prototype을통해서 Person의 prototype객체에 접근할 수 있고, kim.__proto__를 통해서도 접근 할 수 있다. var lee = new Person(‘lee’,10,10)를 통해서도 같은 접근을 할 수 있다. console.log(kim.name)을하면 name이라는 프로퍼티가 있는지를 확인하고 그값을 출력할 것이다. 만약 name이라는 값이 없다면 __proto__가 가르키는 객체에 name이 있는지 다시 찾아본다. kim.sum()을 하게 되면 kim이라는 객체에는 sum이라는 메소드가 없다. 그렇다면 javascript는 __proto__가 가르키는 Person의 prototype객체에 sum이 있는지 찾는다. 이런식으로 prototype이 동작하는 것이다.function Person(name, first, second){    this.name = name;    this.first = first;    this.second = second;}person.prototype.sum = function(){}var kim = new Person('kim',10,20)var lee = new Person('lee',10,10)console.log(kim.name)kim.sum()",
        "url": "/javascript-basic23"
    }
    ,
    
    "javascript-basic22": {
        "title": "Javascript - JavaScript 객체지향-표준 내장객체의 확장",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향-표준 내장객체의 확장1. 표준 내장 객체란?표준 내장 객체(Standard Built-in Object)는 자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다. 내장 객체가 중요한 이유는 프로그래밍을 하는데 기본적으로 필요한 도구들이기 때문에다. 결국 프그래밍이라는 것은 언어와 호스트 환경에 제공하는 기능들을 통해서 새로운 소프트웨어를 만들어내는 것이기 때문에 내장 객체에 대한 이해는 프로그래밍의 기본이라고 할 수 있다. 자바스크립트의 표준 내장객체는 아래와 같다.  Object  Function  Array  String  Boolean  Number  Math  Date  RegExp2. 배열의 확장 1내장객체에 우리가 원하는 기능을 추가하는 방법을 알아보자. 아래 예제는 도시이름이 랜덤하게 값으로 반환되는 코드이다. Math.random함수는 0에서 1사이의 난수(난수란 무작위로 만들어진 수열을 가리킨다. 여기서 무작위란 다음에 나올 수를 절대 예측할 수 없다는 것을 뜻한다.)를 반환하는 함수이다.arr.length * Math.random()은 소수값이 포함되어 있기 때문에 index값을 불러올 수 없다. 그렇기 때문에 Math가 가진 API중에 Math.floor을 사용해 정수로 만들어 줘야한다. Math.floor는 소수점을 없애주는 역할을 한다. 예를들어 0.1은 0, 5.2는 5로 바꿔주는 역할을 한다. 그렇게 하고 우리가 랜덤하게 배열의 인덱스값을 배열에 전달할 수 있게 return arr[index];}를 해준다.var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))3. 배열의 확장 2이번엔 Array생성자를 확장해서 모든 배열이 그 배열이 갖고있는 값 중에 어떤 특정한 값을 랜덤하게 획득할 수 있는 기능을 모든 배열의 객체가 획득할 수 있도록 코드를 변경해 보자.  new Array로 새로운 배열을 만들어 낼때 Array.prototype.random = function() { }라는 생성자 함수가 실행이 될것이다. 그생성자가 가지고있는 prototype이라는 프로퍼티 안에 있는 객체가 만들어지는 그 객체의 원형이 되기 떄문에 random이라는 것을 추가한는 것을 통해서 배열객체가 만들어지는 원형, 배열객체의 원형에 random이라는 메소드를 추가하게 되는것이다. 프로토타입을 추가하는걸 통해서 배열 생성자를 통해서 만들어진 객체가 random이라는 메소드를 가지고 있다. random이라는 메소드 안에서 this는 배열객체 자체를 의미한다./*var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');function getRandomValueFromArray(arr){    var index = Math.floor(arr.length * Math.random());    return arr[index];}console.log(getRandomValueFromArray(arr))*/Array.prototype.random = function() { //배열을 만들기 위한 생성자함수    var index = Math.floor(this.length * Math.random());    return this[index];}var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');console.log(arr.random());",
        "url": "/javascript-basic22"
    }
    ,
    
    "javascript-basic21": {
        "title": "Javascript - JavaScript 객체지향 - 상속",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 상속1. 상속(inheritance)이란?우리가 객체라고 하는 것은 하나의 컨테이너고 변수나 메소드가 하나의 객체 안에 상속되어있다. 이런 객체의 특성으로 인해 객체를 그대로 물려받은 새로운 객체를 만들 수 있다. 이 객체는 부모에 해당 되는 객체의 변수의 메소드에 접근할 수 있게 된다. 즉 상속이란 오리지널 객체가 갖고있는 기능을 상속받는 객체가 동일하게 가질 수 있다는 것이다.Person이라고 하는 생성자를 만들었고 그 생성자에 new를 사용해 새로운 객체를 만들었다. 그 객체는 name이라고 하는 프로퍼티와 introduce라고 하는 프로퍼티를 가지고 있고, name의 값은 person에 인자로 전달된 값이 name으로 사용된다. 아래 코드를 실행하면 ‘My name is ansang’이 출력된다.function Person(name){    this.name = name;    this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");아래도 마찬가지로 Person이라고 하는 생성자를 만들었고 그 아래 생성자에 portotype이라고 하는 특수한 프로퍼티에 name이라고 하는 프로퍼티를 준 것이다. 즉 Person이라고 하는 생성자에는 prototype 프로퍼티가 있는데 그 안에 어떤 객체가 들어가있다. 그객체 .name을 하게 되면 어떤 값을 줄 수 있게 되는것이고 그객체 .introduce하고 함수를 할당을 하게 되면 어떤 메소드를 지정할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");2. 상속의 사용법아래는 우리가 처음에 본 예제에서 Programmer라는 생성자를 추가한 것이다. Programmer라는 생성자를 통해 만든 객체가 Person이라는 생성자를 통해서 만들어진 객체와 동일한 기능성을 갖도록 코드를 작성한 것이다.new Programmer(‘ansang’);를 통해서 Programmer라는 생성자를 호출했다. name이라는 프로퍼티 값을 ansang으로 지정을 했다. p1.introduce을 사용하려고 하는데 생성자 Programmer에는 introduce라는 메소드가 정의되어 있지 않다. introduce메소드는 Person이라고 하는 생성자에 정의되어 있는데 여기서 Programmer.prototype = new Person();로 Person 생성자의 프로퍼티와 메소드를 가져오게 된다. 우리는 Programmer에서 name의 값을 ansang으로 주었고 Programmer.prototype = new Person();에서 prototype 라는 어떠한 객체의 값이 생성자 Person과 같다고 했기 때문에 name은 ansang이되고 introduce메소드를 사용할 수 있는 것이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person(); var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");3. 기능의 추가상속을 받는 객체를 만들었다면 기능을 추하가는 기능을 알아보자. Person이라고하는 공통의 부모가 있고 Programmer, Designer라는 객체가 person이라는 객체를 상속받는 형식이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My name is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");여기서 My name is를 My nickname is로 바꾸면 My nickname is ansanghello worldMy nickname is nibagmanbeautiful의 값을 출력하게 된다. 이말은 Person이라는 생성자를 상속받은 객체들의 값도 바뀐다는 말이다.function Person(name){    this.name = name;}Person.prototype.name=null;Person.prototype.introduce = function(){    return 'My nickname is '+this.name; } function Programmer(name){    this.name = name;}Programmer.prototype = new Person();Programmer.prototype.coding = function(){    return \"hello world\";}function Designer(name){    this.name = name;}Designer.prototype = new Person();Designer.prototype.design = function(){    return \"beautiful\";} var p1 = new Programmer('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\");document.write(p1.coding()+\"&lt;br /&gt;\");var p2 = new Designer('nibagman');document.write(p2.introduce()+\"&lt;br /&gt;\");document.write(p2.design()+\"&lt;br /&gt;\");4. prototype그럼 prototype이란 무엇인가? 한국어로는 원형정도로 번역되는 prototype은 말 그대로 객체의 원형이라고 할 수 있다. 함수는 객체다. 그러므로 생성자로 사용될 함수도 객체다. 객체는 프로퍼티를 가질 수 있는데 prototype이라는 프로퍼티는 그 용도가 약속되어 있는 특수한 프로퍼티다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된  다.생성자는 기본적으로 함수이다. 우리가 이 함 수를 호출할 때 new를 사용하면 생성자가 되는 것이고 그렇게 해서 실행된 결과로 새로운 객체를 만들고 이 객체는 o에 들어가게 된다. 그런데 비어있는 객체를 만드는 것만이 생성자의 역할이라고 한다면 그렇게 효율적이지 못하다. 생성자를 사용하는 이유는 우리가 객체를 생성했을 때 그 객체가 가져야 할 방법이나 프로퍼티 값을 가지고 우리에게 주어지기를 바라기 때문이다. 우리가 어떤 객체를 생성했을 때 객체가 가지고 있어야 하는 방법과 프로퍼티 prototype이라는 프로퍼티에 저장이 되는 것이다. 즉 prototype는 어떠한 객체가 정의가 되어있다는 것이다. 그렇게 하고 new를 이용해 생성자 함수를 생성하게 되면 Javascript는 생성자 함수의 prototype에 저장되어있는 객체를 꺼내서 그것을 돌려보내 주게 된다. 코드를 보자. 우리가 Sub.prototype = new Super(); 라고 하면 생성자 function Super(){} 이 만든 객체 Super.prototype = newUltra(); 이 만든 값이 들어가는 것이고 그리고 생성자 function Super(){}의 값은 Super.prototype = newUltra();로 만들어진 객체가 담긴다는 것이다. 생성자 function Ultra(){}의 값은 Ultra.prototype.ultra Prop = true; 이기 때문에 true가 출력된다. 이러한 개념은 prototype chain 이라고 한다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();console.log(o.ultraProp);5. prototype chain전에 본 코드를 아래와 같이 바꾸면 1을 출력하게 된다. 그이유는 javascript가 기본적으로 동작할 떄 o라는 객체가 ultraprop라는 값을 가지고 있는지 확인하고 우리가 o.ultraProp = 1;로 지정했기 때문에 1을 출력하게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super(); var o = new Sub();o.ultraProp = 1;console.log(o.ultraProp);아래의 결과는 2가 된다. 코드를 실행하면 o라는 객체에 ultra Prop기 있는지 확인한다. 우리는 var o = new Sub();로 ultraProp에 대해선 정의한 바가 없다. 그래서 이 객체에 직접 ultraProp가 없다는 걸 확인하고, o라는 객체의 생성자를 알아내고(생성자를 알아내는 방법은 따로 있다.) Sub이라는 생성자의 prototype 객체를 확인해 그 객체의 프로퍼티 중에 ultraProp이 있는지 확인하고 그 값을 가져오게 된다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}Sub.prototype = new Super();Sub.prototype.ultraProp = 2; var o = new Sub();console.log(o.ultraProp);아래의 결과는 3이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}Super.prototype = new Ultra(); function Sub(){}var s = new Super();s.ultraProp = 3;Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 4이다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();t.ultraProp = 4;Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);아래의 값은 true다.function Ultra(){}Ultra.prototype.ultraProp = true; function Super(){}var t = new Ultra();Super.prototype = t; function Sub(){}var s = new Super();Sub.prototype = s; var o = new Sub();console.log(o.ultraProp);주의할점은 어떠한 객체 super를 sub가 상속받고 싶다면 Sub.prototype에는",
        "url": "/javascript-basic21"
    }
    ,
    
    "javascript-basic20": {
        "title": "Javascript - JavaScript 객체지향 - this",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - this1. 함수와 thisthis는 함수 내에서 함수 호출 맥락(context 어떠한 의미가 고정되어 있지 않고 사용되는 상황에따라 그의미가 달라질 수 있따.)를 의미한다. 맥락이라는 것은 상황에 따라서 달라진다는 의미인데 즉 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다는 뜻이다. 함수와 객체의 관계가 느슨한 자바스크립트에서 this는 이 둘을 연결시켜주는 실질적인 연결점의 역할을 한다.아래 코드는 조건문에서 window(전역객체)와 함수안에서의 this가 정확하게 일치한다면 window === this를 출력하는 코드이다. 개발자 도구 콘솔에서 실행시 아래와 같이 나온다. 아래 예제처럼 함수안에서의 this는 전역객체를 의미하는 window를 의미하는 것이다.function func(){    if(window === this){        console.log(\"window === this\");    }}undefinedfunc();// window === this2. 메소드와 this객체의 소속인 메소드의 this는 그 객체를 가르킨다. o라고 하는 변수에 객체를 정의해서 할당했다. 그객체엔 func라는 프로퍼티가 있고 함수이기 때문에 메소드 이다. 함수의 내용은 변수o와 this가 정확하게 같다면 o === this를 출력하는 함수이다. 출력값은 o === this 이다.var o = {    func : function(){        if(o === this){            document.write(\"o === this\");        }    }}o.func();   3. 생성자 this아래 코드는 함수를 호출했을 때와 new를 이용해서 생성자를 호출했을 때의 차이를 보여준다.function Func()의 funcThis = this;는 지역변수로 지정하지 않았기 때문에 전역변수인 funcThis의 값이 this가 된다. 그렇기 때문에 if(function === window)는 true가 된다. 이말은 우리가 함수와 this에서 본 예제와 같이 함수안에서의 this는 전역객체 window를 의미하는 것이다. 그아래 var o2 = new Func();는 new를 사용해 javascript내부적으로 비어있는 객체를 만들었다. 그비어있는 객체는 o2가된다. 그리고 var o2 = new Func();를 실행하면 생성자 function Func()가 실행이되고 this의 값이 funcThis가 되고 그값은 var = funcThis가 된다. 자 정리하자. 우리가 new생성자를 통해 o2에 빈객체를 만들었고 그 new생성자는 function Func(){funcThis = this;}이고 여기서의 funcThis는 var funcThis를 의미한다. 즉 우리가 생성자를 통해 만든 객체는 o2에 들어있고 그 생성자가 가르키는것이 var funcThis이기 때문에 if(funcThis === o2)는 true가 된다. 이것을 통해 알수 있는것은 생성자의 맥락으로, 똑같은 함수지만 생성자로 사용될 때에는 this의 값이 생성될 객체를 의미한다.var funcThis = null;  function Func(){    funcThis = this;}var o1 = Func();if(funcThis === window){    document.write('window &lt;br /&gt;');} var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}위의 예제를 조금 바꿔봤다. if(o2 === this); 를 추가했는데 이렇게 되면 문제가 있다. 우리가 생성자를 호출하게 되면 생성자에대한 호출이 모두 끝나고난 뒤에 그때 비로소 o2라고하는 변수에 우리가 생성한 객체가 할당이 된다. 그전에 객체는 만들어져 있지만 o2라는 변수에 할당되어 있지 않기 때문에 우리는 객체를 할당할수 없다. 따라서 생성자 안에서 o2라는 변수와 this를 확인하면 o2라는 변수에 객체가 담겨있지 않기때문에 undefined이다. this라고 하는것은 객체에대한 초기화가 끝나서var funcThis = null;  function Func(){    if(o2 === this);}var o2 = new Func();if(funcThis === o2){    document.write('o2 &lt;br /&gt;');}//undefined4. 객체로서의 함수이번엔 javascript가 얼마나 유연한지 극명하게 보여주는 주제를 알아보자.아래 예제는 개발자도구에 입력한 내용이다. function sum(x,y) {return x+y;}는 sum이라고하는 함수 객체를 만든것이다. 그런데 우리가 new Function(‘x’,’y’,’return x+y;’);로 함수객체를 만드는것은 함수의 본문이 복잡하면 굉장히 힘들다. 그래서 함수를 쉽게작성할 수 있도록 function sum(x,y) {return x+y;} 이런식으로 작성하면 javascript해석기는 함수객체를 만들어주고 이런식의 작성을 함수 리터럴(literal)이라고 한다. 그리고 객체를 만들때  var a = {} 이런식으로 만드는것을 객체 리터럴, var a = []; 이런식을 배열 리터럴이라고 한다. 우리가 명시적으로  new Object, new array등으로 만들수도 있지만 보다 편리하게 어떤 값을 만들수있도록 해주는 처리를 리터럴(literal)이라고 한다.function sum(x,y) {     return x+y;}undefinedsum(1,2);3var sum2 = new Function('x','y','return x+y;'); // new를 통해서 function이라고하는 생성자함수를 호출한것이다. 앞의 두'x','y',는 함수를 정의할때 매개변수를 정의하는것과 같은 의미이고 마지막 'return x+y;' 가 본문{}에 해당되는 것이다.undefinedsum2(1,2);35. apply와this함수가 가지고있는 프로퍼티중에 EcamaScript에서 정의하고있는 메소드중의 하나가 apply와 call이다.switch는 괄호안의 어떤값이 들어가면 값과 같은 케이스 안에들어있는 구간이 break를 만날때까지 실행된다. if문과 대체제의 관계에 있고 이것은 for문과 while문이 대체제역할에 있는것과 같다.함수를 apply를이용해 호출했을때 내부적으로 this의 값은 어떻게 변경되는지 알아보자. func();를 호출하게 되면 함수에서의 this의 값은 전역객체window를 의미하기 때문에 window를 실행하게 된다. func.apply(o);는 객체이기 때문에 프로퍼티를 가지고 있을수 있고 Ecmascript의 스펙으로 정의되어 있는 표준 메소드인 apply를 가지고있다. apply를 호출할때 첫번째 인자로 함수호출 컨테스트 o를 주게되면 func()함수가 실행되게 되면서 this의값이 o가된다. 그래서 o를실행하고 braek가되어 값을 반환하게된다. func.apply(p);도 마찬가지로 p를 반환할 것이다.var o = {}var p = {}function func(){    switch(this){        case o:            document.write('o&lt;br /&gt;');            break;        case p:            document.write('p&lt;br /&gt;');            break;        case window:            document.write('window&lt;br /&gt;');            break;              }}func();func.apply(o);func.apply(p);window, o, p라는 객체와 함수가 있었다. 함수를 어떻게 호출하느냐에 따라 즉 맥락에 따라 window에 소속되기도 하고 o와 p에 소속되기도 했다.",
        "url": "/javascript-basic20"
    }
    ,
    
    "javascript-basic19": {
        "title": "Javascript - JavaScript 객체지향 - 전역객체",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 전역객체1. 전역객체란?전역객체(Global object)는 특수한 객체다. 모든 객체는 이 전역객체의 프로퍼티다. func();와 window.func();는 모두 실행이 된다. 모든 전역변수와 함수는 사실 window 객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다. 생략이 가능하다는 말이다.function func(){    alert('Hello?');    }func();window.func();모든 전역변수와 함수는 window객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주한다. 아래 예제는 전역변수 o에 객체메소드를 지정했다. 그렇기 떄문에 o.func();와 window.o.func();가 모두 실행이 되는걸 알수있다.var o = {'func':function(){    alert('Hello?');}}o.func();window.o.func();전역객체 APIECMAScript에서는 전역객체의 API.를 정의해두었다. 그 외의API는 호스트 환경에서 필요에 따라서 추가로 정의하고 있다. 이를테면 웹브라우저 자바스크립트에서는 alert()이라는 전역객체의 메소드가 존재하지만 node.js에는 존재하지 않는다. 또한 전역객체의 이름도 호스트환경에 따라서 다른데, 웹브라우저에서 전역객체는 window이지만 node.js에서는 global이다.",
        "url": "/javascript-basic19"
    }
    ,
    
    "javascript-basic18": {
        "title": "Javascript - JavaScript 객체지향 - 생성자와 new",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 - 생성자와 new1.자바스트립트의 객체지향Javascript는 어떠한 객체지향 언어와도 같지않다. Javascript만의 독특한 성질을 갖고있고, Javascript의 계열에 속하는 언어들은 prototype-based programming이라 부른다. Javascript도 여기에 속해있는 언어다. 전통적인 함수형 언어의 특성을 그대로 갖고있는게 아니고 객체지향언어가 갖고있는 문법을 비슷하게 사용하면서 사실은 함수형언어의 특성을 갖고있다. 객체지향 프로그래밍을 간단하게 이야기하면 서로 연관되어있는 변수와 메소드를 하나의 객체라고하는 그릇에 넣는것이다. 그리고 서로 연관되어있지 않은 것들은 별도의 객체에다 분리를 시켜놓는 것이 객체지향 프로그래밍의 기본적인 형태라고 할 수 있다. 연관되어 있는 로직들을 객체화 시키게되면 각각의 로직들은 하나하나가 독립된 프로그램처럼 독립성을 갖게된다. 독립성을 갖게된다는것은 여러 완제품의 부품으로 사용될 수 있다는 것이다. 우리가 객체지향 프로그래밍으로 도달하고자하는 목표는 좋은 부품을 만드는 것이라고 할 수 있겠다.2. 객체 생성객체를 만들어 보자. {}를 사용하면 비어있는 객체를 만드는 것이고, oject라는 이름의 object를 만드는 것이다. 비어있는 상자라고 생각하자.  person.name 이라고하면 object라는 그릇에 name이라는 변수를 담은것이다. 그변수의 내용은 문자열 ‘ansang’이 되는것이다. 그런데 우리는 객체에 담겨있는 변수를 변수라고 하지않고 프로퍼티(property)라고 부를것이다. 그리고 우리는 또다른 프로퍼티로 person.introduc 를 넣었다. 프로퍼티 안에 함수를 담게되면 우리는 메소드라고 부르기로했다. 객체 내의 변수를 프로퍼티(property) 함수를 메소드(method)라고 부른다는 것이다. 아래 예제를 실행을 시키면 함수가 실행이 되는데 ‘My name is ‘+this.name 의 this는 함수가 속해있는 객체, person이 담고있는 객체를 의미하는 것이다. person이 담고이있는 객체는 person.name = ‘egoing’으로 this.name은 ‘ansang’을 의미하게 된다. 그런데 아래 코드는 객체를 만들었는데 객체안에 들어갈 여러 프로퍼티가 객체와 분리가 되어있다. 그렇다보니 그 과정에서 중간에 다른 코드가 끼어든다거나 여러가지 이유로 인해서 객체를 정의하는 부분이 집중도가 떨어질 수 있다.var person = {} //비어있는 객체 person.name = 'ansang';person.introduce = function(){    return 'My name is '+this.name; }document.write(person.introduce());위와같은 문제를 방지하는 것이 우리가 직접 객체를 시작하고 닫는 기호 사이에 프로퍼티와 메소드를 직접 정의해 주는것이다.var person = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}document.write(person.introduce());만약에 person이라는 객체를 여러개 만들어서 여러사람에대한 정보를 담을수 있는 person객체를 만든다고 하면 아래처럼 만들면 될까?var person1 = {    'name' : 'ansang',    'introduce' : function(){        return 'My name is '+this.name;    }}var person2 = {    'name' : 'ansanghyun',    'introduce' : function(){        return 'My name is '+this.name;    }1,2로 두개의 객체를 만들었다. 문제는 name을 정의하는 부분과 introduce메소드 부분이 중복되어있다. name은 각각의 데이터가 다르기때문에 완전한 중복이라고는 보기힘들지만 메소드 부분은 완벽히 같은 내용으로 중복되어있다. 이것들이 같은 취지의 객체라고 한다면 그 객체가 가지고있는 메소드를 찾아서 똑같이 바꿔줘야하는 이슈가 생긴다. 이것은 프로그래머들이 혐오하는 중복이 발생한 것이다. 중복이 있다는것은 가독성이 떨어지고 코드의 양이 많아져 유지보수가 힘들어진다는 것이다. 이문제를 해결할 수 있는 방법은 중복을 제거하는 것이고 그방법은 생성자,new라는 것이다.3.생성자와 new생성자생성자(constructor)는 객체를 만드는 역할을 하는 함수다. 자바스크립트에서 함수는 재사용 가능한 로직의 묶음이 아니라 객체를 만드는 창조자라고 할 수 있다.아래는 개발자 도구에서 실행한 코드이다. new를 붙이고 함수를 호출하게 되면 함수는 그냥 함수라고 하지 않고 생성자라고 부른다. 이생성자는 객체의 생성자이고 비어있는 객체를 만들어 p에 반환한다. 그래서 p에는 person {}의 비어있는 객체가 만들어졌다.function person () {} //함수를 만들었다. 함수는 어떠한 값도 담고있지 않다.undefinedvar p0 = person(); //함수에 변수를 지정했다.undefinedp0                  //p0의 값이 없다고 나온다.undefinedvar p = new person(); // new를 추가하고 실행하면 아래와같은 객체가 만들어진게 보인다. undefinedpperson {} // var p = {} 과 같다고 볼수있다. (완전히 같진 않지만 지금 단계에서는.)자바스크립트에서는 원시타입(숫자, 불린값, null과 undefined)를 제외한 모든 값이 객체이다.객체를 생성하는 방법에는 2가지가 있는데 객체리터럴과 생성자로 객체를 만들 수 있는데 아래 예제는 객체 리터럴{}로 객체를 생성한 것과 같은 방법이라고 할 수 있다.function Person(){}var p = new Person();p.name = 'egoing';p.introduce = function(){    return 'My name is '+this.name; }document.write(p.introduce());아래 예제는 객체리터럴로 객체를 생성해 introduce 메소드 부분이 중복된 상황이다.function Person(){}var p1 = new Person();p1.name = 'egoing';p1.introduce = function(){    return 'My name is '+this.name; }document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person();p2.name = 'leezche';p2.introduce = function(){    return 'My name is '+this.name; }document.write(p2.introduce());위의 중복된 상황을 해결하기 위해 new를 사용해 생성자를 사용해 코드를 바꾸었다. 생성자함수( new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.) 코드를 통해서 알 수 있듯이 생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다. Person이라는 함수를 작성했고 var p1 = new Person 함수의 앞에 new를 배치해 Person이라는 함수는 생성자가 된것이다. 인자로 ‘ansang’을 배치해 그값은 name에 들어간다 그리고 name은 this.name = ‘ansang’ 이된다. 즉 이객체의 프로퍼티의 값이 ansang이 된것이다. 그리고 현재 객체의 introduce라고하는 프로퍼티에 함수를 정의해 메소드를 만들었다. 생성자 함수가 다실행된 후에 p1에 담겨지게 된다. p1,p2에 new Person(‘ansang’);, new Person(‘sanghyun’); 를통해 생성자에 전달해 introduce라는 부분이 간단해졌다. 우리가 Person이라는 생성자가 만들어 놓은 빈 객체가 가져야할 프로퍼티와 메소드를 생성자 함수안에 기술하는것으로 인해서 그객체가 가지고있 정보와 객체가 할수 있는 일,이러한 것들을 이렇게 세팅해 주고 있는데 이런것들을 초기화 라고하고 줄여서init또는 initialize라고 한다. 즉 중요한 점은 생성자를 통해 객체를 초기화를 했다는 것이다.function Person(name){    this.name = name;     this.introduce = function(){        return 'My name is '+this.name;     }   }var p1 = new Person('ansang');document.write(p1.introduce()+\"&lt;br /&gt;\"); var p2 = new Person('sanghyun');document.write(p2.introduce());",
        "url": "/javascript-basic18"
    }
    ,
    
    "javascript-basic17": {
        "title": "Javascript - JavaScript 객체지향 - 객체지향 프로그래밍 소개",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체지향 프로그래밍 소개객체지향 프로그래밍객체지향 프로그래밍이(Object-Oriented Programming)란 OOP라고도 하고 핵심키워드는 객체이다. 객체지향 프로그래밍에서의 객체를 추상적으로 말하면 상태와 행위로 구분해 서로연관되어있는 상태와 행위를 그룹화 해놓은 것을 객체라고 할수 있다. 이 객체들을 마치 레고 블럭처럼 조립해서 하나의 프로그램을 만드는 것이 객체지향 프로그래밍이라고 할 수 있다. 다시 말해서 객체지향 프로그래밍은 객체를 만드는 것이다. 따라서 객체지향 프로그래밍의 시작은 객체란 무엇인가를 이해하는 것이라고 할 수 있다. 문법과 설계객체지향 프로그래밍 교육은 크게 두 가지로 구분된다.문법하나는 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것이다. 이러한 기능들은 if, for문처럼 문법적인 구성을 가지고 있다. 이 문법을 이해하고, 숙지해야 객체를 만들 수 있다. 객체를 만드는 법에 대한 학습이라고 할 수 있다. 우리 수업은 여기에 초점이 맞춰져 있다.설계두번째는 좋은 객체를 만드는 법이다. 현실에서 우리가 관심이있는 어떤 특성, 어떤관점을 소프트웨어화 시켜서 문제를 해결하는것이 프로그램, 프로그래밍이다.위의 그림은 런던의 지도이다. 이미지중 어떤것이 가장 보기 편할까. 마지막의 이미지가 보기 제일 편하지 않을까? 역과 역사이이의 환승역이라던지 노선들을 간단하게 추상화(abstract)시켜 보여주고 있다. 복잡함을 제외하고 사용자의 유일한 관심사에 초점을 맞춰 편의성을 높였다. 지하철 노선도가 디자인의 추상화라고 한다면 프로그램을 만든다는 것은 소프트웨어의 추상화라고 할 수 있다. 객체 지향 프로그래밍은 좀 더 현실을 잘 반영하기 위한 노력의 산물이다. 이것은 단순히 객체 지향의 문법을 이용해서 객체를 만든다고 달성되는 것이 아니다. 고도의 추상화 능력이 필요하다. 좋은 설계는 문법을 배우는 것보다 훨씬 어려운 일이다. 심지어 이것은 지식을 넘어서 지혜의 영역이다. 좋은 설계를 위한 조언들은 많지만 이러한 조언들은 조언자의 입을 떠나는 순간 생명력을 잃어버린다. 지식은 전수되지만 지혜는 전수되지 않기 때문이다. 스스로 경험하고 깨우쳐서 자기화시켜야 한다. 필자도 그 긴 여정을 따라가고 있는 견습생에 불과하다.객체지향의 설계 원칙이나 객체 지향의 철학적인 의미는 대단히 중요하다. 하지만 이러한 것들을 지금 언급한다면 미궁 속에 빠지게 될 것이다. 그래서 우리가 할 것은 일단은 지식부터 익히자는 것이다. 언어가 지원하는 객체지향 문법을 배우고, 이것들이 어떻게 동작하는지를 충분히 이해한 다음에 비로소 설계 원칙도 이야기할 수 있고, 객체와 사물의 비유도 시도해 볼 수 있을 것이다. 여기서는 몇 가지 객체지향이 추구하는 지향점을 가볍게 이야기하고 다음 토픽부터 구체적인 문법을 알아볼 것이다.부품화객체지향 프로그래밍을 구성하고 있는 컨셉들은 상당히 많다. 하나의 프로그램이 여러개의 로직으로 이루어져 있다. 그 로직을 그룹화 시켜놓고 로직과 관련된 변수와 메소드들을 그룹화 해놓은게 객체이다. 이렇게 함으로서 재활용성을 높일수 있다. 그럼 이 객체를 다른곳에 사용한다는 것은 이객체가 다른 곳, 여러곳에서 일종의 부품으로서 사용된다는 것이다.아래는 초창기의 컴퓨터이다.본체와 모니터, 키보드가 하나로 단일화되어 있다. 어딘가 고장나면 컴퓨터를 바꿔야할수도 있다.하지만 위의 이미지처럼 부품을 나누어 놓는다면 고장난 부품만 고치면 될것이다. (이미지 생활코딩 참조)객체 지향은 부품화의 정점이라고 할 수 있다. 하지만 우리는 아직 객체 지향을 배우지 않았다. 그래서 우리가 배운 것 중에서 부품화의 특성을 보여줄 수 있는 기능을 생각해보면 좋을 것 같다. 메소드는 부품화의 예라고 할 수 있다. 메소드를 사용하는 기본 취지는 연관되어 있는 로직들을 결합해서 메소드라는 완제품을 만드는 것이다. 그리고 이 메소드들을 부품으로 해서 하나의 완제품인 독립된 프로그램을 만드는 것이다. 메소드를 사용하면 코드의 양을 극적으로 줄일 수 있고, 메소드 별로 기능이 분류되어 있기 때문에 필요한 코드를 찾기도 쉽고 문제의 진단도 빨라진다.그런데 프로그램이 커지면 엄청나게 많은 메소드들이 생겨나게 된다. 메소드와 변수를 관리하는 것은 점점 어려운 일이 되기 시작한다. 급기야는 메소드가 없을 때와 같은 상황에 봉착하게 된다. 메소드는 프로그래밍의 역사에서 중요한 도약이었지만, 이 도약이 성숙하면서 새로운 도약지점이 보이기 시작한 것이다.그 도약 중의 하나가 객체 지향 프로그래밍이다. 이것의 핵심은 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑하는 것이다. 바로 그렇게 그룹핑 한 대상이 객체(Object)다. 비유하자면 파일과 디렉토리가 있을 때 메소드나 변수가 파일이라면 이 파일을 그룹핑하는 디렉토리가 객체라고 할 수 있다. 이를 통해서 더 큰 단위의 부품을 만들 수 있게 되었다. 객체를 만드는 법에 대해서 호기심이 생기지 않는가? 이런 호기심을 유발시키는 것이 이번 토픽의 목적이다. 객체를 만드는 법은 다음 토픽에서 알아보고 지금은 부품화에 대해서 조금 더 생각해보자.은닉화, 캡슐화제대로된 부품이라면 그것이 어떻게 만들어졌는지 모르는 사람도 그 부품을 사용하는 방법만 알면 쓸 수 있어야한다. 모니터가 어떻게 동작하는지는 몰라도 컴퓨터와 모니터를 연결하는 방법을 알면 모니터를 설치해 사용할 수 있는것과 같다. 즉 내부동작 방법을 단단한 케이스(객체)안으로 숨기고 사용자에게 그 부품의 사용방법(메소드)만을 노풀하고 있는 것이다. 이러한 컨셉을 정보의 은닉화(Information Hiding), 또는 캡슐화(Encapsulation)라고 부른다. 자연스럽게 사용자에게는 그 부품을 사용하는 방법이 중요한 것이 된다.인터페이스좋은부품의 또다른 특징은 인터페이스이다. 잘만든 부품은 서로 교환할 수 있어야 한다. 모니터를 바꾼다고 가정해보자 서로다른 회사의 모니터를 교환하려고 하면 회사가 다르더라도 모니터를 연결할 수 있어야 한다. 이것은 컴퓨터와 모니터를 연결해주는 케이블이 표준화 되어있기 때문에 가능한 것이다.컴퓨터와 모니터를 만드는 업체들은 HDMI케이블 규격을 공유한다. 각각의 부품은 미리 정해진 약속에 따라 신호의 입출력을 가능하게 해주는 연결점의 모양을 표준에 맞게 만들면 된다. 이러한 연결점을 인터페이스Interface)라고 한다. 즉 인터페이스는 부품들 간의 약속이다. 프로그래밍에서도 인터페이스에 해당하는것을 소프트웨어 적으로 제공하고 있다.  이러한 약속을 프로그램밍 적으로는 어떻게 구현하는가도 알아보자.지금까지 객체를 부품으로 비유해서 설명 했다. 그런데 비유는 비유일 뿐이다. 비유는 의도한 유사점 뿐만 아니라 의도하지 않은 차이점까지도 전달될 가능성이 있기 때문이다. 비유의 함정이라고 할 수 있다. 소프트웨어는 하드웨어가 아니다. 하드웨어가 할 수 없는 것을 소프트웨어는 할 수 있다. 그 중의 하나가 복제와 상속이다. 이러한 개념을 구체적인 문법 없이 설명하는 것은 효용이 크지 않을 뿐만 아니라 자칫 흥미를 저해할 위험이 있기 때문에 여기서는 설명하지 않았다. 소프트웨어가 있기 이전부터 하드웨어가 이룩한 성취를 잘 수용하면서 동시에 소프트웨어 다운 소프트웨어를 만드는 것은 우리게게 주워진 숙제라고 할 수 있다",
        "url": "/javascript-basic17"
    }
    ,
    
    "javascript-basic16": {
        "title": "Javascript - JavaScript 함수지향 - 함수의 호출",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 함수의 호출1. apply 소개Javascript에서 함수는 일종의 객체이다. 객체는 속성을 갖고있고 그 속성의 값을 가지고있으면 속성(property)라고 부르고 함수를 갖고있다면 메소드(method)라고 부른다.\tfunction func(){ }func();//func라는 함수는 객체이고 메소드를 갖고있다. func.apply func.call이라는 메소드에 접근할수 있다. 이것들이 하는역할은 func라는 객체를 호출하는 역할을 한다.아래는 크롬 개발자 도구에서 실행한 코드이다. sum함수를 정의하고  arg1,arg2의 인자를 갖고있다. 여기서 특이한점은 sum(1,2), sum(4,2)를 실행한 결과와 sum.apply(null, [1,2]); sum.apply(null, [4,2]);를 한결과가 같다 이말은 .apply에 두번째 인자로 배열을 넣은 값들이 arg1, arg2가 되었다는 말이다. 다음 주제에서 왜 이렇게 복잡한 방법으로 함수를 호출하는지 그 이유를 배워보자.\tfunction sum(arg1, arg2) {    return arg1+arg2 ; }undefinedsum(1,2);3sum(4,2);6sum.applyƒ apply() { [native code] } // apply라고 하는 메소드가 브라우저에서 제공하는 메소드이기때문에 코드를 보여줄수 없다는 말이다. 내장된 코드는 네이티브 코드라는 메세지를 보여주게 되어있다.sum.apply(null, [1,2]);3sum.apply(null, [4,2]);62. apply 사용apply를 사용하는 구체적인 이유를 알아보자. 우선 아래 코드는 함수를 정의하고 있다. _sum이라는 변수를 0으로 초기화 시켰고, for in 문으로 this라는 객체에 담겨있는 값들을 하나씩 꺼내 _sum이라는 지역변수에 하나씩 더해 바깥으로 리턴해주고있다. this가 무엇인지는 javascript에서 상당히 중요하다. 이맥락에서 this가 무엇인지는 정해져 있지 않다. 이전의 예제와는 다르게 sum.apply(o1), 그리고 o2를 주었다. 이말은 sum이라는 메소드를 호출할때의 대상을 o1, o2로 준것이다. sum.apply(o1)을 하게되면 o1이 sum이라고 하는 함수의 this가 된다. 독립되어있는 함수가 sum.apply를 하고 o1, o2를 인자로 전달하게되면 o1.sum, o2.sum이라는 메소드가 된다는 것이다.o1 = {val1:1, val2:2, val3:3}o2 = {v1:10, v2:50, v3:100, v4:25}function sum(){ // sum.apply(o1)을 하게되면 var this = o1; 이되는거라고 생각하자.    var _sum = 0;     for(name in this){ //이 맥락에서 this는 정해져 있지 않다.        _sum += this[name];    }    return _sum;}alert(sum.apply(o1)) // 6alert(sum.apply(o2)) // 185위 코드를 aaply를 사용하지 않으면 아래 코드처럼 될것이다. 이렇게 작성하고 출력하게 되면 6과 185이후에 sum함수의 내용도 같이 출력이 된다. 우리가 sum이라는 함수를 o1, o2의 속성으로 추가했기 때문이다. sum : sum 의 왼쪽 sum은 o1, o2 객체의 속성(property)명이 되고 오른쪽 sum은 미리 만들어놓은 함수(function) sum이다. 그리고 객체를 호출하는데 객체의 접근방법은 속성명[property 또는 키값], 속성명.property 또는 키값으로 호출할수 있지만, 메서드의 경우 속성명.메소드명()로 접근한다. 따라서 o1.sum(),o2.sum()로 호출하고 이렇게 호출하면 for in문이 this를 열거하는 과정에서 sum이라는 함수도 더하고 있기때문에 숫자열을 더하고 문자열까지 더해 출력하게 되는것이다.function sum(){    var _sum = 0;    for(name in this){         _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());위 출력에서 함수내용을 출력하지 않으려면  if(typeof this[name] !=== ‘function’ )를 사용해 출력에 제한을 주면 되겠다. 조건문을 사용해 typeof로 함수와 같지 않은경우만 더할것이라고 추가하면 함수의 차례가 오면 그부분을 스킵할 수 있게된다.function sum(){    var _sum = 0;    for(name in this){        if(typeof this[name] !=== 'function' )        _sum += this[name];    }    return _sum;}o1 = {val1:1, val2:2, val3:3, sum:sum}o2 = {v1:10, v2:50, v3:100, v4:25, sum:sum}alert(o1.sum());alert(o2.sum());물론 위의 방법대로 해도 사용할 수 있겠지만 복잡하기 때문에 apply를 사용하게되면 함수가 호출되는 시점에서 this값을 프로그래밍적으로 변경해 함수가 o1이라는 객체의 속성인것처럼 실행되게 할수있다.",
        "url": "/javascript-basic16"
    }
    ,
    
    "javascript-basic15": {
        "title": "Javascript - JavaScript 함수지향 - arguments",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - arguments1. arguments 소개arguments객체는 배열과 유사하다. arguments는 함수안에서 사용할 수 있도록 그 이름이나 특성이 약속되어 있는 일종의 배열이다. 몇개의 인자가 들어올지 모를떄 인자를 정의하지 않고 그함수 안에 arguments를 사용하여 결과를 알아내면 되겠다.아래의 예제는 매개변수가 없는 sum이라는 함수가 있다. javacsript는 관대한 언어이다. 매개변수가 없거나, 인자의 수와 매개변수의 수가 다르더라도 문제가 생기지 않는다.아래 for문에서의 arguments는 Javascript와 약속되어있는 특수한 이름의 변수명이다. arguments라는 배열이 담겨져 있다. 이 배열의 역할을 사용자가 전달한 인자(1,2,3,4)를 담는것이다. 그래서arguments.length는 4가되고 4만큼 for문이 반복되게된다.document.write(i+’ : ‘+arguments[i]+’&lt;\\br /&gt;’);는 0 : 1(인덱스0) 부터 차례로 표시하게되고, 그후 _sum의 변수에 +=(a+=1;는a=a+1;과 같다) arguments[i];를 담았다. 이말은 (1,2,3,4)의 값을 _sum = _sum + arguments[i]이다. 즉, sum_에 1234를 차례로 더한다는 것이다. _sum의 초기값은 0이기 때문에 10이된다.\tfunction sum(){    var i, _sum = 0;     // i 루프를 위한 변수 _sum 출력할 결과를 담아낼 변수    for(i = 0; i &lt; arguments.length; i++){       //arguments javascript와 약속되어있는 특수한 이름의 변수명        document.write(i+' : '+arguments[i]+'&lt;br /&gt;');        _sum += arguments[i];    }       return _sum;}document.write('result : ' + sum(1,2,3,4)); 2. 매개변수의 수 - function length함수명.length는 몇개의 매개변수를 갖고있는지 알려주고, arguments.length는 함수를 호출할때 몇개의 인자, 몇개의 arguments를 담고있는지의 정보를 담고있다.function zero(){    console.log(        'zero.length', zero.length,        'arguments', arguments.length    );}function one(arg1){    console.log(        'one.length', one.length,        'arguments', arguments.length    );}function two(arg1, arg2){    console.log(        'two.length', two.length,        'arguments', arguments.length    );}zero(); // zero.length 0 arguments 0 one('val1', 'val2');  // one.length 1 arguments 2 two('val1');  // two.length 2 arguments 1",
        "url": "/javascript-basic15"
    }
    ,
    
    "javascript-basic14": {
        "title": "Javascript - JavaScript 함수지향 - 클로저",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 클로저클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다.1. 내부함수, 외부함수내부함수아래 코드는 함수안에 또다른 함수를 선언한 것이다. 함수 outter은 외부함수가 되고 inner함수는 내부함수가 된다. inner함수는 var inner = fuction {} 과 같게된다.\tfunction outter(){    function inner(){        var title = 'coding everybody';         alert(title);    }    inner();}outter();아래 코드는 outter란 외부함수에 var title = ‘coding everyday’; 라는 지역변수를 만들었다. 그리고 내부함수로 inner을 만들었는데, 이때 이 내부함수 inner에 title이라는 변수를 사용하려고 하는데 이때 inner라는 함수에 지역변수가 존재하지 않는다면 Javascript는 이 inner라는 내부함수를 포함하고 있는 외부함수에서 title이라고하는 변수를 찾게된다. 즉, 내부함수에서 외부함수의 지역변수에 접근할 수 있다.이러한 것을 클로저(closure)라고 한다.function outter(){    var title = 'coding everybody';      function inner(){                alert(title);    }    inner();}outter();2. 클로저란?클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다. 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다. 아래 예제는 이전의 예제를 조금 변형한 것이다. 내부함수inner를 outter함수내에서 호출하는 것이 아니라 반환하도록 했다. 함수 outter는 내부함수 inner를 반환하고 생을 마감했다. 즉, 함수 outter는 실행된 이후 실행이 종료되어 함수 ouuter의 변수 title또한 더이상 유효하지 않게되어 변수 title에 접근할수 없어 보인다. 그러나 아래 코드의 실행 결과는 경고창으로 coding everybody를 출력할 것이다. 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다.function outter(){    var title = 'coding everybody';      return function(){                alert(title);    }}var inner = outter();inner();즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.3. Private variable소프트웨어가 커지는 과정에서 어떠한 정보가 있을때 그 정보를 아무나 수정하는것을 방지하는 것을 Private variable이라 한다. 소프트웨어가 커지면 여러사람이 코드를 작성하게 된다. 그안에는 과거의 자기자신과 미래의 자기자신이 포함되게된다. 그런경우 많은 데이터가 소프트웨어 안에 존재하게 되는데 그 데이터가 누구나 고칠수있는 데이터가 된다는것은 그데이터가 망가질 가능성이 크다는 것이다. 그런 것을 방지하기 위해 접근하는 방법을 클로저를 사용하여 데이터를 가져오고 수정하는 것을 안전하게 하는것이다.아래는 factory_movie라는 외부함수가 get_title, set_title이라는 두 메소드에 함수를 지정한 객체를 담고있다. 이때 get_title, set_title은 내부 함수가 된다. get_title메소드를 호출하면 title이라는 값을 리턴하는데 그 title의 값은 factory_movie함수에 첫번째 인자이다. 첫번째 매개변수가 title이고 이 매개변수는 함수안에서 지역변수로 사용이 된다. 그렇기 때문에 factory_movie(title)은 지역변수이고 지역변수는 내부함수에서 접근이 가능하기 때문에 get_title을 호출하면 factory_movie의 첫번째 매개변수인 title이 값이 되기때문에 factory_movie함수의 (title)에 전달된 값을 리턴해준다. 그리고 set_title메소드는 첫번째 인자로 _title을 갖고 그리고 _title이라는 값은 다시 title이되고 그값은 내부변수를 의미하기때문에 factory_movie의 (title)을 변경하게 된다. 그다음 ghost와 matix라는 변수에 리턴값을 담았다. alert(ghost.get_title()); 는 ‘Ghost in the shell’을 출력하고, alert(matrix.get_title());는 ‘Matrix’를 출력한다. 이말은 ghost와 matix가 같은 객체를 담고 있지만 그 객체가 담고있는 get_title이라는 메소드가 접근하는 title이라고하는 외부변수에 담겨있는 값은 서로 다르다는 것이다. ghost.set_title(‘공각기동대’);는 ghost라는 변수 안에 set_title이라는 메소드를 호출하고 ‘공각기동대’ 를 인자로 사용하겠다는 말이다. ‘공각기동대는’ _title이되고 _title은 title이 되기 때문에 이 타이틀의 값은 factory_movie함수의 지역변수를 바꾸게 된다. alert(ghost.get_title());를 호출하게 되면 ‘공각기동대’를 출력하고, alert(matrix.get_title());를 호출하면 ‘Matrix’를 실행하게 된다. 즉, 우리가 factory_moviex통해 두개의 ghost와 matix변수를 만들었고, 그두개의 변수는 자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수있었고 그지역변수의 값은 유지되고 있기때문에 ghost라는 함수에 set_title을 통해서 그내용을 ‘공각기동대’로 바꾼다 라는것은 ghost가 접근할수있는 title의 값만을 바꾸는것이지 matrix라는 변수가 접근할수 있는 title의 값에는 어떠한 영향도 미치지 않는다는 것이다.function factory_movie(title){    return {        get_title : function (){            return title;        },        set_title : function(_title){            title = _title        }    }}ghost = factory_movie('Ghost in the shell');matrix = factory_movie('Matrix'); alert(ghost.get_title());alert(matrix.get_title()); ghost.set_title('공각기동대'); alert(ghost.get_title());alert(matrix.get_title());이코드의 진짜 효용은 private variable이라는 것이다.  ghost와 matix변수에 객체를 담았다. 이객체의 get_title, set_title은 언제든지 접근할 수 있는 메소드이다. 누구나 접근할수 있다는 것이다. get_title, set_title이 내부적으로 사용하고 이있는 변수는 title이다. 이title은 외부 함수의 지역변수인 title이다.이지역변수인 title은 factory_movie라는 함수가 어떠한 값을 리턴했을때 factory_movie함수 자체는 실행이 끝났기 때문에 그지역변수인 title은 factory_movie의 내부함수인 get_title, set_title을 통해서만 접근할 수 있는 변수가 되는것이다. 즉, 우리가 title이라는 변수 값을 private variable로 만들고 그값을 수정할때는 set_titl을 통해서만 수정할 수 있고, 그변수의 값을 가져올때는 get_title를 통해서만 가져올 수 있게 하면 title이라는 변수가 안전하게 저장,수정될 수 있다는 것이다.4. 클로저의 응용클로저를 활용하는 것에서 실수하기 쉬운 예제를 보자. Javascript에서는 오로지 함수의 괄호 안에서만 지역변수로서 할당되고 그 외 모든 장소는 전역변수로 취급을 받는다. 우리가 예상하는 결과는 0,1,2,3,4 일것이다. 하지만 그렇지 않다. 첫번째 for문이 반복되는 동안 점점 증가되는 i의 값이 arr라는 배열에 저장될 것 같지만, 실제로 저장되는 것은 함수 그 자체이다. i는 반복이 끝난후 5라는 값이되고 return i 의 값은 5가된다. 그리고 다음 for in문에서 arr[index]는 해당 인덱스의 값으로서의 함수이고 ()를 붙였음으로 해당 함수가 호출된다. i 값은 첫번째 for문을 돌아 5가된 상태이기 때문에 5, 5, 5, 5, 5가 출력된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(){        return i;    }}for(var index in arr) {    console.log(arr[index]());}그렇다면 정상출력 0, 1, 2, 3, 4을 얻기위해선 어떻게 해야할까? 위의 코드에서 달라진 점은 그전의 코드를 외부 함수로 감싸주어서 원래 함수는 내부 함수가 된다는 것아다. 그리고 외부 함수는 내부 함수를 값으로 반환하는데 그 자리에서 바로 그 외부 함수를 호출하기 때문에 내부 함수가 값으로서 반환되어 바로 변수에 할당이 된다.var arr = []for(var i = 0; i &lt; 5; i++){    arr[i] = function(id) {        return function(){            return id;        }    }(i);}for(var index in arr) {    console.log(arr[index]());}/* 결과01234*/위의 두 예제에서 첫번째 for문을 비교한 것이다.var arr = [];for(var i = 0; i &lt; 5; i++){  arr[i] = function(){    return i;  }}  arr[0] = function(){    return i;  }  arr[1] = function(){    return i;  }  arr[2] = function(){    return i;  }  arr[3] = function(){    return i;  }  arr[4] = function(){    return i;  }for(var i = 0 ; i &lt; 5; i++){  arr[i] = function(id){  //외부함수.    return function(){    //내부함수.      return id;    }  }(i);  //외부함수 호출}  arr[0] = function(){      return 0;  }  arr[1] = function(){      return 1;  }  arr[2] = function(){      return 2;  }  arr[3] = function(){      return 3;  }  arr[4] = function(){      return 4;  }",
        "url": "/javascript-basic14"
    }
    ,
    
    "javascript-basic13": {
        "title": "Javascript - JavaScript 함수지향 - 값으로서의 함수와 콜백",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 값으로서의 함수와 콜백1. 값으로서의 함수Javascript에서는 함수도 객체이다. 함수를 일단 값이라고 생각하자. 값의 특징은 어떠한 변수에 담을수 있다. var a = “value” a라는 변수에 값으로 value를 넣은것이다. 함수가 일종의 값이라는 것은 함수 역시 어떤 변수에 담을수 있다는 것이다. Javascript의 함수가 다른 언어의 함수와 다른 점은 함수가 값이 될 수 있다는 점이다. 예제를 보자.\tfunction a(){} // var a = function () {}위 예제에서 a라고하는 함수를 정의했다. 위처럼 함수를 정의하는 것은 a라고하는 변수에 담겨진 값이라는 것이다. 아래 예제에선 객체에 변수를 담았다. a라는 객체에 b라는 key와 function(){}이란 value를 담은것이다. 이처럼 객체 안에 함수를 담게되면 함수는 값이기 때문에 b는 객체안에서 변수와 같은 역할을 하고있다. 객체안에서 변수의 역할을 하는것을 속성(Property)라고 하고 그 속성에 저장된 값이 함수라면 그함수는 이러한 맥락에선 메소드(method)라고 한다.a = {    b:function(){    }};또한 함수는 값이기 때문에 다른 함수의 인자로 전달 될수도 있다. increase는 num이라는 매개변수에 +1을해 리턴, decrease는 -1알한 값을 리턴해준다. cal이라는 함수는 func, num이라는 매개변수를 갖고있고 func의 함수에 num이라는 값을 호출하고있다. alert(cal(increase, 1));을 하게되면 cal의 매개변수가 increase, 1이 인자가 된다. 즉, increase라는 함수에 1이라는 인자가 전달되기 때문에 2가된다.function cal(func, num){    return func(num)}function increase(num){    return num+1}function decrease(num){    return num-1}alert(cal(increase, 1));alert(cal(decrease, 1));2. 값으로서의 함수와 콜백 - 함수의 용도2함수는 함수의 리턴 값으로도 사용할 수 있다. 아래 코드를 보자. cal라는 함수를 호출할때 첫번째 인자로 ‘plus’ 라는값을 주면 객체를 담고있는 함수에 ‘plus’라는 인자가 들어가게 되고 function cal(‘plus’), return funcs(‘plus’)가 된다. alert(cal(‘plus’) (2, 1))에서 (cal(‘plus’)는 function(left, right){return left + right} 이부분이 되고, alert(cal(‘plus’) (2, 1)) 에서 (2, 1)은 함수를 호출하겠다는 말이고 인자로 2, 1을 전달하겠다는 것이다. 결과는 3이된다.function cal(mode){    var funcs = {        'plus' : function(left, right){return left + right},        'minus' : function(left, right){return left - right}    }    return funcs[mode];}alert(cal('plus')(2,1));alert(cal('minus')(2,1));당연히 배열의 값으로도 사용할 수 있다. process라는 배열을 정의했고 배열안의 요소 3개가 모두 함수이다. for반복문에서  i = 0 일때 process라는 배열의 index 0의 요소의 함수를 호출하고 첫번째 인자로 1을 전달한다. 이후 input의 값은 11이되고 index 다시 반복문으로 돌아와 1의 요소의 함수를 호출하게 된다. 이때 input의 값은 배열의 첫번쨰 요소에서 얻은 11이 된다. 값은 121이 되고 이 값은 다시 input의 값이 된다. 이후배열의 세번째 요소로 121의 값이 전달되고 60.5의 결과가 나온다.var process = [    function(input){ return input + 10;},    function(input){ return input * input;},    function(input){ return input / 2;}];var input = 1;for(var i = 0; i &lt; process.length; i++){    input = process[i](input);}alert(input);3. 값으로서의 함수와 콜백 - 콜백이란?콜백은 어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다. 처리의 위임값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.아래 예제에서 배열의 내용을 정렬하려면 numbers.sort();라는 명령을 내리는 것이다. 여기서 .앞의 numbers는 배열객체가 되고 우리가 아래처럼 [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]를 작성해 Javascript에 제출을하면 배열객체를 만들어 numbers라고하는 변수에 담아준다. 그리고 배열객체에는 sort라고하는 함수가 정의되어 있기때문에 numbers.sort();를 통해서 배열이 가지고있는 명령어 sort를 호출하게 되는데 여기서 sort는 함수라고 하지않고 객체에 속해있기 때문에 메소드라고 한다. 이러한 numbers객체 또는 sort메소드는 Javascript에서 기본적으로 제공하는 기능이기 때문에 이러한 기능을 내장 객체 내장 메소드, 또는 빌트인 객체 빌트인 메소드라고 한다. 그리고 우리가 만드는 객체나 메소드, 함수같은 것들은 우리가 만드는 것이기 때문에 사용자정의 객체, 사용자정의 메소드 라고한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    numbers.sort(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 실행하면 배열안의 내용을 정렬해주고 결과는 [1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9] 가 출력된다. 이유는 숫작의 크기로 비교한게 아니고 문자로 비교를 했기 때문이다. 앞의 숫자가 1인것들이 우선순위를 갖고 나머지를 정렬했기 때문이다. 우리가 원하는 결과를 얻기 위해선 아래의 방법을 이용해야 한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        console.log(a, b);        if(a &gt; b) {            return 1;        } else if (a&gt;b){            return -1;        } else {            return 0;        }    }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 코드를 단순하게 하면 아래처럼 된다. 아래의 함수에서 sortfunc가 콜백함수가 되고 콜백 함수 라는것은 콜백함수를 수신받는 sort메소드가 sortfunc를 인자로 전달받아 내부적으로 호출하는 것을 통해서 sort함수가 동작하는 기본적인 동작방법을 변경할수 있게 된다. 즉, 값으로서 함수를 사용할수 있기때문에 함수의 동작방법을 값을 전달하는 것을 통해 바꿀수 있는게 콜백 이다. 그리고 콜백이 가능한 것은 Javascript의 함수가 값이기 때문에 가능한 것이다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    var numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];    var sortfunc = function(a, b) {        return a-b; // 역순 b-a     }    console.log(numbers.sort(sortfunc)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 비동기 콜백과  Ajax예를 들어 우리가 홈페이지를 운영하는데 만명정도의 구독자가 있다고 치자. 우리가 글을쓰면 만명에게 메일이 전송되게 되어있다. 한명에게 메일을 보내는데 1초가 걸리면 만명에게 보내는데에는 만초가 걸리게 된다. 글을 작성하고 이메일을 전송후 작성완료까지 3시간을 기다려야 한다면 이런 서비스를 사용하기는 힘들것이다.이렇게 순서대로 실행하는 것을 동기적 처리라고한다. 그런데 우리가 글작성을하고 이메일을 발송하지 않고 발송 예약후 작성완료를 하게 되면 시간이 훨씬 줄어들게 된다. 그리고 내부적으로 사용자에게 노출되지 않는 프로그램이 작동하면서 이메일 발송예약이 들어와 있는지 아닌지를 확인해 들어와있다면 프로그램이 만명에게 이메일 발송하는 작업을 3시간동안 백그라운드에서 진행하면 될것이다. 이렇게 처리하는 방식을 비동기적인 처리라고한다. 우리는 이 비동기적 처리를 Ajax(Asynchronous javascript and xml) 로 사용할 수 있다.우리가 아래와 같은 객체를 만든 파일을 만들었다고 가정하고 예제를 보자.{\"title\":\"JavaScript\",\"author\":\"egoing\"}생활코딩의 동영상을 보고 이해하는것이 좋겠다…(아직 이해못함.)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"//code.jquery.com/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;    $.get('./datasource.json.js', function(result){ //$는 jquery가 제공하는 특수한 객체이다. 여기에 get이라는 메소드를 사용해 json타입 파일을 호출하는 것이다.        console.log(result);    }, 'json');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;",
        "url": "/javascript-basic13"
    }
    ,
    
    "javascript-basic12": {
        "title": "Javascript - JavaScript 함수지향 - 유효범위",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수지향 - 유효범위1. 전역변수와 지역변수유효범위(Scope)는 변수의 수명을 의미한다. 아래의 예제를 보자. vscope라는 변수에 global이라는 데이터를 할당했다. fscope라는 함수는 함수 안에 선언되어 있지 않은, 함수 바깥쪽에 선언되어있는 vscope에 접근할 수 있다. 결과는 global이다.var vscope = 'global';function fscope(){    alert(vscope);}fscope();아래를 실행하게 되면 결과는 ‘함수안 local’과 ‘함수밖 global’이 출력된다. fscope 함수안에 vscope라는 변수가 할당되어 있기 때문에 vscope는 자기자신과 가까이에 있는 vscope를 가르키기 때문에 ‘local’이라는 값을 출력하게 된다. 함수안의 fscope 함수안에 정의 되어 있는 vscope는 지역변수(local variables) 이고, 함수밖에  정의되어 있는 vscope변수는 전역변수(global variables)라고 한다.즉 지역변수의 유효범위는 함수 안이고, 전역변수의 유효범위는 에플리케이션 전역인데, 같은 이름의 지역변수와 전역변수가 동시에 정의되어 있다면 지역변수가 우선한다는 것을 알 수 있다.var vscope = 'global';function fscope(){    var vscope = 'local';    alert('함수안 '+vscope);}fscope();alert('함수밖 '+vscope);var을 쓴것과 쓰지않은것의 차이점을 알아보자. var을쓰면 전역변수를 호출하게되고 var을 쓰지않으면 vscope가 지역변수가 되어 global을 local로 변경하게된다. 즉,  var을 사용하지 않은 지역변수는 전역변수가 된다. fscope라는 함수에 var쓰고 변수를 지정하게 되면 fscope함수에 지역변수를 지정한것이다. 그렇기 때문에 전역 변수의 값이 local로 변경 된 것이다. 그렇기 때문에 출력은 local이 되게 된다.var vscope = 'global';function fscope(){    var vscope = 'local';   }fscope();alert(vscope);// var을 쓸때 global// var을 쓰지 않을때 local아래 예제는 어떻게 될까? 마찬가지로 global을 출력하게 된다. 이유는 이미 var vscope으로 인해 지역변수가 생성이되었다. 그렇기 때문에 vscope를 사용해도 지역변수가 되는것이지 전역변수가 변경되지는 않는다.var vscope = 'global';function fscope(){    var vscope = 'local';    vscope = 'local';   }fscope();alert(vscope);// global2. 유효범위의 효용아래 두개의 예제는 변수 i를 지역변수로 사용했을 때와 전역변수로 사용했을 때의 차이점을 보여준다. 전역변수는 각기 다른 로직에서 사용하는 같은 이름의 변수값을 변경시켜서 의도하지 않은 문제를 발생시킨다.같은 이름을 사용했지만 var을 사용하는것과 사용하지 않는것의 차이가 있다. for문 안에들어있는 i의 값이 선언된것은 어떤 함수에 소속되지 않은 것이다. 그렇기 때문에 전역변수이고 함수 a를 호출하게 되면 변수 i의 값을 0으로 바꿔주고 있다. 그런데 var을 붙이지 않은것은 전역변수를 의미하게 된다. a함수와 for문이 가르키고 있는 i가 같기때문에 a가 실행될때마다 i의값이 매번 0으로 초기화된다. 따라서 무한반복하는 현상이 나타나고 같은이름의 변수를 중복해서 사용했지만 각각의 취지가 다를 때 이런현상이 일어난다.function a (){    var i = 0; //결과 01234    // i=0; // 결과 무한반복}for(var i = 0; i &lt; 5; i++){    a();    document.write(i);}3. 전역변수를 사용하는 법불가피하게 전역변수를 사용해야 하는 경우는 하나의 객체를 전역변수로 만들고 객체의 속성으로 변수를 관리하는 방법을 사용한다.아래의 예제는 MYAPP이라는 전역변수 하나를 만들어서 속성을 지정해 만들었다. 이처럼 전역변수 하나만을 만들고 나머지 다른 전역변수들은 바로 그 전역변수의 소속에 해당되게 만들면 변수의 이름이 충돌할 가능성이 낮아진다.var MYAPP = {}MYAPP.calculator = { //calculator 속성    'left' : null,    'right' : null}MYAPP.coordinate = {    'left' : null,    'right' : null} MYAPP.calculator.left = 10;MYAPP.calculator.right = 20;function sum(){    return MYAPP.calculator.left + MYAPP.calculator.right;}document.write(sum());아래의 예제는 함수안에 변수를 지정해 함수의 지역변수로 만들었다. 함수를 정의하고 바로 호출하는 기법을 익명함수라고 한다. 이러한 기법을 이용해 전역변수가 하나도 존재하지않는 방식을 사용할 수도있다.(function(){    var MYAPP = {}    MYAPP.calculator = {        'left' : null,        'right' : null    }    MYAPP.coordinate = {        'left' : null,        'right' : null    }    MYAPP.calculator.left = 10;    MYAPP.calculator.right = 20;    function sum(){        return MYAPP.calculator.left + MYAPP.calculator.right;    }    document.write(sum());}())4. 유효범위의 대상Javascript는 함수에 대한 유효범위만을 제공한다. 다시말해 Javascript 에선 for문이나 if문에서 중괄호 안에서 선언된 변수는 지역변수로서의 의미를 갖지 않는다. 많은 언어들이 블록(대체로 {,})에 대한 유효범위를 제공하는 것과 다른 점이다. 아래 예제의 결과는 coding everybody이다.for(var i = 0; i &lt; 1; i++){    var name = 'coding everybody';}alert(name);자바에서는 아래의 코드는 허용되지 않는다. name은 지역변수로 for 문 안에서 선언 되었는데 이를 for문 밖에서 호출하고 있기 때문이다.for(int i = 0; i &lt; 10; i++){    String name = \"egoing\";}System.out.println(name);5. 정적 유효범위자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다. 이러한 유효범위의 방식을 정적 유효범위(static scoping), 혹은 렉시컬(lexical scoping)이라고 한다. 이는 이후에 살펴볼 클로저와 연관되어 있다.전역변수 var i = 5가 정의되어 있고 a 함수는 var i = 10이라는 지역변수를 정의하고 있다. a라고 하는 함수를 호출했을 때 함수의 내부적으로 i의 값이 10이 된다. 그 상태에서 b를 호출하게 되면 i는 b 함수 안에 i라고 하는 지역변수가 존재하는지 찾게 된다. 없다면 전역변수를 찾게 되는데 b를 호출하고 있는 함수는 a이다.그렇다면 a 함수에 정의된 변수 a를 호출하게 될까? 아니다. 왜냐하면, 함수 b가 선언된 시점에서 i의 전역변수가 사용되는 것이지 b가 호출된 시점에서 b가 담겨있는 함수의 지역변수가 사용되는 것이 아니다. 즉, 사용될 때 가 아니고 정의 될 때의 전역변수가 사용되게 된다는 말이다. 이러한 것을 정적 유효범위 또는 렉시컬(lexical scoping)유효범위라고 한다.var i = 5; // 전역변수 function a(){    var i = 10; // 지역변수    b();} function b(){    document.write(i);} a(); // 5",
        "url": "/javascript-basic12"
    }
    ,
    
    "javascript-basic11": {
        "title": "Javascript - JavaScript 정규표현식",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 정규표현식정규표현식(Reguler expression)은 문자열 안에서 어떠한 문자가 있는지 없는지, 그문자를 다른 문자로 치환하는 것들을 도와주는 방법이다. 정보와 관련된 언어에서는 정규표현식이 매우 중요하다. 정규표현식의 공부는 양이 많아 따로 해야한다 링크를 통해 공부하고 아래내용을 보는게 좋겠다.1. 패턴만들기정규 표현식은 두가지 사용방법으로 이루어진다. 하나는 컴파일(compile) 다른 하나는 실행(execution)이다. 우선 컴파일부터 알아보자. 우리가 문자열을 변수에 담을때 var str = “a”; 의 식으로 하게된다. 마찬가지로 우리가 정규표현식을 만들때 정규표현식 리터럴이라는것을 이용해 만든다.//정규표현식 리터럴var pattern = /a/;또하나의 방법은 정규표현식 객체 생성자를 사용하는 방법이다. 두방법 모두 정규표현식 객체를 pattern이라는 변수에 담은것이다. 우리가 찾고자하는 정보를 pattern이라는 변수에 저장을 한것이다.var pattern = new RegExp('a');2. RegExp객체의 사용우리가 어떤일을 할때 두가지 방법이 있다. 작업을 할 대상을 선택하고 그리고 그대상에 대하 어떤작업을 할지 정한다. 먼저 해야할 것은 작업할 대상을 찾는것이다. 이작업을 할수 있게 해주는게 정규표현식이다.정규표현식 메소드 실행정규표현식을 컴파일해서 객체를 만들었다면 이제 문자열에서 원하는 문자를 찾아내야 한다.RegExp.exec()문자열 a를 찾고싶다고할때 pattern변수안에 정규표현식 a를 지정하고 RegExp.exec()로 실행을 시킬수 있다.RegExp는 정규표현식을 의미하고 exec는 실행을 의미한다. 즉, 우리가 지정한 정규표현식을 실행하는데 그실행의 대상을 첫번째 인자로 전달하고, 그정보가 있는지 없는지 찾으려고 하는 정보가 (‘abcdef’) 이고 이것이 두번째 인자가 된다. 실행결과는 문자열 a를 값으로 하는 배열을 리턴한다.var pattern = /a/;console.log(pattern.exec('abcdef')); // [\"a\"]이번엔 변수에 정규표현식 a.을 담았다. 결과는 ab가되는데 이것은 정규표현식에서 .이 문자 1개를 의미하기 때문이다.var pattern = /a./;console.log(pattern.exec('abcdef')); // [\"ab\"]인자 ‘bcdef’에는 a가 없기 때문에 null을 리턴한다.var pattern = /a/;console.log(pattern.exec('bcdefg')); // nullRegExp.test()우리가 필요한 정보를 추출해내야 할때 사용한다. 우리가 찾는 어떤 정보가 있는지 없는지를 존재 유무를 테스트 한다.test는 인자 안에 패턴에 해당되는 문자열이 있으면 true, 없으면 false를 리턴한다var pattern = /a/;console.log(pattern.test('abcdef')); // truecnosole.log(pattern.test('bcdefg')); // false3. String과 정규표현식String.match()RegExp.exec()와 비슷하다.var pattern = /a/;console.log('abcdef'.match(pattern)); // [\"a\"]console.log('bcdefg'.match(pattern)); // nullString.replace()String.replace()는 문자열에서 패턴을 검색해서 이를 변경한 후에 변경된 값을 리턴한다.pattern a를 찾아 A로 치환해주었다.console.log('abcdef'.replace(pattern, 'A'));  // Abcdef4. 옵션(i, g)정규표현식 패턴을 만들 때 옵션을 설정할수있다. 찾고자하는 값 뒤에 옵션을 넣어주면 되고, 옵션에 따라 검출되는 데이터가 달라진다.i는 대소문자 구분을 없애주는 역할을 한다.var xi = /a/;console.log(\"Abcde\".match(xi)); // nullvar oi = /a/i;console.log(\"Abcde\".match(oi)); // [\"A\"];g는 문자열에 포함되어 있는 패턴에 해당되는 문자열들을 모두 리턴해준다.var xg = /a/;console.log(\"abcdea\".match(xg)); // [\"a\"]var og = /a/g;console.log(\"abcdea\".match(og)); // [\"a\",\"a\"]두가지 모두 사용도 가능하다.var og = /a/ig;console.log(\"AabcdAa\".match(ig)); // [\"A\",\"a\",\"A\",\"a\"]5. 캡쳐그룹을 지정하고 지정된 그룹을 가져와 사용하는 기능, 또는 사용할 수 있는 개념을 캡쳐라고 부른다.var pattern = /(\\w+)\\s(\\w+)/; // 문자열 공백 문자열var str = \"coding everybody\"; //coding$1 everybody$2var result = str.replace(pattern, \"$2, $1\"); //$2,(공백)$1로 치환.console.log(result);//everybody, coding6. 치환아래 코드는 본문 중의 URL을 링크 html 태그로 교체한다. \\b는 단어를 식별한다. ?:로 https를 캡쳐로 지정하지 않고 뒤에 ?로 https, http가 모두 해당되게 했다. 뒤에 //는 escape를 사용해 문자화 시켰고 그뒤의 a-z는 a부터 z까지 0-9 는 0에서 9까지 그리고 그뒤에 주소에 들어갈만한 특수문자들 까지 해당되게 해줬다. 그리고 replace라는 메소드가 실행될때 urlPattern해당되는 텍스트를 찾을때마다 두번째인자로 전달된 함수가 replace라는 메소드 내부로 호출된다. 호출될때 javascript는 호출된 시점에서 검색된 문자열을 첫번째 인자(url)로 전달되게 약속되어있다. 그리고 그 텍스트를 가공을하고 리턴을 해주면 우리가 변경하고싶은 내용으로 변경되게 된다.var urlPattern = /\\b(?:https?):\\/\\/[a-z0-9-+&amp;@#\\/%?=~_|!:,.;]*/gim;var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';var result = content.replace(urlPattern, function(url){    return '&lt;a href=\"'+url+'\"&gt;'+url+'&lt;/a&gt;';});console.log(result);//생활코딩 : &lt;a href=\"http://opentutorials.org/course/1\"&gt;http://opentutorials.org/course/1&lt;/a&gt; 입니다. 네이버 : &lt;a href=\"http://naver.com\"&gt;http://naver.com&lt;/a&gt; 입니다.",
        "url": "/javascript-basic11"
    }
    ,
    
    "javascript-basic10": {
        "title": "Javascript - JavaScript UI와 API",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript UI와 API1. UI란?UI(User Interface)는 컴퓨터의 시스템과 사용자의 접점에 존재하며 중개자에 해당하는 것을 UI라고 한다. 사용자를 대면하는 접점을 하는 지점을 UI라고하고 물리적, 하드웨어적 UI가 있고 소프트웨어적 UI가 있다. 노트북이나 키보드에 있는 버튼이 하드웨어적 UI라 할수있고 브라우저의 각종 버튼이 소프트웨어적 UI라 할수 있겠다.2. API란?API란 Application Programming Interface의 약자로 프로그램이 동작하는 환경을 제어하기 위해서 환경에서 제공되는 조작 장치이다. 이 조작 장치는 프로그래밍 언어를 통해서 조작할 수 있다. 일반 사용자는 UI를 사용해 원하는 결과를 얻고 개발자는 API를 이용해 자신이 하고자하는 프로그래밍을 하게된다.Javascript의 APIJavascript의 API는 크게 Javascript 자체의 API와 Javascript가 동작하는 호스트 환경의 API로 구분된다. 현재 우리가 공부하는건 Javascript자체의 API이고 앞으로 나아가 더 공부를 하게되면 호스트 환경에서의 API도 공부해야한다.Javascript API 문서Javascript가 제공하는 기본적인 API를 볼수있는 사이트이다. 여기서 필요한 API를 찾아 사용하면 된다.  ECMAScript.  Javascript사전.  Javascript 레퍼런스 MDN.  jscript 레퍼런스.호스트 환경의 API 문서호스트 환경에서의 API를 볼수있는 사이트이다. 지금 우리는 기본적인 Javascript의 API를 공부하고 있어 당장은 필요하지 않지만 앞으로 심화과정에 들어가면 사용할 일이 있을것이다.  웹브라우저 API.  Node.js API.  Google Apps Script API.",
        "url": "/javascript-basic10"
    }
    ,
    
    "javascript-basic9": {
        "title": "Javascript - JavaScript 모듈",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 모듈1. 모듈이란?프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 이과정에 필요한 것은 코드의 재활용성, 유지보수의 편의성등이 있다. 어떤 프로그램을 구성하고 있는 수만은 로직들을 재사용 할 수 있는 단위로 조각조각 나누어 구획화를 시켜 별도의 모듈이라는 형태로 떼어내 이것을 또다른 프로그램의 부품으로 사용하는 기법, 그런 부품들을 모듈이라 하고 이러한 기법을 모듈화 라고 한다. 아래는 모듈화를 통해 얻을 수 있는 효과이다.  자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.  코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.  코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.  필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.  한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)Javascript에서는 모듈이라는 개념이 분명하게 존재하지 않는다. Javascript에서는 모듈이라는 기능 자체를 제공하지 않는다. 구동 환경(호스트 환경)에 따라서 Javascript로직 구성을 모듈형식으로 구성해 사용한다.2.모듈화모듈화를 알기 전에 모듈이 없다는 가정을 해보자. 그리고 funcion함수가 엄청 복잡하다고 가정하고, 함수 호출도 여러번하며 html파일이 아래 welcome이라는 함수를 여러 html에서 호출한다고 생각해보자. 그렇다면 welcome이라는 함수를 해당 페이지에 두는것은 덩치가 엄청 커질것이다. 이런경우 내가 필요한 코드와 그렇지 않은 코드를 분류하는게 힘들어 질 것이다. welcome이라는 함수를 별도의 파일로 빼고 그 별도의 파일을 읽어 오는것을 통해 welcome이라는 함수를 사용할 수 있다면 복잡한 코드가 한줄로 바뀔 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function welcome(){            return 'Hello world'        }        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;아래 예제에서 별도의 파일로 js를 불러오는 형식을 알아보자. 아래 내용을 코드를 에디터를 활용해 실행해보자. greeting.js 라는 파일에 위 예제에서 사용한 function함수를 저장하고 불러오는 형식이다.&lt;script type=”text/javascript” src=”greeting.js”&gt;&lt;/script&gt; 그다음 welcom함수를 호출하면 greeting.js파일에서 불러오게 된다. 다른 html파일에서도 마찬가지로 위 코드로 불러와 함수를 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;    &lt;script type=\"text/javascript\" src=\"greeting.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        alert(welcome());    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.node.js의 모듈화모듈을 로드하는 방법은 호스트 환경에 따라서 달라진다. Node.js에서는 아래와 같은 방법으로 모듈을 로드한다.var PI = Math.PI;  exports.area = function (r) {return PI * r * r;};  exports.circumference = function (r) {return 2 * PI * r;};var circle = require('./node.circle.js');console.log( 'The area of a circle of radius 4 is '           + circle.area(4));4.라이브러리라이브러리는 자주 사용되는 로직을 재사용되기 편리하도록 잘 정리한 일련의 코드들의 집힘을 의미한다고 할 수 있다. 오픈 소스를 통해 만들어진 수많은 라이브러리가 있기 때문에 우리가 만들고자 하는 프로그래밍의 핵심적인 부분이 아니라면 공개되어있는 좋은 라이브러리를 선택하고 잘 사용하는 것은 프로그래밍의 핵심이라고 할 수 있다. Javascript로 웹 브라우저를 제어하는 방법은 기본적으로 웹 브라우저가 제공하는 기능, Javascript가 제공하는 기능을 이용해 모든 것을 다 할 수 있다. 다르게 말하면 웹 브라우저와 Javascript가 제공하지 않는 기능은 전혀 사용할 수 없다. 왜냐하면, 브라우저가 허용하는 기능만을 쓸 수 있기 때문이다. 브라우저의 기능이 너무 다양하고 파편화되어 있기 때문에 라이브러리를 사용한다. 라이브러리는 어떤 목적을 정해놓고 목적을 쉽게 달성할 수 있게 만들어놓은 프로그래밍의 집합이기 때문이다. 우리가 사용해볼 라이브러리는 query다.5. 라이브러리 사용하기jQuery를 이용한 예제와 사용방법을 알아볼 것이다. 하지만 jQuery에 대한 공부를 하는것 보다 어떻게 사용하는지에 대한 예제 이기 때문에 jQuery강의를 보고 공부를 해야한다. 아래 코드list에있는 empty를 한번에 coding paratice gym으로 바꾸는 예제이다. 아래의 상태에서&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;아래 예제 처럼 변경해준다. 아래 jQuery를 사용한 3줄의 코드로 작업을 수행하게 되었다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=\"text/javascript\" src=\"./jquery.js\" &gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input type=\"button\" value=\"execute\" id=\"execute_btn\"/&gt;    &lt;script type=\"text/javascript\"&gt;        $('#execute_btn').click(function(){            $('#list li').text('coding practice gym');        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;하지만 jQuery를 사용하지 않으면 아래 예제처럼 쉽지않은 프로그래밍을 해야한다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;ul id=\"list\"&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;        &lt;li&gt;empty&lt;/li&gt;    &lt;/ul&gt;    &lt;input id=\"execute_btn\" type=\"button\" value=\"execute\" /&gt;    &lt;script type=\"text/javascript\"&gt;    function addEvent(target, eventType,eventHandler, useCapture) {        if (target.addEventListener) { // W3C DOM            target.addEventListener(eventType,eventHandler,useCapture?useCapture:false);        } else if (target.attachEvent) {  // IE DOM            var r = target.attachEvent(\"on\"+eventType, eventHandler);        }    }    function clickHandler(event) {        var nav = document.getElementById('list');        for(var i = 0; i &lt; nav.childNodes.length; i++) {            var child = nav.childNodes[i];            if(child.nodeType==3)                continue;            child.innerText = 'Coding everybody';        }    }    addEvent(document.getElementById('execute_btn'), 'click', clickHandler);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이번 강의에선 라이브러리가 중요하다는 것을 알아야 한다. 세세하게 어떻게 하는지 알려고 하는 것보단 라이브러리의 장점과 편의성에 초점을 맞추고 이후 나오는 내용에서 자세히 알아볼 시간이 있을 것이다.",
        "url": "/javascript-basic9"
    }
    ,
    
    "javascript-basic8": {
        "title": "Javascript - JavaScript 객체(Object)",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 객체(Object)1. 객체의 소개와 문법배열은 연관되어 있는 데이터들을 담아내기 위한 그릇이다. 마찬가지로 객체도 연관된 데이터를 담아내는 것에 있어서 유사하다. 하지만 똑같은 그릇이 있다고 쳤을 때 객체도 그릇에 담아내는 것은 같지만 index의 값으로 숫자나 문자를 쓸 수도 있고, 인덱스로 우리가 원하는 데이터를 지정할 수 있다는 것이 둘의 차이점이라고 할 수 있다. 다른 언어에서는 연관배열(associative array) 또는 맵(map), 딕셔너리(Dictionary)라는 데이터 타입이 객체에 해당한다.객체의 생성객체를 만드는 법을 알아보자. 배열은 대괄호로 시작해 대괄호로 끝나지만,객체는 중괄호로 시작해 중괄호로 끝나게 된다. 아래는 데이터값으로 숫자를 썻지만 문자나 다른 데이터를 할당하는 것도 가능하다. 아래 예제에서 ansang은 key(index)가 되고 10은 value(데이터 값)가 된다.var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghyun': 80};            // key : value  key : value  key : value 위의 상태에서 객체를 대표하는 변수를 grades로 지정하고 grades를 호출하면 아래와 같은 값이 나오게 된다.gradesodject {ansang: 10, sanghyun: 6, ansanghyun: 80}아래는 객체를 만드는 다른 방법이다.var grades = {};grades['ansang'] = 10; //key는 ansang value는 10grades['sanghyun'] = 6; //key는 sanghyun value는 6grades['ansanghyun'] = 80; //key는 ansanghyun value는 80위에서 객체를 호출하는 방법은 아래와 같다. 아무래도 garade.ansang가 간편하지만, 프로그래밍 적인 기재가 불가능하다 이 경우 garade.’an’+’sang’로 호출하게 되면 SyntaxError가 나오게 된다. 즉 . 뒤의 내용을 프로그래밍 적으로 만들 수 없다. []안에 들어가는 값은 프로그래밍 적으로 생성이 가능하기 때문에 필요에 따라 대괄호 안에 작성하는 게 편리하거나 써야만 하는 상황이 있을 수 있다.grades['ansang'] //value 10garade.ansang //value 10grades['an'+'sang'] //value 102.객체와 반복문 for in객체에 저장된 데이터를 기준으로 반복하는 작업을 알아보자. 배열은 저장된 데이터들이 순서를 가지고 있다. 그래서 배열에선 순서 자체가 중요한 정보이다. 하지만 객체엔 순서가 없고, key와 value로 이루어져 있기 때문에 저장된 순서는 없기 때문에 저장된 값이 순서에 따라서 나오지 않을 것 이라는 걸 인지해야 한다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(key in grandes) {    document.write(\"key : \"+key+\" value : \" + grades[key] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/또는 key부분을 변수로 바꿔도 된다. 아래는 var name으로 바꿔보았다.var grades = {'ansang' : 10, 'sanghyun' : 6, 'ansanghynu' : 80}for(var name in grandes) {    document.write(\"key : \"+name+\" value : \" + grades[name] + \"&lt;br /&gt;\");}/*출력key : ansang value : 10key : snaghyun value : 6key : ansanghyun value : 80*/더 보기 편하게 리스트 형태로 만들어보자. html에서의 ul태그와 li태그를 사용해본다.  &lt;ul&gt;    &lt;script type=\"text/javascript\"&gt;        var grades = {'ansang': 10, 'sanghyun': 6, 'ansanghynu': 80};            for(var name in grades) {            document.write(\"&lt;li&gt;key : \"+name+\" value : \"+grades[name]+\"&lt;/li&gt;\");            }        &lt;/script&gt;  &lt;/ul&gt;        /* 출력        -key : ansang value : 10        -key : snaghyun value : 6        -key : ansanghyun value : 80        */배열도 for in문으로 사용할수 있다. 배열에선 var name으로 지정한 값이 index가 됨으로 console.log(name)에서 012라는 index가 추출되고 console.log(arr[name])에선 abc라는 데이터가 출력된다.var arr = ['a', 'b', 'c']for(var name in arr) {    console.log(name);}//출력 //0//1//2for(var name in arr) {    console.olg(arr[name]);}3. 객체 지향 프로그래밍객체 지향 프로그래밍이란 서로 연관되어있는 데이터와 처리형식을 하나의 그릇안에 그룹핑 해놓은 프로그래밍을 객체 지향 프로그래밍 이라한다.객체에 담길 수 있는 값이 무엇지에 대해 알아보자. 아래 예제는 객체 안에 객체와 함수를 담았다. list라는 key 값에 {‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}라는 value를 넣었고 이 value는 객체이다. show라는 key값에 function(){ alert(‘Hello World’)}; 라는 value를 담았다. javascript에서는 함수도 일종의 값이고 함수도 변수에 저장될 수 있기 때문에 마찬가지로 값으로서의 함수도 객체 안에 저장될 수 있다(고하는데 아직 뭔 소린지 모르겠음).grades에 담긴var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert('Hello World');    }}alert(grades['list']['ansang']); //ansang이라는 key가 갖고있는 10이라는 value에 접근alert(grades['show']); // 함수에 접근this라는 키워드를 알아보자. this라는 것은 javascript에서 약속되어있는 변수이다. this 변수는 함수가 속해있는 객체를 가르치는 변수이다. 함수가 소속되어있는 객체를 가르친다는 말이다.아래 예제는 grades라는 객체가 갖고있는 key 값 중 show를 호출해 show 함수가 가진 this변수로 list객체{‘ansang’ : 10, ‘sanghyun’ : 8, ‘ansanghyun’ : 80}를 출력하게 된다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        alert(this.list);    }}grades['show']();이번엔 개발자 도구에서 console.log(name, this.list[name]);를 사용해 key와 value를 호출해보자. value를 호출하는 방법은 위에서 배웠듯,  grades[‘ansang’] , garade.ansang 두가지가 있다. for in 문을 사용했기 때문에 list[name]을 사용하면 value 값을 불러올 수 있다.var grades = {    'list' : {'ansang' : 10, 'sanghyun' : 8, 'ansanghyun' : 80},    'show' : function(){        for(var name in this.list){            console.log(name, this.list[name]); // ,를 쓰게되면 여러 값을 출력할 수 있다.        }    }}grades.show();",
        "url": "/javascript-basic8"
    }
    ,
    
    "javascript-basic7": {
        "title": "Javascript - JavaScript 배열",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 배열1. 배열의 문법배열배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해 사용하는 데이터의 형식이다. 변수는 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 하나의 변수에 저장하기 위해 사용한다. 아래 코드는 name이라는 변수에 ‘Ahnsang’이라는 데이터를 할당한 것이다.var name = 'Ahnsang'alert(name);배열의 생성위에선 변수에 하나의 데이터를 할당 했다. 이제 배열로 여러개의 데이터를 변수에 할당하는 방법을 공부해 보자.여러개의 데이터를 할당 하려면 변수명 = 뒤에 [] 대괄호를 사용해 여러개의 데이터를 작성할 수 있다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']이 각각의 데이터를 요소,또는 원소(Element)라고 부르고 이제 이 원소들을 호출할것이다. 요소는 순서대로 0,1,2의 고유한 값,식별자를 가지게 된다. 색인 이라고도 하고 index라고도한다.var member = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert(member[0]);alert(member[1]);alert(member[2]);코드를 실행하면 차례대로 ‘Ahnsang’, ‘SangHyun’, ‘AhnSangHyun’ 세개의 데이터를 차례로 경고창에 출력해준다.2. 배열의 효용성배열이 없다면 변수에 하나의 데이터만 할당할수 있기 때문에 불편할 것이다. 아래의 예제를 보자.함수는 여러개의 입력값을 받을 수 있지만, 하나의 출력만 할 수 있다.function get_member1(){    return 'Ahnsang';}document.write(get_member1()); function get_member2(){    return 'SangHyun';}document.write(get_member2());  function get_member3(){    return 'AhnSangHyun';}위 코드처럼 배열을 사용하지 않으면 각각의 회원정보를 반환하는 함수로 표한해야한다. 배열을 사용해 코드를 만들어 보자. return 안에 배열을 사용해 각각의 색인으로 원하는 정보를 호출할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0]);document.write(members[1]);document.write(members[2]);3. 배열의 사용 - 배열과 반복문우리가 배열을 사용해 index값을 호출할때 그 값을 일일히 기억해서 호출한다는것은 불가능하다. 배열이 몇백 몇천개가 사용될수도 있기 때문이다. 그렇기 때문에 배열이란 결국 배열에 담겨있는 값을 하나하나 꺼내서 그꺼내진 값을 가공하는게 배열의 핵심적인 요소라고 할수있다.아래 예제에서 출력값을 대문자로 출력하려고 .toUpperCase();라는 javascript내장함수를 사용해 출력했다.‘AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();document.write(members[0].toUpperCase()+\"&lt;br /&gt;\");document.write(members[1].toUpperCase()+\"&lt;br /&gt;\");document.write(members[2].toUpperCase()+\"&lt;br /&gt;\");위 예제 처럼 우리가 직접 손으로 배열을 호출을 하기엔 무리가 있다. 이때 사용할 수 있는 방법이 배열과 반복문을 결합하는 것이다. 그전에 한가지 예제를 더 보자. 아래 예제는 배열의 값이 몇개인지 나타내 주는 함수이다. 경고창 내용은 3을 출력하게 된다.var a = ['Ahnsang', 'SangHyun', 'AhnSangHyun']alert (a.length);이제 배열과 반복문을 결합한 예제를 보자. i란변수를 지정하고 시작은 0에서 1씩 증가해 2로 끝나게 된다. 이렇게 나온 0, 1, 2는 index 값으로 사용하고, members[index값]에 i의 값이 어가게 되어 차례로 출력할 수 있게 된다.’AHNSANG’,’SANGHYUN’,’AHNSANGHYUN’을 출력하게 될것이다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; 3; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}그런데 여기서 배열의 갯수가 늘어난다면 우리는 반복문의 조건을 수정해야한다. 이것도 함수를 사용해 더 편리하게 만들어 보면, 우리는 members라는 변수에 get_members라는 함수를 호출했다. 그 함수안에 return의 배열이 들어있기 때문에 members.length함수를 사용하면 배열안의 요소의 갯수를 호출해 사용할 수 있다.function get_members() {    return ['Ahnsang', 'SangHyun', 'AhnSangHyun']}var members = get_members();for(var i = 0; i &lt; members.length; i++) {    document.write(members[i].toUpperCase()+\"&lt;br /&gt;\");}4. 배열의 제어배열은 복수의 데이터를 효율적으로 관리, 전달하기 위한 목적으로 고안된 데이터 타입이다. 따라서 데이터의 추가/수정/삭제와 같은 일을 편리하게 할 수 있도록 돕는 다양한 기능을 가지고 있다. 몇가지 중요한 기능들만 살펴보자.배열의 조작 - 추가 push배열의 끝에 원소를 추가하는 방법을 알아보자. push는 인자로 전달된 값을 배열에 추가하는 javascript 내장함수 이다. 아래 코드를 실행하면 “f”가 추가된 배열이 출력된다.var li = ['a', 'b', 'c', 'd', 'e'];li.push('f');alert(li);아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();배열의 추가 concatconcat(concatenate)은 복수의 원소를 배열에 추가하는 방법이다. 추가한 출력은 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’,’f’, ‘g’] 가된다.var li = ['a', 'b', 'c', 'd', 'e'];li = li.concat(['f', 'g']);alert(li);배열의 추가 unshiftunshift는 배열의 시작점에 원소를 추가하는 방법이다. 출력은 [‘z’,’a’, ‘b’, ‘c’, ‘d’, ‘e’] 가되고 index도 0~5로 변경된다.var li = ['a', 'b', 'c', 'd', 'e'];li.unshift('z');alert(li);배열의 추가 splicesplice는 배열의 특정구간을 추출하거나, 특정구간에 특정 배열을 추가하는 방법이다. 문법은 아래와 같고,array.splice(index, howmany, element1, ...., elementN);아래 표를 보면서 이해해보자.            인자명      데이터형      필수/옵션      설명                  index      number      필수      배열에 추가할 특정 배열의 위치를 가르키는 index              howmany      number      필수      index에서부터 제거될 원소들의 수. index부터 index+howmany에 해당하는 원소들은 삭제된다. 이 값이 0이면 어떠한 원소도 삭제되지 않는다.              element1,…,elementN      number      옵션      index와 index+howmany 사이에 추가될 값      아래와 같이 splice를 이용해 배열에 ‘x’,’y’를 추가하는 코드가 있다. splice뒤에 오는 1은 [a,b,c] 배열에서 ‘b’를 가르키고 0은 ‘b’를 제거하지 않고 index 1번 위치에 ‘x’,’y’를 추가하겠다는 말이다.이러면 배열은 [‘a’,’x’,’y’,’b’,’c’] 가된다.var a = ['a','b','c']a.splice(1,0,['x','y'])이번엔 기존 배열을 삭제하고 추가하는 예제를 보자. index 1번자리에 있는 ‘b’의 자리에서 2개의 원소를 삭제하고 [‘x’,’y’]를 순서대로 넣어주겠다는 말이다. 변경된 배열은 [‘a’ , ‘x’, ‘y’]가 된다.var a = ['a','b','c']a.splice(1,2,['x','y'])몇가지 예제를 더보자.var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2)); //2번 index를 포함 이후의 모든 요소를 제거한다.alert(numbers); // [1,2] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4)); // array, [3,4,5,6] var numbers = [1,2,3,4,5,6,7,8,9,10];alert(numbers.splice(2, 4, 'three', 'four', 'five', 'six')); // array, [3,4,5,6]alert(numbers); // array, [1,2,three,four,five,six,7,8,9,10]5. 배열의 조작 - 제거, 정렬제거 shiftshift는 배열의 첫번째 원소를 제거하는 방법이다. index 0번에 위치한 원소를 제거하고 나머지 값들을 한칸씩 앞으로 당겨온다. 만약 배열의 length가 0이면 undefined을 리턴한다. 아래 예제의 결과는 b, c, d, e다.var li = ['a', 'b', 'c', 'd', 'e'];li.shift();alert(li);제거 poppop은 배열의 마지막 원소를 제거하는 방법이다. 마지막 index에 위치한 원소를 제거하고 마찬가지로 빈 배열이라면 undefined을 리턴한다.var li = ['a', 'b', 'c', 'd', 'e'];li.pop();alert(li);정렬 sort배열을 이용하는 중요한 이유중 하나가 정렬이다. sort는 배열의 정렬을 하고싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.sort();alert(li);하지만 만약 배열이 [‘1’, ‘10’, ‘6’] 인경우엔 정렬이 1, 10, 6이 된다. 데이터를 문자로 보기때문에 앞에 1이 온 10을더 작다고 보는것이다. 이것을 올바르게 정렬하려면 아래와 같은 예제를 사용한다.function sortNumber(a,b){    return a-b; //역순을 구한다면 b-a를 활용한다.}var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]위 함수 a-b; 부분을 이해하려 찾아보았다. 정확하게 javascript에서 어떤 알고리즘으로 작동하는지 모르지만 이런 식으로 작동할 것이라는 글을 보게 되었다.만약 5,4,6,1,3,2 라는 배열이 있다고 가정하자.a-b에서 양수면 위치를 바꾸고 음수면 유지한다.5-4는 양수로 위치를바꾼다.4,5,6,1,3,24-6은 음수로 유지.4,5,6,1,3,24-1은 양수로 변경.1,5,6,4,3,21-3,1-2도 음수로 자리를 유지하고 index0번위치에 1이 오게된다.이제 1,5,6,4,3,2에서 두번째 자리를 찾는다.5-6은 음수로 유지.1,5,6,4,3,25-4는 양수로 변경.1,4,6,5,3,24-3은 양수로 변경.1,3,6,5,4,23-2는 양수로 변경.1,2,6,5,4,3 두번째 자리를 찾았다.….…이런 식으로 반복해서 찾는다는 글을 봤는데 맞는진 모르겠지만 이렇게 이해하면 좋을 것 같다.정렬 reversereverse는 역순으로 정렬하고 싶을때 사용한다.var li = ['c', 'e', 'a', 'b', 'd'];li.reverse();alert(li);",
        "url": "/javascript-basic7"
    }
    ,
    
    "javascript-basic6": {
        "title": "Javascript - JavaScript 함수",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 함수1. 함수란?함수(function)란 javascript에서 기본적인 구성 블록중 하나로, 작업을 수행하거나 값을 계산하는 문장 집합같은 절차이다. 함수는 하나의 로직을 재실행 할 수 있도록 하는것으로 코드의 재사용성을 높여준다.함수의 형식함수(function)의 형식은 아래와같다.function 함수명( [인자...[,인자]] ){   코드 내용   return 반환값}함수의 정의와 호출함수(function) 뒤에 함수의 이름이 오고, 소괄호가 따라온다. 우리가 변수를 호출하려면 변수를 정의하고 값을할당한후 그 변수를 호출해야한다. 함수도 마찬가지로 함수를 정의했으면 정의한 함수를 호출해야한다. 변수는 변수 이름만으로 호출하지만 함수는 함수명 뒤 (); 를 붙여줘야한다. ();를 붙이지 않으면 javascript는 변수로 인식하기 때문에 꼭 써줘야한다.function numbering() {    document.write(1);}numbering();다음 예제를 보자. 이 함수의 이름은 numbering이고, 내용은 0부터 9까지를 화면에 출력한다.function numbering(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1; // i = i + 1; 과 같다    }   }numbering();2. 함수의 효용성만약 함수가 없이 0~9까지의 코드를 출력하려고 하려고 하면 아래와 같이 하면 될것이다.var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}var i = 0while(i &lt; 10&gt;){    document.write(i);    i +=1;}그런데 위의 코드를 0에서19까지로 바꿔야한다면 while(i &lt; 10&gt;) 부분을 while(i &lt; 20&gt;)으로 바꿔줘야 한다. 5번만 호출한다면 어렵지 않겠지만 많은 횟수를 호출하는 상황에선 어려운 작업이 될것이다. 이럴때 함수를 쓰면 1에서19까지를 1000번을 호출해도 아래와 같이 간단히 바꿀수 있다.funtion numbering() {    while(i &lt; 20&gt;){    document.write(i);    i +=1;}for(var i = 1; i &lt; 1000; i++){    numbering();}물론 함수를 사용하지 않고 for문과 while로도 호출이 가능하다.for(var i = 1; i &lt; 1000; i++){    var i = 0;    while(i &lt; 20&gt;){        document.write(i);        i +=1;    }}위의 두코드의 차이점은 반복문은 반복문 안에서만 실행이 되고 함수는 다른 여러곳에서도 호출하여 사용할 수 있다는 점이다. 핵심은 재사용성이고 이말은 이 함수를 사용하고 있는 여러곳 에서 이함수의 내용을 변경, 개선한다고 하면 함수만 변경하면 사용하는 여러곳 에서 변경이되기 때문에 유지보수가 용이하게 된다.3. 함수의 입력과 출력함수의 핵심은 입력과 출력이다. 입력된 값을 연산해서 출력하는 것이 함수의 기본적인 역할이다. 다음은 함수에서 입력과 출력의 역할을 하는 구문들에 대한 설명이다.함수의 출력return함수 내에서 사용한 return은 return 뒤에 따라오는 값을 함수의 결과로 반환한다. 동시에 함수를 종료시킨다. 아래 내용을 보자. 결과는 egoing과 k8805다.function get_member1(){    return 'egoing';} function get_member2(){    return 'k8805';} alert(get_member1());alert(get_member2());아래 함수를 실행시켜보면 ‘egoing’만 출력하고 함수가 종료된다. return뒤의 내용은 출력하지 않는다.function get_member(){    return 'egoing';    return 'k8805';    return 'sorialgi';}alert(get_member());인자인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다. 다음 예를보자.앞에서본 함수와는 다르게 함수명 뒤에 1과 2가 들어가있다. 이말은 get_argument라는 함수를 호출할때 숫자 1과2를 넣어준다는 말이 된다. 숫자가 들어가는 arg는 변수가된다. arg=1, arg=2라는 뜻이 되는것이다. return이지만 2번을 호출했기 떄문에 1000,2000 의 값이 출력 된다.function get_argument(arg){ //arg는 매개변수 또는 parameter라고 부른다.    return arg*1000;} alert(get_argument(1)); // 1과 2를 인자 argument라고 한다.alert(get_argument(2));복수의 인자인자를 여러개의 사용할수도 있다. 첫번째 두번째 인자가 차례로 arg1와 arg2로 들어가게 되고 30 , 50의 값이 출력 되게 된다.function get_arguments(arg1, arg2){    return arg1 + arg2} alert(get_arguments(10, 20));alert(get_arguments(20, 30));4. 다양한 함수 정의 방법함수를 정의하는 다른 방법을 알아보자.우리가 위에서 작성한 함수와는 조금 다르다. function내의 함수 내용이 numbering이라는 변수에 대입되어 변수가 함수를 가지게 된것이다.var numbering = function (){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }numbering();아래의 함수와 위의 함수는 같다.function numbering() {    var i = 0;    while(1 &lt; 10) {        document.write(i);        i += i;    }}아래 함수는 이름을 정하지도 않고 변수도 붙이지 않았다. 함수를 정의하고 함수를 괄호로 묶었다. 그다음에 호출할때 사용하는 기호 ();로 호출하게 되면 정의와 호출을 하나의 문장으로 같이하는 함수로 익명함수라고 한다. 일회 성으로 호출할때 이런 함수를 사용한다.(function(){    i = 0;    while(i &lt; 10){        document.write(i);        i += 1;    }   }) ();",
        "url": "/javascript-basic6"
    }
    ,
    
    "javascript-basic5": {
        "title": "Javascript - JavaScript 반복문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 반복문1. 반복문 기본문법-while반복문(Loop iterate)은 사람이 하기힘든 반복 작업을 하기위해 사용하고, 몇가지 문법이 있다.whilewhile의 형식은 아래와같다. 조건이 true인 동안에 { } 안의 데이터를 반복하게 된다.while (조건){    반복해서 실행할 코드}2. 반복조건반복조건이 없다면 반복문이 무한대로 실행이되게된다. 반복조건을 설정해 적당한 시기에 반복이 정지하도록 해줘야한다.아래 예제는 i의 시작값을 0으로 정했고 한번씩 반복 할때마다 ‘coding everybody ‘문장이 실행되고 i가 1씩 늘어나게 된다. i의 값이 9가되면 반복을 멈추게 된다.var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++}3. for문for문의 형식은 아래와 같다. while 과 for문은 둘다 반복문이고 대체가능하다.for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){    반복해서 실행될 코드}for(var i = 0; i &lt; 10; i++){   // i = i + 1 과 i ++는 같다.    document.write('coding everybody'+i+'&lt;br /&gt;');}i++는 해당 구문을 실행할때마다 i값을 1씩 증가시킨다는 말이다. i=0이라고 시작하면 0부터 시작하게 된다.++i는 해당 구문을 실행할때부터 1을 증가시킨채 실행한다. i=0이라고하면 시작부터 1로 시작한다.4. 반복문의 효용성반복문이 없다면 코드를 복사해서 붙여넣기 하면 된다. 하지만 반복 횟수가 많아지면 많아질수록 힘들어질 것이다. 아래 예제의 두 코드는 같은 내용이다. 어떤 작업이 더 편할까?document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');document.write('coding everybody');var i = 0;while(i &lt; 10){    document.write('coding everybody &lt;br /&gt;');    i++;}그런데 ‘coding everybody’뒤에 순서를 써야하고 그 양이 많다면 불가능해 질것이다. 반복문으로 코드를 작성하면 간단하다.var i = 0;while(i &lt; 10) {    document.write('coding everybody' + i + &lt;br/&gt;);}5. 반복문의 제어반복문을 강제 정지시키거나 정지후 재시작 하기위한 명령어를 알아보자.breakbreak는 반복문을 중간에 중단시키게 해준다. 아래 예제는 0~4까지 출력하고 중단하게 된다.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        break;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}continuecontinue는 지정된 부분에선 반복을 중단하고 반복을 재시작할 수 있게 해준다. 아래의 코드를 실행해보자.for(var i = 0; i &lt; 10; i++){    if(i === 5) {        continue;    }    document.write('coding everybody'+i+'&lt;br /&gt;');}i===5에서 continue를 하겠다고 했기때문에 i의 값이 5가되었을 때는 실행을 중단하고 다음 i값부터 다시 반복하게 된다.coding everybody 0coding everybody 1coding everybody 2coding everybody 3coding everybody 4coding everybody 6coding everybody 7coding everybody 8coding everybody 96. 반복문의 중첩사용과 디버거반복문안에 반복문을 중첩해 사용할수 있다. 아래 예제에선 i와j를 0~9까지 반복하고 그i와j는 숫자이고 숫자끼리 더해지게 되는데 아래 처럼 문자열과 숫자의 결합하는 경우 javascript는 숫자인 부분을 문자로 변환해 준다.for(var i = 0; i &lt; 10; i++){    for(var j = 0; j &lt; 10; j++ ) {    document.write('coding everybody' + i + j + '&lt;br /&gt;');    }}위코드를 실행해 보면 00~99까지의 i와j가 출력된다.디버거우리가 만든 코드의 버그를 확인하고 코드 실행 순서를 볼 수 있는 기능을 알아보자. F12키를 눌러 개발자도구를 열고 console로 들어가 보고자 하는 줄의 코드를 선택하고 F5를 눌러 새로고침한다.그리고 버튼을 활용해 실행 순서를 확인해 보자.",
        "url": "/javascript-basic5"
    }
    ,
    
    "javascript-basic4": {
        "title": "Javascript - JavaScript 조건문",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 조건문1. 조건문이란?조건문(Conditional statement)은 if로 시작한다.if뒤에는 반드시 true나 false로 두개의 값중에 하나가 온다. 그뒤 중괄호안에 조건이 들어오게 된다.아래의 예제는 true를 출력할것이다. if뒤가로에 true가 오게되면 중괄호 안의 내용이 실행된다.if(true){    alert('result : true');이번엔 아무것도 출력하지 않는다. if뒤에 false가오면 중괄호 안의 내용을 실행하지 않는다.if(false){    alert('result : true');12345를 출력 할것이다.if(true){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);5만 출력한다. false기 때문에 중괄호 안의 내용은 실행하지 않는다.if(false){    alert(1);    alert(2);    alert(3);    alert(4);}alert(5);2. else, else ifif만으로는 조건문을 사용하는데에 제약이 있다. else와 else if는 더 다양하게 조건문을 응용할 수 있게 해준다.elseif뒤 true가 있다면 중괄호 안의 내용이 실행이 되고, else는 실행이 되지 않는다. 만약에 참 이라면 if중괄호가 실행후 else는 무시하고 결과는 1이된다.if(true){    alert(1);} else {    alert(2);}if뒤에 false가 있다면 중괄호 안의 내용이 실행이 안되고, 만약에 거짓이라면 else가 실행이 된고 결과는 2다.if(false){    alert(1);} else {    alert(2);}else if아래 코드에 대한 해석을 해보자. 1번에서 if뒤의 false로 2번alert(1)이 실행되지 않고 다음으로 넘어간다. 3번코드 else에선 1번에서 if가 false기 때문에 실행이 되고 else뒤의 if가 true이기 때문에 2라는 값이 출력된다. 4번이 실행 되었기 때문에 5와 7의 else가 실행될수 없다. 그대로 2만 출력 할 것이다.if(false){       //1    alert(1);    //2} else if(true){ //3    alert(2);    //4} else if(true){ //5    alert(3);    //6} else {         //7    alert(4);    //8}아래 코드도 해석해보면 3이 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(true){    alert(3);} else {    alert(4);}아래 코드도 해석해보면 4가 출력된다는 걸 알 수 있다.if(false){    alert(1);} else if(false){    alert(2);} else if(false){    alert(3);} else {    alert(4);}3. 조건문의 응용변수와 비교연산자if(true) {    alert(1);}위와 같은 코드는 javascript에서 쓸일이 없다. 무조건 1이 출력이 되기 때문이다. 조건문과 변수가 만나 상황에 따라 가변적인 요소가 되어야 조건문이라 할수 있다. prompt라는 구문을 사용해야 하는데 prompt는 사용자가 입력한 값을 가져와서 변수의 값으로 대입해준다. 예제를 통해 더 알아보자.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.') //prompt를 통해 사용자가 입력한 값을 id라는 변수에 적용        if(id=='Ahnsang'){            alert('아이디가 일치 합니다.')        } else {            alert('아이디가 일치하지 않습니다.')        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;위의 예제를 응용해 아이디와 비밀번호 모두 사용하게 해보자. 아이디가 일치하면 비밀번호를 물어볼 필요가 없다. id 변수에 입력한 값이 if id의 조건문에서 아이디가 일치한다면 if password에서 prompt를 통해 비밀번호를 요구한다. 그렇게 되면 입력한 비밀번호가 password라는 변수에 담겨서 입력 값과 111111라는 password와 일치하면 로그인 하셨습니다. 다르다면 비밀번호가 다릅니다라는 메세지가 나오게 된다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        if(id=='Ahnsang'){            password = prompt('비밀번호를 입력해주세요.');            if(password==='111111'){                alert('로그인 했습니다.');            } else {                alert('비밀번호를 확인해 주세요.');            }        } else {            alert('아이디를 확인해 주세요.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4. 논리 연산자논리 연산자는 조건문을 더 간결하고 다양하게 사용할수 있다.&amp;&amp;&amp;&amp;는 좌항과 우항이 모두 참(true)일때 참이된다. 아래 예제에선 1이라는 값이 출력된다. 이러한 연산자를 and연산자라고 한다.if(true &amp;&amp; true){    alert(1);}if(true &amp;&amp; false){    alert(2);}if(false &amp;&amp; true){    alert(3);}if(false &amp;&amp; false){    alert(4);}아래 예제에선 논리연산자 중 and연산자를 활용한 것 이다. 두 변수를 동시에 호출하기 위해 id와 password를 prompt로 호출해주고 &amp;&amp; 연산자로 둘의 값이 모두 참일때만 ‘인증했습니다.’라는 메세지를 출력 하게되고 하나라도 다르다면 ‘인증에 실패 했습니다.’ 라는 값을 출력하게 된다. and연산자는 2개 이상도 사용할 수 있다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"/&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        id = prompt('아이디를 입력해주세요.');        password = prompt('비밀번호를 입력해주세요.');        if(id=='Ahnsang' &amp;&amp; password=='111111'){            alert('인증 했습니다.');        } else {            alert('인증에 실패 했습니다.');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;||||는 ||의 좌우항 하나라도 참이라면 참이 되고 둘다 거짓일때 거짓이 되는 연산자 이다. 예제는 1, 2, 3이 출력되고 ||는 or연산자 라고 한다.if(true || true){    alert(1);}if(true || false){    alert(2);}if(false || true){    alert(3);}if(false || false){ //둘다 false기 때문에 false    alert(4);}아래 예제는 Ahnsang, Ahnsang1, Ahnsang2 값중 하나라도 변수값에 들어오면 ‘인증 했습니다.’라는 값을 출력하게 될것이다.id = prompt('아이디를 입력해주세요.');if(id==='Ahnsang' || id==='Ahsang1' || id==='Ahnsang2'){    alert('인증 했습니다.');} else {    alert('인증에 실패 했습니다.');}다음예제는 or와 and를 사용하는 방법이다.id 비교를 할 때 괄호를 사용한 것은 사칙 연산을 할 때 괄호부터 계산하는 것과 같은 원리다. 세개의 id중 하나라도 맞고 password가 111111이면 로그인 했습니다 라는 값이 출력된다.id = prompt('아이디를 입력해 주세요')password = prompt('비밀번호를 입력해 주세요.')if(id === 'Ahnsang' || id === 'Ahnsang1' || id === 'Ahnsang2' &amp;&amp; password = '111111') {    alert('로그인 했습니다.')}   else {    alert('로그인 실패 했습니다.')}!!는 부정의 의미로 true나 false 앞에 !를 붙이면 값을 역전시킨다. not 연산자 라고 부른다. 아래 에제에서 !를 사용하면 어떻게 되는지 확인하자. 값은 4이다.if(!true &amp;&amp; !true){ //false false 이기 때문에 &amp;&amp;연산자 에선 실행되지 않는다.    alert(1);}if(!false &amp;&amp; !true){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(2);}if(!true &amp;&amp; !false){ //true false &amp;&amp;는 둘다 참이어야 실행한다.    alert(3);}if(!false &amp;&amp; !false){ //true true기 때문에 실행한다.    alert(4);}5.boolean의 대체제0과 1조건문에 사용될 수 있는 데이터 형이 꼭 불린만 되는 것은 아니다. 관습적인 이유로 0는 false 0이 아닌 값은 true로 간주된다. 아래의 예제는 2를 출력한다.if(0){    alert(1)}if(1){    alert(2)}그외의 false로 간주되는 데이터if(!''){    alert('빈 문자열')}if(!undefined){    alert('undefined');}var a;if(!a){    alert('값이 할당되지 않은 변수'); }if(!null){    alert('null');}if(!NaN){    alert('NaN');}",
        "url": "/javascript-basic4"
    }
    ,
    
    "javascript-basic3": {
        "title": "Javascript - JavaScript 변수, 비교",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 변수, 비교변수1. 변수의 사용법변수(Variable)는 문자나 숫자같은 값을 담는 컨테이너로 값을 유지할 필요가 있을때 사용한다. 담겨진 값은 다른 값으로 바꿀수 있고 var로 변수를 선언할수 있다. 생략도 가능하지만 var의 의미를 명확하게 이해하기 전에는 var를 사용하는 것이 좋겠다. 예제를 보자.var a = 1;alert(a+1);  //2 var a = 2;alert(a+1);  //3var first = \"coding\";alert(first+\" everybody\"); //coding everyday//변수 a에 coding ,변수 b에 everybody를 활당하는 방법은 아래와 같다.var a = 'coding', b = 'everybody';alert(a);alert(b);2. 변수의 효용변수는 코드의 재활용성을 높여준다. 반복해서 100에서 10을 빼고 더하고 나누는 계산을 해야하는 코드가 있다고 가정해보고 변수가 없다면 100에관한 숫자 데이터를 모두 수정해야 할것이다. 여기서 변수를 적용하면 변수 값만 바꿔주면 된다.//변수를 쓰기 전alert(100+10);alert((100+10)/10);alert(((100+10)/10)-10);alert((((100+10)/10)-10)*10);// 변수 사용 후a = 100; //변할수 있는a = a + 10; //변하지 않는alert(a);a = a / 10;alert(a);a = a - 10;alert(a);a = a * 10;      alert(a);변수를 쓰지 않은 코드보다 쓴 코드가 더 길기때문에 비효율 적으로 보일수 있으나 코드가 천줄 만줄이라고 생각하면 변수를 쓰는게 좋을것이다.코딩을 할때 위의 주석처럼 구획을 나누어 놓는게 좋다. 변할수 있는 부분이 군데군데 들어가 있다면 그것을 찾아서 수정해야한다. 그럴경우 유지보수가 힘들어진다.비교1.연산자비교는 조건문을 쓸때 꼭 필요하다. 비교 기능 자체는 효용이 크지 않지만 조건문을 사용하기 위해 꼭 필요하다.연산자란 간단하게 말해 = 이다. 변수에 값을 대입할때 사용한다.a=1 //변수 대입연산자 값2. 비교 연산자 (==과===)비교 연산자는 말그대로 비교하고 판별할때 사용한다. 좌항과 우항중 뭐가 작고 큰지 또는 같은지 등을 판별한다. 비교연산자의 결과는 true나 false둘중 하나다. true와 false형식을 블린 데이터라고 부르고 역시 조건문에서 중요하게 사용한다.== ==는 동등연산자로 좌항과 우항의 값이 같다면 true 다르다면 false가 된다.=와 ==는 전혀 다르기 때문에 주의해야한다.alert(A==B)             //falsealert(A==A)             //truealert(\"one\"==\"two\")     //false alert(\"one\"==\"one\")     //true=== === 일치 연산자라고 하고 좌항과 우항이 정확하게 같을때 같다면 true 다르다면 false가 된다. 여기서 정확하게는 아래 코드처럼 형식까지 일치해야 한다는 말이다. 1과 ‘1’은 숫자와 숫자를 문자화시킨 데이터이다. 결론은 ==보다 ===를 쓰는것이 좋겠다.alert(1=='1');              //truealert(1==='1');             //false3.===를 사용하자null과 undefined는 값이 없다는 의미의 데이터 형이다. var a; 라는 코드를 쓰고 alert(a); 를 하면 undefined라는 경고창이 나온다. 값이 정의되지 않았다는 뜻이다. 그리고 var a=null; alert(a);를 하면null이라는 경고창이 나온다. 이말은 작성한사람이 의도적으로 값이 없다는것을 지정한것이다.이말은 프로그래밍에서 의도한것과 의도하지 않은것은 전혀 다른것이다.alert(null == undefined);       //truealert(null === undefined);      //falsealert(true == 1);               //truealert(true === 1);              //falsealert(true == '1');             //truealert(true === '1');            //false alert(0 === -0);                //truealert(NaN === NaN);             //false NaN(Not-a-Number)은 이값은 숫자가 아님을 의미한다.                   //그래서 NaN생성의 가능성이 있는 코드는 비교 연산을 실행하면 안되겠다.4.부정과 부등호!=!는 부정을 의미한다. 1==2는 false다 하지만 1!=2는 true가 된다. 같지 않은게 사실이기 때문이다.alert(1!=2);            //truealert(1!=1);            //falsealert(\"one\"!=\"two\");    //truealert(\"one\"!=\"one\");    //false!==!==는 ===에 부정을 부여한 것으로 정확하게 같지 않다는 의미이다.&gt;좌항과 우항을 비교해주는 연산자로 좌항이 더 크다는것을 의미한다. 더크면 true 작으면 false이다.&lt;는 반대의 의미이다.alert(10&gt;20);   //falsealert(10&gt;1);    //truealert(10&gt;10);   //false&gt;=좌항이 우항보다 크거나 같다는 의미이다. &lt;=는 반대의 의미이고 =&gt;, =&lt;식의 표현은 불가하다.alert(10&gt;=20);      //falsealert(10&gt;=1);       //truealert(10&gt;=10);      //true",
        "url": "/javascript-basic3"
    }
    ,
    
    "javascript-basic2": {
        "title": "Javascript - JavaScript 숫자와 문자",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 숫자와 문자1. 수의 표현 javascript는 큰따옴표나 작은 따옴표가 붙지 않은 숫자는 숫자로 인식한다.정수, 자연수, 실수 모두 사용가능하고 모두 숫자로 인식한다.javascript에선 포괄적으로 number라고 부르고 다른 프로그래밍 언어들 보다 덜 엄격한 편이다.수식으로는 더하기는 + 빼기는 - 나누기는 / 곱셈은 * 으로 표현한다.2. 수의 연산javascript는 계산 기능이 있는데 우리가 흔히 쓰는 수식과는 조금 다르기 때문에 그 방법을 알아두는게 좋겠다.아래 코드에 아직 배우지 않은 부분이 있는데 뒤에서 자세히 배워볼 예정이다.Math.pow(3,2);       // 9,   3의 2승 Math.round(10.6);    // 11,  10.6을 반올림Math.ceil(10.2);     // 11,  10.2를 올림Math.floor(10.6);    // 10,  10.6을 내림Math.sqrt(9);        // 3,   3의 제곱근Math.random();       // 0부터 1.0 사이의 랜덤한 숫자3. 문자””,’‘내에 들어가는 내용은 javascript가 문자로 인식한다.데이터를 입력하면 javascript는 문자와 숫자를 인식하게 된다.숫자를 “A”나 ‘A’로 감싸면 문자로 인식하게 된다.우리가 작성한 데이터 값은 typeof 라는 명령을 사용하면 데이터의 형식을 알수있다.문자는 string 숫자는 number라는 결과가 나온다.alert(typeof \"1\") //결과 : string \"내용' 이런식의 기입은 할수 없음을 알아두자.여러줄로 표시하기 위해서는 \\n을 사용할 수 있다.alert(\"왔냐.\\n 코딩 연습장이다\")또한 데이터를 입력하다 보면 ‘이나 “ ex)alert(‘egoing’s coding everyday’) 등을 사용 해야할 때가 이있는데 이럴땐 \\뒤에 해당 기호를 넣어 문자로 인식하게 할수 있다.alert(\"egoing's coding everyday\") // \"\"사이에 '가 들어 있기 때문에 사용 가능하다.arlert('egoing\\'s coding everyday')// 역슬래쉬 \\뒤의 어떠한 기호는 문자로 해석된다. escape라고 한다.4. 문자의 연산1+1은 2이다 하지만 “1”+”1”은 “11”이된다. 숫자와 문자의 연산은 전혀 다르다.문자를 더하는 표현은 아래와 같다.alert(\"Ahns\"+\" Coding Gym\") //결과 : Ahns Coding Gym문자의 길이를 구할때는 문자 뒤에 .length를 붙여준다.alert(\"Ahns Coding Gym\".length) //결과 : 15 ",
        "url": "/javascript-basic2"
    }
    ,
    
    "javascript-basic": {
        "title": "Javascript - JavaScript 기본",
            "author": "AhnSang0915",
            "category": "",
            "content": "Javascript    JavaScript 기본     JavaScript 숫자와 문자     JavaScript 변수, 비교    JavaScript 조건문    JavaScript 반복문    JavaScript 함수    JavaScript 배열    JavaScript 객체(Object)    JavaScript 모듈    JavaScript UI와 API    JavaScript 정규표현식    JavaScript 함수지향 - 유효범위    JavaScript 함수지향 - 값으로서의 함수와 콜백    JavaScript 함수지향 - 클로저    JavaScript 함수지향 - arguments    함수지향 - 함수의 호출    객체지향 - 객체지향 프로그래밍 소개    객체지향 - 생성자와 new    객체지향 - 전역객체    객체지향 - this    객체지향 - 상속    객체지향-표준 내장객체의 확장    JavaScript 객체지향-ObjectJavaScript 기본1. 주석 (Comment)주석은 JavaScript Code외의 우리가 쓰는 문자로 사용되는 내용을 말한다.코드 내용에대한 부연설명이나 함수에 대한 기능을 작성할수 있고 불필요한 코드의 실행을 막을수 있다.JavaScript주석의 코드 사용 방법한줄 주석의 경우 - // 내용여러 줄의 경우 - /* 내용 */ 로 사용한다// 한줄 주석 사용시/*     여러줄     주석     사용시*/2. 줄바꿈과 여백JavaScript의 경우 명령이 끝났다는걸 알려주기 위해 ;를 표시해준다 줄바꿈을 할 경우엔 JavaScript에서 자동으로 명령이 끝났다고 판단하지만 한줄에 여러 명령을 쓸 경우가 있어 명령어 뒤엔 ;를 붙여주는게 좋다.    &lt;script type=\"text/javascript\"&gt;        var a = 1; //;을 안넣어도 줄이 바뀌면 명령이 끝났다고 인식한다        alert(a);    &lt;/script&gt;위 코드에서 ;기호를 없애도 줄바꿈을 했기 때문에 명령이 끝났다고 인식할 것 이다.하지만    &lt;script type=\"text/javascript\"&gt;        var a = 1; alert(a); //;가 없다면 var a = 1alert(a) 가 될것이다.            &lt;/script&gt;이런 경우엔 ;가 없다면 하나의 명령이 될 것이다.( var 뒤 띄어쓰기를 해야 하고 =양쪽엔 하지 않아도 된다.)그리고 코드를 썼는데 코드가 다닥다닥 붙어 있다면 코드를 보기 힘들 것이다. 가독성이 좋지 않다는 말이다. Tap키를 명령어와 함수 사이에 적절히 사용해 좀 더 보기 좋게 하는 게 좋을 것이다.",
        "url": "/javascript-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://AhnSang0915.github.io/">My Coding Practice Gym</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search My Coding Practice Gym</h1>
                <p class="subscribe-overlay-description">
                블로그 포스팅 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
